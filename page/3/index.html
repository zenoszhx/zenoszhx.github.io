<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>ArrayStars</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="ArrayStars">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="ArrayStars">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ArrayStars">
  
    <link rel="alternate" href="/atom.xml" title="ArrayStars" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ArrayStars</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一些个人的总结，辩证来看，不保证完全正确。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Cocos-C++/6.3 可变速度类" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/6.3 可变速度类/" class="article-date">
  <time datetime="2018-11-24T03:37:30.715Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/6.3 可变速度类/">6.3 可变速度类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="可变速度类"><a href="#可变速度类" class="headerlink" title="可变速度类"></a>可变速度类</h1><p>ActionEase是ActionInterval的派生子类，这种继承关系使得任何一个可变速动作类的对象才能参与到组合动作当中。</p>
<p>速度变化动作不是指改变动作目标的速度，而是指动作本身的执行速度。</p>
<h3 id="1-EaseIn、EaseOut、EaseInOut"><a href="#1-EaseIn、EaseOut、EaseInOut" class="headerlink" title="1.EaseIn、EaseOut、EaseInOut"></a>1.EaseIn、EaseOut、EaseInOut</h3><p>1).EaseIn表示的一个由慢至快的过程。</p>
<p>2).EaseOut表示一个由快至慢的过程。</p>
<p>3).EaseInOut表示一个由慢至快再由快至慢的过程。</p>
<pre><code>static EaseRateAction * create(ActionInterval *action, float rate);
// 第一个参数为其他类对象，第二个是速度变化类参数。
</code></pre><h5 id="1-1-示例"><a href="#1-1-示例" class="headerlink" title="1.1 示例"></a>1.1 示例</h5><pre><code>void SpriteEase::onEnter()
{
    EaseSpriteDemo::onEnter();

    Size s = Director::getInstance()-&gt;getWinSize();

    // 基本动作
    ActionInterval *move = MoveBy::create(3, Vec2(s.width-130, 0));
    ActionInterval *move_back = move-&gt;reverse();

    // 加速动作
    ActionInterval *move_ease_in = EaseIn::create((ActionInterval *)(move-&gt;copy()-&gt;autorelease()), 2.5f);
    ActionInterval *move_ease_in_back = move_ease_in-&gt;reverse();

    // 减速动作
    ActionInterval *move_ease_out = EaseOut::create((ActionInterval *)(move-&gt;copy()-&gt;autorelease()), 2.5f);
    ActionInterval *move_ease_out_back = move_ease_out-&gt;reverse()

    // 延时动作
    DelayTime *delay = DelayTime::crete(0.25f);

    // 序列动作
    FiniteTimeAction* seq1 = Sequence::create(move, delay, move_back, CCCA(delay), NULL);
    FiniteTimeAction* seq2 = Sequence::create(move_eses_in, CCCA(delay), move_ease_in_back, CCCA(delay), NULL);
    FiniteTimeAction* seq3 = Sequence::create(move_ease_out, CCCA(delay), move_ease_out_back, CCCA(delay), NULL);

    Action *a2 = m_grossini-&gt;runAction(RepeatForever::create((ActionInterval *)seq1));
    Action *a1 = m_tamara-&gt;runAction(RepeatForever::create((ActionInterval *)seq2));
    Action *a  = m_kathia-&gt;runAction(RepeatForever::create((ActionINterval *)weq3));

    schedule(schedule_selector(SpriteEase::testStopAction), 6.25f);
}
</code></pre><h3 id="2-EaseSineIn、EaseSineOut、EaseSineInOut"><a href="#2-EaseSineIn、EaseSineOut、EaseSineInOut" class="headerlink" title="2.EaseSineIn、EaseSineOut、EaseSineInOut"></a>2.EaseSineIn、EaseSineOut、EaseSineInOut</h3><p>此动作组的变化速率不再是依据加速度的方式，而是依据正弦函数来进行的。</p>
<h3 id="3-EaseBackIn、EaseBackOut、EaseBackInOut"><a href="#3-EaseBackIn、EaseBackOut、EaseBackInOut" class="headerlink" title="3.EaseBackIn、EaseBackOut、EaseBackInOut"></a>3.EaseBackIn、EaseBackOut、EaseBackInOut</h3><p>此类动作的变化速率量反向的，在基动作变化之前首先报告一下反向动作，然后才会继续执行原本动作。</p>
<h3 id="4-EaseExponentialln、EaseExponentialOut、EaseExponentiallnOut"><a href="#4-EaseExponentialln、EaseExponentialOut、EaseExponentiallnOut" class="headerlink" title="4.EaseExponentialln、EaseExponentialOut、EaseExponentiallnOut"></a>4.EaseExponentialln、EaseExponentialOut、EaseExponentiallnOut</h3><p>此可变动作速率的变化将会按照指数增量的方式来增长。</p>
<h3 id="5-EaseBouncelIn、EaseBouncelOut、EaseBouncelInOut"><a href="#5-EaseBouncelIn、EaseBouncelOut、EaseBouncelInOut" class="headerlink" title="5.EaseBouncelIn、EaseBouncelOut、EaseBouncelInOut"></a>5.EaseBouncelIn、EaseBouncelOut、EaseBouncelInOut</h3><p>此可变动作的方式是反弹变化。</p>
<h3 id="6-EaseElasticIn、EaseElasticOut、EaseElasticInOut"><a href="#6-EaseElasticIn、EaseElasticOut、EaseElasticInOut" class="headerlink" title="6.EaseElasticIn、EaseElasticOut、EaseElasticInOut"></a>6.EaseElasticIn、EaseElasticOut、EaseElasticInOut</h3><p>伸缩方式</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/6.3 可变速度类/" data-id="cjov31rko004n88riqrl0dptm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/6.2 组合动作类" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/6.2 组合动作类/" class="article-date">
  <time datetime="2018-11-24T03:37:30.713Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/6.2 组合动作类/">6.2 组合动作类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#组合动作类</p>
<p>Cocos2D-x提供了一些将其他动作进行组合的类，好比是动作对象的一个容器，在组合类中的对象将会按照一定的规则来执行。</p>
<h3 id="1-序列动作类（Sequence）"><a href="#1-序列动作类（Sequence）" class="headerlink" title="1.序列动作类（Sequence）"></a>1.序列动作类（Sequence）</h3><p>Sequence是由ActionInterval派生来的，因此它也是一个与时间有关的类。</p>
<h5 id="1-1序列动作的创建函数"><a href="#1-1序列动作的创建函数" class="headerlink" title="1.1序列动作的创建函数"></a>1.1序列动作的创建函数</h5><pre><code>// 1.根据参数中动作数组指针，来创建序列动作
static Sequence* create(FiniteTimeAction *action1, ...) CC_REQUIRES_NULL_TERMINATION;

// 2.根据参数中动作数组，来创建序列动作
static Sequence* create(const Vector&lt;FiniteTimeAction*&gt;&amp; arrayOfActions);

// 3.根据参数中第一个动作对象和第二个动作对象来创建序列动作
static Sequence* createWithActions(FiniteTimeAction *actionOne, FiniteTimeAction *actionTwo)
</code></pre><h5 id="1-2-示例"><a href="#1-2-示例" class="headerlink" title="1.2 示例"></a>1.2 示例</h5><pre><code>void ActionSequence2::onEnter()
{
    ActionsDemo::onEnter();

    alignSpriteLeft(1);

    m_grossini-&gt;setVisible(false);

    FiniteTimeAction* action = Sequence::create(
        Place::create(Vec2(200, 200)),
        Show::create(),
        MoveBy::create(1, Vec2(100, 0)),
        CallFunc::create(CC_CALLBACK_0(ActionCallFunc::callback, this)),
        CallFuncN::create(CC_CALLBACK_1(ActionCallFuncN::callback, this)),
        CallFuncND::create(CC_CALLBACK_1(ActionCallFuncN::callback, this, true)),
    );

    m_grossini-&gt;runAction(action);
}

(1)序列动作中的对象会一个个的被Node对象执行
</code></pre><h3 id="2-同步动作类（Spawn）"><a href="#2-同步动作类（Spawn）" class="headerlink" title="2.同步动作类（Spawn）"></a>2.同步动作类（Spawn）</h3><p>该类与序列动作的区别是，它使得Node对象可以同时执行若干个动作。</p>
<p>在同步动作中要求其同步动作对象必须是可以继续执行的，比如：翻转、变色、尺寸、透明度的变化。</p>
<p>示例代码：</p>
<pre><code>void ActionSpawn::onEnter()
{
    ActionsDemo::onEnter();

    alignSpritesLeft(1);
    Action* action = Spawn::create(
         JumpBy::create(2, Vec2(300, 0), 50, 4)，
        RotateBy::create(2, 720),
        NULL，
    );

    m_grossini-&gt;runAction(action);
}
</code></pre><h3 id="3-重复动作类（Repeat-amp-RepeatForever）"><a href="#3-重复动作类（Repeat-amp-RepeatForever）" class="headerlink" title="3.重复动作类（Repeat &amp; RepeatForever）"></a>3.重复动作类（Repeat &amp; RepeatForever）</h3><p>Repeat和RepeatForever派生自ActionInterval，且ActionForever不是Repeat的子类，而是由类ActionInterver直接派生的。它可以使用任何对象作为参数，单个的基本动作对象、序列动作、同步动作。创建函数如下：</p>
<pre><code>static Repeat* create(FiniteTimeAction *action, unsigned int times);

（1）第一个参数为重复的动作对象,第二个参数为重复的次数。如果是RepeatForever则没有第二个参数。
</code></pre><p>示例：</p>
<pre><code>void ActionRotateToRepeat::onEnter()
{
    ActionDemo::onEnter();

    centerSprites(2);

    ActionInterval* act1 = RotateTo::create(1, 90);
    ActionInterval* act2 = RotateTo::create(1, 0);
    ActionInterval* seq = (ActionInterval *)(Sequence::create(act1, act2, NULL));

    Action* rep1 = RepeatForever(seq);
    ActionIntervel* rep2 = Repeat::create((FiniteTimeAction*)(seq-&gt;copy()-&gt;autorelease()), 10);

    m_tamata-&gt;runAction(rep1);
    m_kathis-&gt;runAction(rep2);
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/6.2 组合动作类/" data-id="cjov31rkm004j88rij2qvfjaj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/6.1 时间动作" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/6.1 时间动作/" class="article-date">
  <time datetime="2018-11-24T03:37:30.711Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/6.1 时间动作/">6.1 时间动作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="时间动作"><a href="#时间动作" class="headerlink" title="时间动作"></a>时间动作</h1><p>动作基类Action首要的继承子类，其实就是FiniteTimeAction类。并且在类中加入了一个与时间有关的成员变量，同时提供了如下两个操作函数。</p>
<pre><code>// 返回动作执行的间隔时间，以秒为单位
float getDuration(void);

// 设置动作执行的时间间隔
void setDuration(float duration);
</code></pre><h3 id="1-即时动作"><a href="#1-即时动作" class="headerlink" title="1. 即时动作"></a>1. 即时动作</h3><p>即时动作的父类为ActionInstant，类ActionInstant中只添加了一个只增加了一个函数：</p>
<pre><code>// 返回一个反序动作
virtual FiniteTimeAction * reverse(void);
</code></pre><h5 id="1-1-即时动作具体类"><a href="#1-1-即时动作具体类" class="headerlink" title="1.1 即时动作具体类"></a>1.1 即时动作具体类</h5><p>1).水平与垂直翻转（FilpX和FilpY）</p>
<pre><code>// 创建动作对象
ActionInstant *flipX = FlipX::create(true);
ActionInstant *flipY = FlipY::create(true);
// 执行动作
m_tamara-&gt;runAction(flipX);
m_grossini-&gt;runAction(flipY);
</code></pre><p>2).放置(Place)</p>
<pre><code>void ActionPlace::randomPlace(float dt)
{
    Size s = Director::getInstance()-&gt;getWinSize();
    Vec2 p = Vec2(rand_0_1() * s.width, rand_0_1() * s.height);
    ActionInstant * actionPlace = Place::create(p);
    m_grossini-&gt;runAction(actionPlace);
}
</code></pre><p>3).隐藏和显示（Hide&amp;Show）</p>
<pre><code>// 和Node对象的visible属性是一样的
m_tamara-&gt;runAction(Hide::create());
m_tamata-&gt;runAction(Show::create());
</code></pre><p>4).可见切换（ToggleVisibility）</p>
<pre><code>// 与隐藏、显示的效果类似。如果当前Node对象可见，执行动作会进入不可见状态。
sprite-&gt;runAction(ToggleVisibility::create());
</code></pre><p>5).使用与停止网格（ReuseGrid和StopGrid）</p>
<p>将Node对象显示的画面切换成矩形方块，然后运用各种画面效果。<br>CCReuseGrid的作用是重新使用网格动作。其参数代表了执行次数。<br>CCStopGrid的作用量结束当前网格动作，这里的结束并不终止其他与网格有关的动作，而是在这些动作执行完毕后将其移除。</p>
<p>6).函数调用动作（CallFunc、CallFuncND、CallFuncN、CallFuncO）</p>
<p>与前几个类一样，函数调用的动作也经常会在动作序列当中。比如当移动某个对象到指定的位置之后，需要执行一个函数，这个函数就要依靠函数调用的动作。</p>
<pre><code>// 调用函数动作
ActionInstant *action0 = CallFunc::create(CC_CALLBACK_0(ActionCallFunc::callback1, this));
ActionInstant *action2 = CallFuncN::create(CC_CALLBACK_1(ActionSequence2::callback2, this));
ActionInstant *action3 = CallFuncND::create(CC_CALLBACK_1(ActionSequence2::callback3), this, true);

// 回调函数1
void ActionCallFunc::callBack()
{
    Size s = Director::getInstance()-&gt;getWinSize();
    Label *label = LabelTTF::createWithTTF(&quot;callback 1 calld&quot;, &quot;Marker Felt&quot;, 16);
    label-&gt;setPosition(Vec2(s.width/4*2, s.height/2));
    addChild(label);
}

// 回调函数2
void ActionCallFunc::callback2(Node *pSender)
{
    Size s = Director::getInstance()-&gt;getWinSize();
    Label *label = LabelTTF::createWithTTF(&quot;callback 2 calld&quot;, &quot;Marker Felt&quot;, 16);
    label-&gt;setPosition(Vec2(s.width/4*2, s.height/2));
    addChild(label);
}

// 回调函数3
void ActionCallFunc::callback3(Node *pSender, bool cleanUp)
{
    Size s = Director::getInstance()-&gt;getWinSize();
    Label *label = LabelTTF::createWithTTF(&quot;callback 3 calld&quot;, &quot;Marker Felt&quot;, 16);
    label-&gt;setPosition(Vec2(s.width/4*2, s.height/2));
    addChild(label);
}

1.CallFunc调用的函数为callback1，此调用函数没有任何参数。
2.CallFuncN调用函数为callback2,在其调用自定义函数的时候，当前对象会以参数的形式传递。
3.CallFuncND类调用函数callback3有两个参数，分别为Node对象和Data数据指针。
4.CallFuncO的调用函数则会传递一个Ref指针作为参数。
</code></pre><h3 id="2-持续动作"><a href="#2-持续动作" class="headerlink" title="2. 持续动作"></a>2. 持续动作</h3><p>持续动作的父类ActionInterval是一个类的集合，加入了一个与时间有关的初始化函数：</p>
<pre><code>bool initWithDuration(float d)
</code></pre><h5 id="2-1-与位置有关的持续动作"><a href="#2-1-与位置有关的持续动作" class="headerlink" title="2.1 与位置有关的持续动作"></a>2.1 与位置有关的持续动作</h5><pre><code>// MoveTo
// MoveBy
// JumpTo
// JumpBy

// 贝塞尔曲线
// BezerTo
// BezerBy

ActionInterval *actionTo = MoveTo::create(2, Vec2(80,60));

ActionInterval *actionTo = JumpTo::create(2, Vec2(300, 300), 50, 4);

CcBezierConfig bezier;
bezier.controlPoint_1 = Vec2(0, 100);
bezier.controlPoint_2 = Vec2(300, -100);
bezier.endPosition = Vec(300, 100);
ActionInterver *bezierForward = BezierBy::create(3, bezier);

(1)MoveTo、MoveBy后面的参数表示移动的时间和位置或距离。
(2)JumpTo、JumpBy增加了两个参数，分别为对象的跳跃高度、跳跃次数。
(3)贝塞尔曲线配置类ccBezierConfig包含了3个CGPoint对象，如果读者想要在游戏中进行抛物线，除非使用物理引擎，否则Bezier将会是最佳选择。
</code></pre><h5 id="2-2-缩放的动作类"><a href="#2-2-缩放的动作类" class="headerlink" title="2.2 缩放的动作类"></a>2.2 缩放的动作类</h5><p>ScaleBy、ScaleTo</p>
<pre><code>ActionInterval *actionTo = ScaleTo::create(2.0f, 0.5f);
ActionInterval *actionBy = ScaleBy::create(2.0f, 1.0f, 10.0f);

(1)两个参数的分别表示动作执行时间和尺寸变化的数值。
(2)三个参数的创建函数则是将缩放参数变为X轴和Y轴。
</code></pre><h5 id="2-3-旋转的动作类"><a href="#2-3-旋转的动作类" class="headerlink" title="2.3 旋转的动作类"></a>2.3 旋转的动作类</h5><p>RotateBy、RotateTo</p>
<h5 id="2-4-倾斜的动作类"><a href="#2-4-倾斜的动作类" class="headerlink" title="2.4 倾斜的动作类"></a>2.4 倾斜的动作类</h5><p>SkewTo、SkewBy。倾斜与旋转的动作十分相似，区别在于倾斜动作包括了对象尺寸属性的变化。</p>
<pre><code>ActionInterval *actionTo = SkewTo::create(2, 37.2f, -37.2f);
ActionInterval *actionBy = SkewBy::create(2, 0.0f, -90.0f);

(1)三个参数分别表示持续时间、X轴、Y轴的倾斜角度。
</code></pre><h5 id="2-5-与颜色有关的属性"><a href="#2-5-与颜色有关的属性" class="headerlink" title="2.5 与颜色有关的属性"></a>2.5 与颜色有关的属性</h5><p>FadeIn、FadeOut、FadeTo、TintBy、TintTo、Blink前三个是与透明度相关的函数，后面的一对是通过修改Node对象中的颜色值来体现变化的动作。Blink则是用来实现闪烁效果。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/6.1 时间动作/" data-id="cjov31rkh004c88ri8xhn1o7z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/6. 动作" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/6. 动作/" class="article-date">
  <time datetime="2018-11-24T03:37:30.710Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/6. 动作/">6 动作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h1><h3 id="1-动作基类"><a href="#1-动作基类" class="headerlink" title="1. 动作基类"></a>1. 动作基类</h3><p>Action成员函数：</p>
<pre><code>// 公共函数
Action (void);
virtual ~Action();

const std::string&amp; description();

// 返回bool值表示动作是否完成
virtual bool isDone(void);
// 动作开始之前用来指点动作目标
virtual void startWithTarget(Node *pTarget);
// 动作执行完毕之后，调用的函数
virtual void stop(void);
// 动作执行中按照时间间隔调用的函数，最好不要重写
virtual void step(float dt);
// 动作执行中每帧调用的函数
virtual void update(float time);
// 返回动作执行目标
Node * getTarget(void);
// 设置动作执行坐标
void setTarget(Node *target);
// 得到原始动作执行目标
void getOriginalTarget(void);
// 设置原始动作执行目标
void setOriginalTarget(Node *originalTarget);
// 返回动作的标签
int getTag(void);
// 设置标签
void setTag(int tag);
</code></pre><h3 id="2-Node中与动作有关的函数"><a href="#2-Node中与动作有关的函数" class="headerlink" title="2. Node中与动作有关的函数"></a>2. Node中与动作有关的函数</h3><pre><code>// 执行一个动作，并返回执行的动作
Action *runAction(Action *action);
// 移除所有执行动作
void stopAllActions(void);
// 根据函数参数，移除相应动作
void stopAction(Action *action);
// 根据函数参数，返回对应动作
Action * getActionByTag(int tag);
// 返回当前对象执行动作的总数
ssize_t getNumberOfRuningActions(void);
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/6. 动作/" data-id="cjov31rkk004g88ripapark2q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/4.3 滚动视图类" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/4.3 滚动视图类/" class="article-date">
  <time datetime="2018-11-24T03:37:30.708Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/4.3 滚动视图类/">4.3 滚动视图类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-ScrollView"><a href="#1-ScrollView" class="headerlink" title="1 ScrollView"></a>1 ScrollView</h3><h3 id="2-ListView"><a href="#2-ListView" class="headerlink" title="2 ListView"></a>2 ListView</h3><h3 id="3-TableView"><a href="#3-TableView" class="headerlink" title="3 TableView"></a>3 TableView</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/4.3 滚动视图类/" data-id="cjov31rke004988riw2nn4j1t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/4.2 基础Widget类" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/4.2 基础Widget类/" class="article-date">
  <time datetime="2018-11-24T03:37:30.706Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/4.2 基础Widget类/">4.2 基础Widget类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/4.2 基础Widget类/" data-id="cjov31rk9004288rivzxtsrd6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/4.1 UI布局类" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/4.1 UI布局类/" class="article-date">
  <time datetime="2018-11-24T03:37:30.705Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/4.1 UI布局类/">4.1 UI布局类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-布局因素"><a href="#1-布局因素" class="headerlink" title="1 布局因素"></a>1 布局因素</h3><h3 id="2-布局组件"><a href="#2-布局组件" class="headerlink" title="2 布局组件"></a>2 布局组件</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/4.1 UI布局类/" data-id="cjov31rk7003y88ridjurm24p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/4 UI" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/4 UI/" class="article-date">
  <time datetime="2018-11-24T03:37:30.703Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/4 UI/">4 UI</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/4 UI/" data-id="cjov31rk4003r88riv13552f7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/3.6 文字与字体" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/3.6 文字与字体/" class="article-date">
  <time datetime="2018-11-24T03:37:30.701Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/3.6 文字与字体/">3.6 文字与字体</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="文字与字体"><a href="#文字与字体" class="headerlink" title="文字与字体"></a>文字与字体</h1><p>通常在游戏中存在两种文字方式：美术字及排版字。既美术人员制作的纹理图片和字体库。</p>
<p>下图展示了引擎用于处理文字的三个类：LabelAtlas、LabelBMFont、LabelTTF。</p>
<p><img src="http://7xqzxs.com1.z0.glb.clouddn.com/0114%E6%96%87%E5%AD%97%E5%AD%97%E4%BD%93%E7%BB%A7%E6%89%BF.png" alt=""></p>
<h3 id="1-TTF类型标签"><a href="#1-TTF类型标签" class="headerlink" title="1.TTF类型标签"></a>1.TTF类型标签</h3><p>TTF（True Type Font）从继承关系来看，此类的另一个父类就是Sprite，说明可以把TTF当精灵对象来使用。</p>
<h5 id="1-1-此类标签的优缺点如下："><a href="#1-1-此类标签的优缺点如下：" class="headerlink" title="1.1 此类标签的优缺点如下："></a>1.1 此类标签的优缺点如下：</h5><p>1).TTF字体中包含了某种语言中所有的字母及符号，可以随意调整大小、颜色。</p>
<p>2).TTF标准得到了普及，操作系统中已经提供了多种字体，开发者无需提供任何编辑就可使用。</p>
<p>3).包含内容较多，初始化的时候需要创建纹理图片，所以创建和更新的过程会比较缓慢。</p>
<h5 id="1-2-创建函数"><a href="#1-2-创建函数" class="headerlink" title="1.2 创建函数"></a>1.2 创建函数</h5><pre><code>// 参数为文字内容、字体名称、字体尺寸
static Label create(const std::string&amp; string, const std::string&amp; fontNane, float fontSize);

// 参数为文字内容、字体名称、字体尺寸、标签尺寸、对齐方式
static Label create(const std::string&amp; string, const std::string&amp; fontName, float fontSize, const Size&amp; dimension, CCTextAlignment hAlignment);

// 参数为文字内容、字体名称、字体尺寸、标签尺寸、对齐方式、文字竖直对齐方式
static Label create(const std::string&amp; string, const std::string&amp; fontName, float fontSize, const Size&amp; dimension, CCTextAlignment hAlignment， CCVerticalTextAligment vAlignment);
</code></pre><h3 id="2-BMFont标签"><a href="#2-BMFont标签" class="headerlink" title="2.BMFont标签"></a>2.BMFont标签</h3><p>从继承关系看，BMFont继承自类CCSpriteBatchNode。</p>
<h5 id="2-1-BMFont特点"><a href="#2-1-BMFont特点" class="headerlink" title="2.1 BMFont特点"></a>2.1 BMFont特点</h5><p>1).需要一个图片编辑器， 用于编辑文字的纹理图集。</p>
<p>2).具备了很快的创建以及更新速度。</p>
<p>3).自由度非常的高，每一个字母和符号都是单独的精灵。</p>
<p>4).自制字体的方式，开发者可以自定义其中的字母以及符号，甚至包含阴影。外框及花纹。</p>
<h5 id="2-2-BMFont示例项目"><a href="#2-2-BMFont示例项目" class="headerlink" title="2.2 BMFont示例项目"></a>2.2 BMFont示例项目</h5><pre><code>Atlas3::Atlas3()
{
    m_time = 0;
    // 创建一个颜色图层
    LayerColor* col = LayerColor::create(ccc4(128, 128, 128, 255));
    addChild(col, -1);

    // 使用字体资源文件，创建一个LabelBMFont对象
    LoabelBMFont* label1 = LabelBMFont::create(&quot;Test&quot;, &quot;fonts/bitMapFontTest2.fnt&quot;);
    // 设置字体锚点，以及执行一个淡进淡出的动作效果
    label1-&gt;setAnchorPoint(Vec2(0, 0));
    addChild(lable1, 0, kTagBitmapAtlas1);
    ActionInterval *fade = FadeOut::create(1.0f);
    ActionInterval *fad_in = fade-&gt;reverse();
    FiniteTimeAction *seq = Sequence::create(fade, fade_in, NULL);
    Action *repeat = RepeatForever::create((ActionInterval *)seq);
    label1-&gt;runAction(repeat);

    // 设置位置
    Size s = Director::getInstance()-&gt;getWinSize();
    label1-&gt;setPositon(VisibleRect::leftBottom());

    // 开启定时器回调函数
    schedule(schedule_selector(Atlas3::step))
}

// 更新显示文字
void Atlas3::step(float dt)
{
    m_time += dt;
    char string[15] = {0};

    LabelBMFont *label1 = (LabelBMFont*) getChildByTag(kTagBitmapAtlas1);
    label1-&gt;setString(string);
}
</code></pre><h3 id="3-Atlas标签"><a href="#3-Atlas标签" class="headerlink" title="3.Atlas标签"></a>3.Atlas标签</h3><p>Atlas 标签类的父类是AtlasNode，这是一个纹理图集的类，可以将纹理图片按照矩形区域分隔显示。</p>
<h5 id="3-1-Atlas类的特点"><a href="#3-1-Atlas类的特点" class="headerlink" title="3.1 Atlas类的特点"></a>3.1 Atlas类的特点</h5><p>1).Atlas与TTF类相似，只不过TTF标签会创建一张绘制着文字的图片。而Atlas不会创建任何纹理图片。</p>
<p>2).Atlas标签只会使用源纹理图片进行创建，Atlas创建速度要远远超过TTF。</p>
<p>3).LabelAtlas类中每一个字母或符号都是独特的，它们可以有灵活可变的样式各尺寸。</p>
<p>4).LabelAtlas中字母和符号也是可以由开发者制定。</p>
<pre><code>// 全参数创建函数
static LabelAtlas* create(const std::string&amp; label, const std::string&amp; charMapFile, ssize_t itemWidth, ssize_t itemHeight, ssize_t startCharMap);
</code></pre><h5 id="3-2-示例项目"><a href="#3-2-示例项目" class="headerlink" title="3.2 示例项目"></a>3.2 示例项目</h5><pre><code>LabelAtlasTest::LabelAtlasTest()
{
    m_time = 0;

    // 创建Atlas标签对象
    LabelAtlas *label = LabelAtlas::create(&quot;123 Test&quot;, &quot;fonts/tuffy_bold_italic-charmap.plist&quot;);
    addChild(label, 0, kTagSprite1);
    label-&gt;setPosition(Vec(10, 100));
    // 设置透明度
    label-&gt;SetOpacity(200);

    schedule(schedule_selecotr(LabelAtlasTest::step));
}
</code></pre><h3 id="4-综合类Label标签类"><a href="#4-综合类Label标签类" class="headerlink" title="4.综合类Label标签类"></a>4.综合类Label标签类</h3><p>3.x中新加了Label类，这个类量上面所介绍的LabelTTF、LabelBMFont、LabelAtlas的一个综合类，提供了创建这三个类的新方法，并增加了字体描边、添加阴影、字体外发光的方法。</p>
<h5 id="4-1-Label中所有新功能示例"><a href="#4-1-Label中所有新功能示例" class="headerlink" title="4.1 Label中所有新功能示例"></a>4.1 Label中所有新功能示例</h5><pre><code>LabelTTFDynamicAlignment::LabelTTFDynamicAligment()
{
    auto size = Director::getInstance()-&gt;getWinSize();
    TTFConfig ttfConfig(&quot;font/arial.ttf&quot;, 23);
    _label = Label::createWithTTF(ttfConfig, LongSentencesExample, TextHAligment::CENTER, size.width);
    _label-&gt;setPosition(Vec2(size.width/2, size.height/2));

    addChild(_label);
    this-&gt;addChild(menu);
}
</code></pre><h5 id="4-2-TTFConfig结构体"><a href="#4-2-TTFConfig结构体" class="headerlink" title="4.2 TTFConfig结构体"></a>4.2 TTFConfig结构体</h5><p>TTFConfig是一个结构体，其中定义了TTFlabel所需的几个参数，如下面代码所示。</p>
<pre><code>typedef struct _ttfConfig
{
    std::string fontFilePath;
    int fontSize;
    GlyphCollection glyphs;
    const char *customGlyphs;
    bool distanceFieldEnabled;
    int outlineSize;

    _ttfConfig(const char* filePath = &quot;&quot;, int size = 12, const GlypnCollection&amp; glyphCollection = GlypnCollection::DYNAMIC);
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/3.6 文字与字体/" data-id="cjov31rkb004588riclv03s1a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/3.5 Sprite" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/3.5 Sprite/" class="article-date">
  <time datetime="2018-11-24T03:37:30.699Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/3.5 Sprite/">3.5 Sprite</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Sprite"><a href="#Sprite" class="headerlink" title="Sprite"></a>Sprite</h1><p>精灵类本身具有了一些特殊属性，比如纹理、尺寸、翻转、透明度以及角度，另外也会赋予一些新的属性，比如物理属性和游戏逻辑属性。</p>
<p><img src="http://7xqzxs.com1.z0.glb.clouddn.com/0109Sprite%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.png" alt=""></p>
<p>从精灵类的继承关系来看，继承Node是为了满足渲染框架的结构，继承CCTextureProtocol,这个协议为了处理纹理图片的管理。</p>
<h3 id="1-精灵类"><a href="#1-精灵类" class="headerlink" title="1.精灵类"></a>1.精灵类</h3><h5 id="1-1-精灵类属性"><a href="#1-1-精灵类属性" class="headerlink" title="1.1 精灵类属性"></a>1.1 精灵类属性</h5><pre><code>// 纹理图集
TexttureAtlas *_textureAtlas;
// 纹理图集的序号
ssize_t _atlasIndex;
// 精灵集合类对象指针
SpriteBatchNode *m_pobBatchNode;
// 是否重新绘制
bool _dirty;
// 是否递归重新绘制
bool _recursiveDirty;
// 是否隐藏
bool _shouldBeHidden;
// 精灵集合类的转换坐标
Mat4 _trandformToBatch;
// 混合属性
BlendFunc _blendFunc;
// 精灵纹理
Texture2D * _texture;
// 碰撞矩形
Rect _rect;
// 矩形是否旋转
bool _rectRotated;
// 偏移坐标
Vec2 _offsetPosition;
// 偏移坐标
Vec2 _unflippedOffsetPositionFromCenter;
// X轴是否翻转
bool _flipX;
// Y轴是否翻转
bool _flipY;
</code></pre><h5 id="1-2-精灵对象创建函数"><a href="#1-2-精灵对象创建函数" class="headerlink" title="1.2 精灵对象创建函数"></a>1.2 精灵对象创建函数</h5><pre><code>// 创建精灵对象
static Sprite * create();
// 以图片文件来创建精灵对象
static Sprite *create(const std::string&amp; filename);
// 以图片文件中一块矩形区域来创建精灵对象
static Sprite *create(const std::string&amp; filename, const Rect&amp; rect);
// 以精灵帧来创建精灵对象
static Sprite *createWithSpriteFrame(SpriteFrame *spriteFrame);
// 以精灵帧名字来创建精灵对象
static Sprite *createWithSpriteFrameName(const std::string&amp; spriteFrameName);
// 以纹理图片来创建精灵对象
static Sprite *createWithTexture(Texture2D *texture);
// 以纹理图片中的矩形区域来创建精灵对象
static Sprite *createWithTexture(Texture2D, const Rect&amp; rect, bool rotated = false);
</code></pre><h5 id="1-3-精灵创建函数示例"><a href="#1-3-精灵创建函数示例" class="headerlink" title="1.3 精灵创建函数示例"></a>1.3 精灵创建函数示例</h5><p>1).通过图片文件来创建精灵</p>
<pre><code>// 通过图片文件来创建精灵
Sprite *sprite = Sprite::create(&quot;Images/grossini.png&quot;); 
// 通过图片文件中一块矩形区域来创建精灵对象
Sprite *sprite = Sprite::create(&quot;Images/grossini.png&quot;, Rect(x, y, 85, 121));
</code></pre><p>2).通过精灵帧来创建对象</p>
<pre><code>// 创建精灵集合
SpriteBatchNode* batch = SpriteBatchNode::create(&quot;animation/grossini.png&quot;, 50);
// 将精灵帧集合添加至父节点用于显示
addChild(batch, 0, kTagSpriteBatchNode);
// 添加精灵帧缓冲
SpriteFrameCache::getInstance()-&gt;addSpriteFramesWithFile(&quot;animations/grossini.plist&quot;);
// 通过精灵帧名字创建精灵对象1
Sprite* sprite = Sprite::createWithSpriteFrameName(&quot;grossini_dance_01.png&quot;);
sprite-&gt;setPosition(Vec2(s.width/3, s.height/2));
// 通过精灵帧对象创建精灵对象2
Sprite* sprite = Sprite::createWithSpriteFrameName(&quot;grossini_dance_02.png&quot;);
sprite:setPosition(Vec2(50, 50));

注：精灵集合各精灵帧缓冲没有要求必须使用。可以选择使用其一或者两者配合。
</code></pre><p>3).使用纹理对象创建精灵</p>
<pre><code>texture1 = TextureCache::getInstance()-&gt;addImage(&quot;Images/testImage.png&quot;);
texture1-&gt;retain()
Sprite* sprite = Sprite::createWithTexture(texture1, Rect(x, y, 85, 121));
Node-&gt;addChild(sprite);
</code></pre><h3 id="2-精灵集合类（SpriteBatchNode）"><a href="#2-精灵集合类（SpriteBatchNode）" class="headerlink" title="2.精灵集合类（SpriteBatchNode）"></a>2.精灵集合类（SpriteBatchNode）</h3><p>精灵集合类继承关系</p>
<p><img src="http://7xqzxs.com1.z0.glb.clouddn.com/0111%E7%B2%BE%E7%81%B5%E9%9B%86%E5%90%88%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt=""></p>
<p>1). 从继承关系看，精灵集合类来自Node，这使得它犹如精灵、图层、场景一样用来显示游戏内容，其次还继承了TextureProtocol纹理协议，实现一些绘制图片有关的方法。与精灵类不同，精灵集合类没有重载绘制函数，不能用来绘制游戏内容。</p>
<p>2).有效的运用精灵集合类对象，减少渲染器的绘制次数，就是从根本上提高了游戏运行速率。</p>
<p>3). 精灵集合类的对象包含了很多子节点，这些子节点都是精灵对象，它们作用的同一张纹理图片， 但是所使用的矩形区域不一样。</p>
<p>4). 精灵集合类存在一个子类，TMXLayer，既地图背景类。</p>
<p>使用精灵类集合过程中，读者不要留意两个细节：</p>
<p>1).使用精灵类绘制时，会导致所有子节点处于同一个画面层次，所有的对象都是同一个Node对象的节点。比如，实现飞机在子弹中间穿梭，就不能将子弹与飞机纹理放在同一个精灵集合对象中。</p>
<p>2).OpenGLES渲染器要求，纹理的尺寸必须满足“2的N次方规则”。</p>
<h3 id="3-精灵帧类"><a href="#3-精灵帧类" class="headerlink" title="3.精灵帧类"></a>3.精灵帧类</h3><p><img src="http://7xqzxs.com1.z0.glb.clouddn.com/0114%E7%B2%BE%E7%81%B5%E5%B8%A7%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt=""></p>
<p>1）.精灵帧类是一个非常简单的的类。甚至都不是Node的子类，这说明它都不能用来绘制，也不能加入节点链表中去。</p>
<p>2).精灵帧的主要作用是持有一个纹理对象，为精灵对象提供动画支持。</p>
<p>3).精灵帧的存在，将纹理图片加载与创建精灵对象的过程分开了。这样将纹理资源首先载入内存，然后在合适的时机创建精灵对象。</p>
<h5 id="3-1精灵帧对象的属性"><a href="#3-1精灵帧对象的属性" class="headerlink" title="3.1精灵帧对象的属性"></a>3.1精灵帧对象的属性</h5><pre><code>// 偏移量
Vec2 _offset;
// 纹理原始尺寸
Size _originalSize;
// 纹理像素尺寸
Size _rectInPixels;
// 是否旋转
bool _rorated;
// 矩形区域
Rect _rect;
// 像素单位的偏移量
Vec2 _offsetInPixels;
// 纹理对象
Texture2D *_texture;
// 纹理名称
std::string _textureFilename;
</code></pre><h5 id="3-2精灵帧对象的创建函数"><a href="#3-2精灵帧对象的创建函数" class="headerlink" title="3.2精灵帧对象的创建函数"></a>3.2精灵帧对象的创建函数</h5><pre><code>// 以图片文件中的矩形区域来创建
static SpriteFrame *create(const std::string&amp; filename const Rect&amp; rect);
// 以图片文件中的矩形区域来创建，包含属性初始化参数
static SpriteFrame *create(const std::string&amp; filename const Rect&amp; rect, bool rotated, const Vec2&amp; offset, const Size &amp;originalSize);


// 以纹理对象中的矩形区域来创建精灵帧
static SpriteFrame *createWithTexture(Texture2D *pobTexture, const Rect&amp; rect);
// 以纹理对象中的矩形区域来创建精灵帧，包含属性初始化参数
static SptiteFrame *createWithTexture(Texture2D *pobTexture, cont Rect&amp; rect, bool rotated, const Vec2&amp; offset, const Size &amp;originalSize);
</code></pre><h5 id="4-精灵帧缓冲"><a href="#4-精灵帧缓冲" class="headerlink" title="4.精灵帧缓冲"></a>4.精灵帧缓冲</h5><p>明白精灵帧存在的价值，就会联想到精灵帧缓冲的作用了。</p>
<p>1）.精灵帧缓冲，包含了当前游戏画面中需要使用的精灵帧，其中这些有些纹理图片来自一张纹理图片，也有一些是单独的纹理图片。</p>
<p>2）.精灵帧缓冲提供了一个管理纹理图片资源的简洁路径，可以选择何时将纹理加载进内存，使用精灵帧创建精灵的时候无需在进行文件内存的操作，回忆游戏运行速度。</p>
<p>3).引擎中通常只存在一个精灵帧缓冲池的单例。</p>
<pre><code>// 从plist文件中加载多个精灵帧
void addSpriteFramesWithFile(const std::string&amp; plist);
// 从plist文件中加载多个精灵帧，参数为纹理名称
void addSpriteFramesWithFile(const std::string&amp; plist, const std::string&amp; textureFileName);
// 从plist文件中加载多个精灵帧，参数为纹理对象
void addSpriteFramesWithFile(const std::string&amp; plist, Texture2D* texture);
// 按照参数中的名字添加一个精灵帧
void addSpriteFrame(SpriteFrame* frame, const std::string&amp; frameName);

// 清除帧缓冲，所有的精灵帧都将消失
void removeSpriteFrames(void);
// 清除所有末使用的精灵帧对象
void removeUnusedSpriteFrames(void);
// 清除参数名字的精灵帧对象
void removeSpriteFrameByName(const std::string&amp; name);
// 按照plist文件内容，来清除精灵帧
void removeSpriteFramesFromFile(const std::string&amp; plist);
// 按照纹理对象来清除精灵帧
void removeSpriteFromTexture(Texture2D *texture);
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/3.5 Sprite/" data-id="cjov31rk7003v88rig8dtwcpe" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Cococs2d与OpenGL-ES/">Cococs2d与OpenGL ES</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos2d-Lua/">Cocos2d-Lua</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos2d与OpenGL-ES/">Cocos2d与OpenGL ES</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cococs2d与OpenGL-ES/">Cococs2d与OpenGL ES</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cocos-Lua/">Cocos-Lua</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lua/">Lua</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Cococs2d与OpenGL-ES/" style="font-size: 12.5px;">Cococs2d与OpenGL ES</a> <a href="/tags/Cocos-C/" style="font-size: 20px;">Cocos-C++</a> <a href="/tags/Cocos-Lua/" style="font-size: 17.5px;">Cocos-Lua</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Lua/" style="font-size: 15px;">Lua</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/3.2 精灵/">3.2 精灵</a>
          </li>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/3.1（2） 纹理压缩及应用/">3.1(2) 纹理压缩及应用</a>
          </li>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/3.1（1） 纹理/">3.1 纹理</a>
          </li>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/3 全新的绘制系统/">全新的绘制系统</a>
          </li>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/2.2 OpenGL ES 着色程序/">OpenGL ES着色程序</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Zenos<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>