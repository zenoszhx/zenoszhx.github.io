<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>ArrayStars</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="ArrayStars">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="ArrayStars">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ArrayStars">
  
    <link rel="alternate" href="/atom.xml" title="ArrayStars" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ArrayStars</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一些个人的总结，辩证来看，不保证完全正确。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Cocos-C++/3.4 Layer" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/3.4 Layer/" class="article-date">
  <time datetime="2018-11-24T03:37:30.697Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/3.4 Layer/">3.4 Layer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Layer"><a href="#Layer" class="headerlink" title="Layer"></a>Layer</h1><p>在一个场景中可以有多个图层，图层之间可以想到叠加，引擎中的图层对象包含了3个功能：</p>
<p>1）.接受用户操作，比如触屏、重力加速计的信息。</p>
<p>2）.作为游戏内容元素的容器，用于显示游戏画面、承载精灵类、字体文本等对象。</p>
<p>3）.填充游戏背景颜色</p>
<h3 id="1-Layer的头文件定义"><a href="#1-Layer的头文件定义" class="headerlink" title="1. Layer的头文件定义"></a>1. Layer的头文件定义</h3><pre><code>class CC_DLL Layer:public Node, pbulic TouchDelegate, CCAcceletometerDelegate, public CCKeypadDelegate
{
publick:
    Layer();
    virtual ~layer();
    bool init();                  // 初始化函数
    static Layer *create(void);      // 创建图形对象的

    // 用户操作函数，单点触碰
    virtual bool onTouchBegan(Touch *touch, Event *unused_event);
    virtual void onTouchMoved(Touch *touch, Event *unused_event);
    virtual void onTouchEnded(Touch *touch, Event *unused_enent);
    virtual void onTouchCancelled(Touch *touch, Event *unused_event);

    // 用户操作函数，多点触碰
    virtual void onTouchesBegan(const std::vector&lt;Touch *&gt; touches, Event *unused_event);
    virtual void onTouchesMoved(const std::vector&lt;Touch *&gt; touches, Event *unused_event);
    virtual void onTouchesEnded(const std::vector&lt;Touch *&gt; touches, Event *unused_event);
    virtual void onTouchesCancelled(const std::vector&lt;Touch *&gt; touches, Event *unused_event);

    // 加速度信息
    virtual void onAcceleration(Acceleration *acc, Event *unused_event);
    // 返回是否接受加速度计的信息
    CC_DEPRECATED_ATTRIBUTE bool isAccelerometerEnabled();
    // 设置图层是否接受加速度计的信息
    CC_DEPRECATED_ATTRIBUTE void setAccelerometerEnabled();
    // 设置加速度计的时间间隔
    CC_DEPRECATED_ATTRIBUTE void setAccelerometerInterval();

    // 注册触碰事件
    CC_DEPRECATED_ATTRIBUTE virtual void registerWithEventDispathcer(void);
    // 返回图层是否接受触碰事件
    CC_DEPRECATED_ATTRIBUTE bool isTouchEnable();
    // 设置图层是否接受触碰事件
    CC_DEPRECATED_ATTRIBUTE void setTouchEnable(bool value);
    // 设置触碰方式是同时响应，不是逐个响应
    CC_DEPRECATED_ATTRIBUTE void setTouchMode(Touch::DispatchMode mode);
    // 返回触碰方式
    CC_DEPRECATED_ATTRIBUTE virtual Touch::DispatchMode getTouchMode():

    // 返回是否接受键盘按键
    CC_DEPRECATED_ATTRIBUTE bool isKeypadEnabled();
    // 设置是否接受键盘按键
    CC_DEPTECATED_ATTRIBUTE boid setKeypadEnabled(bool value);
}

注意：
1.默认情况下，图层是不接受用户操作的，需要调用函数来开启图层将要接受的用户操作。
</code></pre><h3 id="2-LayerColor颜色层"><a href="#2-LayerColor颜色层" class="headerlink" title="2. LayerColor颜色层"></a>2. LayerColor颜色层</h3><p>颜色层可以按照RGB设置填充颜色，同时还可以设置透明度。在游戏中主要用来烘托背景。比如，需要暂停的时候可以创建一个半透明的颜色层来遮挡游戏内容，显示暂停菜单。</p>
<pre><code>class CC_DLL LayerColor:public Layer, public BlendProtocol
{
public:
    LayerColor ();
    virtual ~LayerColor ();

    // 绘制函数
    virtual draw();
    // 设置图层尺寸
    virtual void setContentSize(const Size &amp; var);

    // 创建函数
    static LayerColor *create();
    static LayerColor *create(const Color4B&amp; color);
    static LayerColor *create(const Color4B &amp; color, GLfloat width, GLfloat height);

    // 初始化
    virtual bool init();
    virtual bool init(const Color4B&amp; color);
    virtual bool init(const Color4B&amp; color, GLfolat width, GLfloat height);

    // 改变大小
    void changeWidth(GLfloat w);
    void changeHeight(GLfloat h);
    void changeWidthAndHeight(GLfloat w, GLfloat h);

    // 图层混合属性及函数
    virtual const BlendFunc&amp; getBlendFunc() const override;
    virtual void setBlenFunc(const BlendFunc&amp; blendFunc) override;
}

注：
1.颜色图层包含了绘制的内容，所以需要重载来自Node的draw函数。
</code></pre><h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a>3.其他</h3><h5 id="3-1-LayerGradient——颜色图层的特殊子类"><a href="#3-1-LayerGradient——颜色图层的特殊子类" class="headerlink" title="3.1 LayerGradient——颜色图层的特殊子类"></a>3.1 LayerGradient——颜色图层的特殊子类</h5><p>LayerGradient是LayerColor的一个子类，是具有颜色渐变效果的颜色图层。<br>创建函数中需要传入开始颜色和结束颜色，开始透明度和结束透明度。</p>
<h5 id="3-2-Menu-菜单图层"><a href="#3-2-Menu-菜单图层" class="headerlink" title="3.2 Menu 菜单图层"></a>3.2 Menu 菜单图层</h5><p>这是一个以按钮对象为集合的UI图层。</p>
<h5 id="3-3-LayerMultiplex-复合层"><a href="#3-3-LayerMultiplex-复合层" class="headerlink" title="3.3 LayerMultiplex 复合层"></a>3.3 LayerMultiplex 复合层</h5><p>可以包含多个层的复合层，通常被用来制作游戏内容的主画面。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/3.4 Layer/" data-id="cjov31rk1003o88riretrub1y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/3.3 Scene" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/3.3 Scene/" class="article-date">
  <time datetime="2018-11-24T03:37:30.695Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/3.3 Scene/">3.3 场景类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="场景类"><a href="#场景类" class="headerlink" title="场景类"></a>场景类</h1><p>场景中不包含游戏逻辑，仅仅是作为一个容器，将不同的层组到一起最终呈现给玩家一个完整的画面。</p>
<h3 id="1-HelloWorld-场景类"><a href="#1-HelloWorld-场景类" class="headerlink" title="1 HelloWorld 场景类"></a>1 HelloWorld 场景类</h3><pre><code>Scene *HelloWorld::scene()
{
    // 创建一个场景类，此对象将会自动释放
    Scene *scene = Scene:create();

    // 创建一个层次对象，将会自动释放
    HelloWorld *layer = HelloWorld::crete();

    // 将层次添加至场景中
    scene-&gt;addChild(layer);

    // 返回场景
    return scene;
}

注：
1.类Node中提供了更改父类节点的函数setParent()
2.不要直接使用layer来进行场景转换，而是持有一个场景对象的指针。
</code></pre><h3 id="2-场景转换特效"><a href="#2-场景转换特效" class="headerlink" title="2 场景转换特效"></a>2 场景转换特效</h3><p>需要注意的是，绚丽的效果要花费更大的代价，在游戏中进行场景切换的时候，内存中会留有两个场景类对象。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/3.3 Scene/" data-id="cjov31rjv003h88ridfvs3f19" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/3.2 导演类" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/3.2 导演类/" class="article-date">
  <time datetime="2018-11-24T03:37:30.693Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/3.2 导演类/">3.2 导演类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#导演类</p>
<p>导演类在引擎中发挥的主要作用：</p>
<p>1).管理、显示场景。</p>
<p>2).持有Cocos2D-X引擎的配置细节。</p>
<p>3).维持与设备窗口、OpenGL视窗对象的联系。</p>
<p>4).反馈来自操作系统的应用响应，比如暂停、恢复和结束游戏。</p>
<p>5).在引擎世界和OpenGL之间进行坐标转换。</p>
<h3 id="1-导演类的使用方法"><a href="#1-导演类的使用方法" class="headerlink" title="1. 导演类的使用方法"></a>1. 导演类的使用方法</h3><p>导演对象负责创建、管理应用程序或者游戏的主窗口。在特定条件下显示、执行某个场景。</p>
<p>在代码中，导演是一个单例对象。</p>
<pre><code>bool AppDelegate::applicationDidFinishLaunching()
{
    auto director = Director::getInstance();
    auto glview = director-&gt;getOpenGLView();
    if(!glview)
    {
        glview = GLViewImpl::create(&quot;Cpp Empty Test&quot;);
        director-&gt;setOpenGLView(glview);
    }
    director-&gt;setOpenGLView(glview);

    #if (CC_TARGET_PLATFORM == CC_PLATFORM_WP8)
        glview-&gt;setDesignResolutionSize(disignResolutionSize.width, designResolutionSize.height, ResolutionPolicy::SHOW_ALL);
    #else
        glview-&gt;setDesignResolutionSize(disignResolutionSize.width, designResolutionSize.height, ResolutionPolicy::SHOW_ALL);
    #endif

    Size frameSize = glview-&gt;getFrameSize();
    vector&lt;string&gt; searchPath;
    if (frameSize.height &gt; mediumResource.size.height)
    {
        searchPath.push_back(largeResource.directory);
        director-&gt;setContentScaleFactor(MIN(largeResource.size.height/designResolutionSize.height, largeResource.size.width/designResolutionSize.width));
    } else if (frameSize.height &gt; smallResource.size.height) {
        searchPath.push_back(mediaResource.directory);
        director-&gt;setContentScaleFactor(MIN(mediaResource.size.height/designResolutionSize.height, mediaResource.size.width/designResolutionSize.width));
    } else {
        searchPath.push_back(smallResource.directory);
        director-&gt;setContentScaleFactor(MIN(smallResource.size.height/designResolutionSize.height, smallResource.size.width/designResolutionSize.width));
    }

    FileUtils::getInstance()-&gt;setSearchPath(searchPath);
    director-&gt;setDisplayStats(true);
    director-&gt;setAnimationInterval(1.0/60);
    auto scene = HelloWorld::scene();
    director-&gt;runWithScene(scene);
    return ture;
}

1.首先通过静态函数Director::getInstance();来创建单例对象。之后的代码中，再次调用此函数来获取导演类对象，返回的也是首次创建的单例例对象。
2.代码中创建了一个GLView对象，这是一个用OpenGL ES来绘制的界面，将创建的openflView传递给导演，好比将摄像机交给导演。
3.接下来的代码中，根据设备显示尺寸选择了不同的资源路径，开启了显示游戏画面刷新率，将显示界面传递至设备窗口、设置统计格式、用导演对象来运行场景。
4.在类Director代码中，为了便于管理场景对象，采用了队列方式来管理场景对象。
</code></pre><h3 id="2-导演类中与场景有关的函数"><a href="#2-导演类中与场景有关的函数" class="headerlink" title="2. 导演类中与场景有关的函数"></a>2. 导演类中与场景有关的函数</h3><pre><code>// 运行一个场景 
void runWithScene(Scene *scene);
// 压入当前活动场景，使其进入等待状态
void pushScene (Scene *scene);
// 从队列顶端弹出一个场景对象
void popScene (void);
// 从队列底部弹出所有场景对象，仅剩根部场景对象
void popToRootScene (void);
// 替换新的场景对象
void replaceScene (Scene *scene);
// 结束执行，释放当前场景
void end (void);
// 暂停运行的场景
void pause (void);
// 恢复运行的场景
void resume (void);
// 绘制当前场景
void drawScene (void);

1.runWith用于运行一个场景，除了显示场景的内容外还接受用户在场景中的操作。
2.pushScene需要停止当前正在运行的场景并压栈入场景队列，将传入场景设置为当前执行场景。
3.popScene恢复压入场景队列中的最后一个场景，当前队列顶端的场景将被释放，。如果当前队列中没有没有等待执行的场景，系统自动退出，调用end函数。
4.replaceScene是直接用一个场景直接用一个场景取代当前场景并释放的函数。
5.end结束场景的运行。
6.pause暂停场景运行。
7.resume则用来恢复场景运行。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/3.2 导演类/" data-id="cjov31rjy003k88rif5n2tq86" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/3.1 根节点Node" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/3.1 根节点Node/" class="article-date">
  <time datetime="2018-11-24T03:37:30.691Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/3.1 根节点Node/">3.1 根节点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h1><p>几乎所有与渲染有关的类都继承自Node类。</p>
<p><img src="http://7xqzxs.com1.z0.glb.clouddn.com/0102Node%E7%B1%BB%E5%B1%9E%E6%80%A7.png" alt=""></p>
<h3 id="1-Node类和子类的特点"><a href="#1-Node类和子类的特点" class="headerlink" title="1.Node类和子类的特点"></a>1.Node类和子类的特点</h3><h5 id="1-1-Node类和它的子类有三个明显的特点"><a href="#1-1-Node类和它的子类有三个明显的特点" class="headerlink" title="1.1 Node类和它的子类有三个明显的特点"></a>1.1 Node类和它的子类有三个明显的特点</h5><p>1). 可以包含Node类对象作为子节点。对应方法为addChild、getChildByTag、removeChild。</p>
<p>2). Node类及子类都可以使用定时器。对应方法为schedule、unschedule。</p>
<p>3). Node类及子类都可以执行动作。对应方法为runAction、stopAction。</p>
<h5 id="1-2-Node子类需要改变3个内容"><a href="#1-2-Node子类需要改变3个内容" class="headerlink" title="1.2 Node子类需要改变3个内容"></a>1.2 Node子类需要改变3个内容</h5><p>1）.类对象初始化的方式和内容。</p>
<p>2）.编写时间回调函数。</p>
<p>3）.重载绘制函数。</p>
<h3 id="2-Node类的函数"><a href="#2-Node类的函数" class="headerlink" title="2.Node类的函数"></a>2.Node类的函数</h3><h5 id="2-1-Node类与节点有关的函数"><a href="#2-1-Node类与节点有关的函数" class="headerlink" title="2.1 Node类与节点有关的函数"></a>2.1 Node类与节点有关的函数</h5><pre><code>// 将参数中的节点对象添加至当前节点
virturl void addChild(Node *child);
virturl void addChild(Node *child, int localZOrder);
virturl void addChild(Node *child, int localZOrder, int tag)

// 将当前节点从父节点移除，并设置是否清除
void removeFromParentAndCleanup (bool cleanup)
// 移除参数中的指定的节点，并设置是否清除
virtual void removeChild (Node *child, bool cleanup)
// 通过参数标识移除子节点，并设置是否清除
void removeChildByTag(int tag, bool cleanup)
// 移除全部子节点，并设置是否清除
virtual void removeAllChildrenWithCleanup (bool cleanup)

// 返回参数值指定的标志的子节点
virtual Node *getChildByTag(int tag)
// 返回所有的子节点
virtual Vector&lt;Node *&gt;&amp; getChildren (void)

// 重新设置子节点的坐标值
virtual void reorderChild(Node *child, int localZOrder)

// 通过排序所有子节点，提供渲染性能。不要随意调用，除非要在当前帧移除新加入的节点
virtual void sortAllChildren()

// 获得子节点的数目
virtual ssize_t getChildrenCount(void)

注意：
1. 在执行添加子节点的函数时，如果当前节点处于运行中状态，则会立即调用另外函数“onEnter”和“onEnterTransitionDidFinish”。
2. 如果存在多个相同标志的Node对象，则会返回第一个被添加的对象。如果不存丰则返回NULL
3. removeChild函数中，cleanup参数为是否停止移除子节点当前定时器和动作。如果要移除的子节点还在使用，那么传入true。
</code></pre><h5 id="2-2-Node类的节点操作"><a href="#2-2-Node类的节点操作" class="headerlink" title="2.2 Node类的节点操作"></a>2.2 Node类的节点操作</h5><pre><code>// 生成一个新节点
Node *childNode = Node::create();
// 将新节点添加为子节点
myNode-&gt;addChild(childNode, 0, 100);
// 获取子节点
Node *retrievedNode = myNode-&gt;getChildByTag(100);
// 通过tag移除子节点，cleanup会停止任何运行中的动作
myNode-&gt;removeChildByTag(100, true);
// 通过节点指针删除节点
myNode-&gt;removeChild(retrieveNode);

注意：
1.在代码后面使用了两次移除节点的方法。这是只做展示。在节点移除后再一次移除会报错。
</code></pre><h5 id="2-3-Node中与定时器有关函数"><a href="#2-3-Node中与定时器有关函数" class="headerlink" title="2.3 Node中与定时器有关函数"></a>2.3 Node中与定时器有关函数</h5><p>类Node中第二个特性就是定时器。</p>
<p>1）.类Node中定时器的功能，开发者需要设定一定的时间间隔，它会自动执行起来，每当达到预定时间，它会自动执行起来。</p>
<p>2）.一旦开发者开启了定时器，就会持续地执行循环，直到通过代码来控制。</p>
<p>3）.类Node中的定时器量循环执行的。类似于游戏中的循环周期，只不过定时器是按照固定的时间节奏来调用一个函数。其实在游戏当中，开发者确实通过定时器回调机制来实现游戏逻辑循环的。</p>
<pre><code>// 检查当前函数是否为定时器回调
bool isSchedule (SEL_SCHEDULE selector);

// 启动定时器更新函数
void scheduleUpdate (void);
// 根据参数中的优先级来控制回调函数
void scheduleUpdateWithPriority(int priority);
// 取消回调函数
void unscheduleUpdate(void)

// 启动定时器，参数为回调函数句柄、以毫秒为单位的循环周期、循环次数、延迟启动时间
void schedule(SEL_SCHEDULE selector);
void schedule(SEL_SCHEDULE selector, folat interval);
void schedule(SEL_SCHEDULE selector, float interval, ssize_t repeat, float delay);
// 启动一次定时器，参数为回调函数以及延迟启动时间
void scheduleOne(SEL_SCHEDULE selector, float delay);

// 取消参数所指定回调函数的定时器
void unschedule(SEL_SCHEDULE selector);
// 取消所有定时器，包括了回调（更新）函数
void unscheduleAllCallbacks (void)

// 恢复所有定时器及动作
void resume (void)
// 暂停所有定时器及动作
void pose (void)

注意：
1.在一个类Node对象中只能存在一个更新回调函数upate()，因为引擎运算消耗，所以函数的回调间隔并不为零。
</code></pre><p>说明：</p>
<p>1）.类Node中包含了一个默认的计时器，其优先级为0，优先权是最高的。当多个定时器都在同一个时间点触发的，首先调用优先级高的。secheduleUpdateWithPriority就是通过参数来更新定时器的优先级。</p>
<p>2).除了默认的更新定时器，开发者还可以通过使用函数。它的级别通常会低于引擎默认的定时器。</p>
<p>3).</p>
<h5 id="2-4-Node中与动作有关的函数"><a href="#2-4-Node中与动作有关的函数" class="headerlink" title="2.4 Node中与动作有关的函数"></a>2.4 Node中与动作有关的函数</h5><pre><code>// 执行动作，返回执行动作
Action *runAction (Action *action);
// 停止所有动作
void stopAllActions (void);
// 停止指定参数动作
void stopActionByTag (int tag);
// 根据标志获取动作对象
Action *getActionByTag (int tag);
// 获取当前对象执行动作数目
ssize_t getNumberOfRunningActions();

注意：
1.并不是所有的动作都适合Node对象。比如，让一个图层对象来播放动画，不就成了播放视频了吗？
2.当销毁一个对象的时候，引擎会首先停止它所有的动作及定时器。
</code></pre><h5 id="2-5-与场景转换有关的函数"><a href="#2-5-与场景转换有关的函数" class="headerlink" title="2.5 与场景转换有关的函数"></a>2.5 与场景转换有关的函数</h5><p>Node的对象作为游戏中的元素，通常需要一个载体。载体负责管理众多的节点对象。在引擎结构中场景类就是众多类Node的载体。</p>
<pre><code>// 当前对象进入场景时调用函数
virtual void onEnter ();
// 当场景转换完成时调用的函数
virtual void onEnterTransitionDidFinish();
// 当前对象退出场景时调用的函数
virtual void onExit ();
// 当前场景边转换开始时调用的函数
virtual void onExitTransitionDidStart ();

注意：
1.onEnterTransitionDidFinish和onExitTransitionDidStart是否被调用，取决于是否使用了场景TransitionScene。
2.onEnter和onExit则必然会在场景转换过程中的某个时间点调用。
3.在每个方法中必须要调用它们父类中相同的方法，以避免丢失用户触碰信息以及内存泄漏问题

与场景转换有关的函数示例：

void testLayer1::onEnter()
{
    // 节点调用了init方法后将会调用此方法
    // 如果使用了TransitionScene，将会在过渡效果开始以后调用此方法
    Layer::onEnter();
    CCLog(&quot;Scene 1 onEnter&quot;);
}

void TestLayer1::onEnterTransitionDidFinish()
{
    // 在使用了Transition方法时，将会在过渡效果结束以后调用此方法
    layer::onEnterTransitionDidFinish();
    CCLog(&quot;Scene 1: onEnterTransitionDidFinish&quot;);
}

void testLayer1::onExitTransitionDidStart()
{
    // 在使用了TransitonScene方法后，将会在过渡效果开始以后调用此方法
    layer::onExitTransitionDidStart();
    CCLog(&quot;Scene 1: onExitTransitionDidStart&quot;);
}

void testLayer1:onExit()
{
    // 节点调用dealloc方法之前将会调用此方法
    // 如果使用了TransitionScene将会在过渡效果结束以后调用此方法
    layer:onExit();
    CCLog(&quot;Scene 1 onExit&quot;);
}

注意：
1.如果不在onEnter方法里调用super方法，在新的场景里可能就无法对触摸或者加速计的输入有任何的反应;如果不在onExit方法里调用它的super方法，当前场景可能不会从内存中释放。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/3.1 根节点Node/" data-id="cjov31rjt003d88rixwojvz7c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/3 引擎的渲染框架" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/3 引擎的渲染框架/" class="article-date">
  <time datetime="2018-11-24T03:37:30.689Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/3 引擎的渲染框架/">3 引擎的渲染框架</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/3 引擎的渲染框架/" data-id="cjov31rjr003b88rikiz8h3lu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/2.8 日志调试方式" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/2.8 日志调试方式/" class="article-date">
  <time datetime="2018-11-24T03:37:30.687Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/2.8 日志调试方式/">2.8 日志调试方式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="2-8-日志调试方式"><a href="#2-8-日志调试方式" class="headerlink" title="2.8 日志调试方式"></a>2.8 日志调试方式</h1><p>不同平台拥有各自的控制台，因此在引擎中日志调试功能也是跨平台的。</p>
<p>调试的应用：</p>
<pre><code>// 移除Node对象
void Node::removeChildByTag(int tag, bool cleanup)
{
    CCASSERT(tag != Node::INVALID_TAG, &quot;Invalid tag&quot;);

    Node *child = this-&gt;getChildByTag(tag);

    if (child == nullptr)
    {
        CCLOG(&quot;cocos2d:removeChildByTag(tag = %d):child not found!&quot;, tag);
    }
    else
    {
        this-&gt;removedChild(child, cleanup);
    }
}
</code></pre><h3 id="1-Debug宏定义"><a href="#1-Debug宏定义" class="headerlink" title="1. Debug宏定义"></a>1. Debug宏定义</h3><pre><code>// 未开启状态
#if !definde(COCOS2D_DEBUG) || COCOS2D_DEBUG == 0

#define CCLOG(...) do {} while(0)
#define CCLOGINFO(...) do {} while(0)
#define CCLOGERROR(...) do {} while(0)
#define CCLOGWARN(...) do {} while(0)

// 开启状态1
#elif COCOS2D_DEBUG == 1

#define CCLOG(format, ...) cocos2d::CCLog(format, ##__VA_ARGS__)
#define CCLOGERROR(format, ...) cocos2d::CCLog(format, ##__VA_ARGS__)
#define CCLOGINFO(format, ...) do {} while(0)
#define CCLOGWARN(...) __CCLOGWITHFUNCTION(__VA_ARGS__)

// 开启状态2
#elif COCOS2D_DEBUG &gt; 1

#define CCLOG(format, ...) cocos2d::CCLog(format, ##__VA_ARGS__)
#define CCLOGERROR(format, ...) cocos2d::CCLog(fromat, ##__VA_ARGS__)
#define CCLOGINFO(format, ...) cocos2d::CCLog(format, ##__VA_ARGS__)
#define CCLOGWARN(...) __CCLOGWITHFUNCTION(__VA_ARGS__)

#endif
</code></pre><h3 id="2-函数CCLog的实现"><a href="#2-函数CCLog的实现" class="headerlink" title="2.函数CCLog的实现"></a>2.函数CCLog的实现</h3><pre><code>void CCLog(const char* format, ...)
{
    va_list args;
    va_start(args, format);
    _log(format, args)
    va_end(args);
}

static void _log(const char *format, va_list args)
{
    char buf[MAX_LOG_LENGTH];

    vsnprintf(buf, MAX_LOG_LENGTH-3, format, args);
    strcat(buf, &quot;\n&quot;);

#if CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID

    __android_log_print(ANDROID_LOG_DEBUG, &quot;cocos2d-x debug info&quot;, &quot;%s&quot;, buf);

# elif CC_TARGET_PLATFORM == CC_PLATFORM_WIN32 || CC_TARGET_PLATFORM == CC_PLATFORM_WINRT || CC_TARGER_PLANTFORM == CC_PLATFORM_WP8

    WCHAR wszBuf[MAX_LOG_LENGTH] = {0};
    MultiByteWideChar(CP_UTF8, 0, buf, -1, sizeof(wszBuf));
    OutputDebugStringW(wszBuf);
    wideCharToMultiByte(CP_ACP, 0, wszBuf, -1, buf, sizeof(buf), nullptr, FALSE);
    printf(&quot;%s&quot;, buf);
    fflush(stdout);

#else

// Linux, MAC, iOS, etc
fprintf(stdout, &quot;Cocos2d:%s&quot;, buf);
fflush(stdout);

#endif

    Director::getInstance()-&gt;getConsole()-&gt;log(buf);
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/2.8 日志调试方式/" data-id="cjov31rjq003888rigb8mfxf0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/2.7 管理模式和管理类" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/2.7 管理模式和管理类/" class="article-date">
  <time datetime="2018-11-24T03:37:30.685Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/2.7 管理模式和管理类/">2.7 管理模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="2-7-管理模式"><a href="#2-7-管理模式" class="headerlink" title="2.7 管理模式"></a>2.7 管理模式</h1><p>管理模式与工厂模式、单例模式、外观模式都是程序设计的一种模式。不过管理模式的实现相对复杂一点。</p>
<h3 id="1-引擎当中的应用"><a href="#1-引擎当中的应用" class="headerlink" title="1.引擎当中的应用"></a>1.引擎当中的应用</h3><p>管理模式的类就是专门管理其他类的对象。通常管理模式只会负责管理一种类型的对象。比如纹理资源只有一个纹理对象管理类、精灵资源只有一个精灵资源管理类。</p>
<p>除了上表中的管理模式之外，引擎中还存在一些其他的管理类,比如定时器、字体。</p>
<p>管理有常见的三个特点：</p>
<p>1）只会存在一个管理者。在引擎中任何一种资源只有一个管理者。例如自动释放池，虽然程序中可能有很多个自动释放池对象，但是池管理者却只有一个。为了保证管理者的唯一，管理模式的对象都会是单例。这些对象中大多会存在两个关键字“getInstance”和“destroyInstance”。</p>
<pre><code>// 静态函数，返回管理者的单例对象
static AnimationCache* getInstance(void);

// 表达函数，释放管理者的单例对象
static void destroyInstance(void);
</code></pre><p>2)管理对象功能，负责管理对象的创建各销毁。在一些管理者中，创建对象的方式会采用工厂模式。例如精灵帧缓冲的管理者创建精灵帧的方式就是工厂模式。精灵帧对象会以键值方式被管理。开发者可以通过函数自由的访问每一个对象帧。这些函数有名字中通常会出现两个关键字“add”和”remove”。</p>
<pre><code>// 成员函数，向缓冲区添加精灵帧对象
void addSpriteFrame(SpriteFrame *frame, const std::string&amp; frameName);

// 成员函数，移除缓冲区中的精灵帧对象
void removeSpriteFrames(void);
</code></pre><p>3）为一组相关的对象提供一个统一的全局访问点，还可以提供一些简洁的接口来获取和操作这些对象。同时使用此模式来缓存游戏中的常用资源，可以提高游戏运行时性能。例如纹理缓冲区就为开发者提供了许多便利的条件。开发者通过调用一个函数就可以将缓冲区中没有使用的纹理资源释放。</p>
<pre><code>// 将纹理对象添加至缓冲区
Texture2D* addImage(std::string&amp; filepaht);

// 移除缓冲区所有纹理对象
void removeAllTextures();

// 移除未使用的纹理对象
removeUnusedTextures();

// 释放指定的纹理对象
void removeTexture(Texture2d* texture);

// 移除指定文理对象，参数为文理对象名字
void removeTextureForkey(const std::string&amp; key);
</code></pre><h3 id="2-缓冲区"><a href="#2-缓冲区" class="headerlink" title="2.缓冲区"></a>2.缓冲区</h3><p>对于频繁出现的对象，采用需要创建、不需要释放的原则就不合适了。缓冲区允许开发者将一些频繁使用的对象存储下来，以便在需要的时候，能够快速的访问。</p>
<ul>
<li>创建和释放都是比较耗费性能的操作。</li>
<li>游戏中场景切换时，是释放缓冲区的最好时机。</li>
<li>虽然在程序退出，缓冲区会自动创建删除。但是在运行期间，开发者需要手动调用函数进行清理。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/2.7 管理模式和管理类/" data-id="cjov31rjk003388riy9f1tqzs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/2.6 UI树及运行时游戏对象" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/2.6 UI树及运行时游戏对象/" class="article-date">
  <time datetime="2018-11-24T03:37:30.684Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/2.6 UI树及运行时游戏对象/">2.6 UI树及运行时游戏对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Cocos2d-x支持在屏幕上绘制精灵、文本、形状、粒子、地图等。所有这些元素都继承自Node类。Node类定义了一个元素的布局、变换、坐标系统等属性，定义了场景中和每个元素，以及这些元素按什么顺序遍历和绘制。我们还可以定制自己的Node子类，实现特定的绘制行为和交互。</p>
<h3 id="1-位置与变换"><a href="#1-位置与变换" class="headerlink" title="1 位置与变换"></a>1 位置与变换</h3><p>Position决定了一个元素在坐标系中的位置。anchorPoint指定了元素的那个位置绑定坐标系位置。anchorPoint还决定着如何对元素执行变换操作，包括旋转、缩放。</p>
<h5 id="1-1-坐标系"><a href="#1-1-坐标系" class="headerlink" title="1.1 坐标系"></a>1.1 坐标系</h5><p>（1）世界坐标系</p>
<p>Cocos2d坐标系与OpenGL一样，以左下角为原点。</p>
<p>（2）屏幕坐标系</p>
<p>以左上角为原点</p>
<p>（3）本地坐标系</p>
<p>相对于父节点的坐标</p>
<h5 id="1-2-坐标变换"><a href="#1-2-坐标变换" class="headerlink" title="1.2 坐标变换"></a>1.2 坐标变换</h5><p>相对坐标系简化了屏幕上元素的布局，我们只需要关心局部。但许多时候我们仍然需要知道一个元素的世界坐标系，如用于触摸处理时的点击判定，两个不同层级元素之间的碰撞检测。Node类提供了一些用于在本地坐标系与世界坐标系进行坐标转换的方法。</p>
<pre><code>class CC_DLL Node:public Ref
{
public:
    // 把世界坐标转换到当前节点的本地坐标系中
    Point convertToNodeSpace(const Point&amp; worldPoint) const;
    // 把基于当前节点的坐标系下的坐标转换到世界坐标系中
    Point convertToWorldSpace(const Point&amp; nodePoint) const;
    // 基于Anchor Point将世界坐标转换到当前节点坐标
    Point convertToNodeSpaceAR(const Point&amp; worldPoint) const;
    // 计算以Anchor Point为原点的坐标系中某个位置的世界坐标
    Point convertToWorldSpaceAR(const Point&amp; nodePoint) const;
    Point convertTouchToNodeSpace(Touch *touch) const;
    Point convertTouchToNodeSpaceAR(Touch *touch) const;
}
</code></pre><h3 id="2-UI树"><a href="#2-UI树" class="headerlink" title="2 UI树"></a>2 UI树</h3><p>一个场景中的UI元素的结构天然适合用树来表示，大多数GUI系统都会设计某种形式的树来管理场景中的元素。用来实现树中节点的查找、遍历，以及节点之间的修改、排序。</p>
<p>Cocos2d-x中的UI树根节点为Scene类，UI树中每个节点都是一个Node实例对象，每个Node对象都具有一个children集合和一个parent节点，其中Scene的parent属性为空。Node类对UI树结构定义如下：</p>
<pre><code>class CC_DLL Node : public
{
public:
    virtual void addChild(Node *child);
    virtual void addChild(Node *child, int localZorder);
    virtual void addChild(Node *child, int localZorder, int tag);
    virtual Node * getChildByTag(int tag);
    virtual Vector&lt;Node*&gt;&amp; getChildren() {return _children;}
    virtual const Vector&lt;Node *&gt; getChildren() const {return _children;}
    virturl sszize_t getChildrenCount() const;
    virtual void setParent(Node* parent);
    virtual Node* getParent() {return _parrent;}
    virtual const Node * getParent const {return _parent;}
}
</code></pre><p>Node除了定义场景树还决定了Cocos2d-x中其他一些很重要的概念，包括元素层级、分制顺序、元素的遍历、坐标变换、运行时对象查找。</p>
<h5 id="2-1-UI树的遍历"><a href="#2-1-UI树的遍历" class="headerlink" title="2.1 UI树的遍历"></a>2.1 UI树的遍历</h5><p>渲染系统最重要的职责就是遍历UI树中的每一个元素，然后将每个元素绘制到屏幕上。</p>
<p>UI树的遍历有两个重要目的：其一是遍历顺序决定了元素被绘制的顺序；其二在遍历过程中实现模型视图变换矩阵的计算，其结果供OpenglES渲染管线计算顶点位置。</p>
<p>在3D四体图形渲染中，元素可以以任何顺序被绘制（透明和非透明的叠加除外），最终图形渲染管线能够根据元素的Z轴，使用深度测试进行正确的绘制。</p>
<p>在2D图形绘制中，各个元素在图形渲染管线中通常具有相同的深度，它们之间层级及绘制关系必须依赖同一个深度，这就需要在游戏逻辑中处理好绘制顺序。</p>
<p>Cocos2d-x中使用localZorder来表示逻辑深度，UI树遍历中采用中序深度优先算法进行遍历，特点如下：</p>
<ul>
<li>遍历左边的了节点</li>
<li>遍历根节点</li>
<li>遍历右边的子节点</li>
</ul>
<p>中序遍历用于二叉树。它保证左边的子元素优先被绘制，而右边的子元素最后被绘制。Cocos2d-x按层级来组织一棵“二叉树”，左边的“子节点”表示所有逻辑深度小于0的元素，右边“子节点”表示所有逻辑深度大于或者等于0的子元素。</p>
<p>将所有元素分为两组，逻辑深度小于0的处于父节点之后，另一组大于或等于0的处于父节点之上，就可以通过开发者指定的逻辑深度来指定一个元素的绘制顺序，参见Node::visit()方法。</p>
<pre><code>void Node::visit()
{
    auto renderer = _director-&gt;getRenderer();
    auto&amp; parentTransform = _director-&gt;getMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
    visit(renderer, parentTransform, true);
}

void Node::visit(Renderer * renderer, const kmMat4 &amp;parentTrasform, bool parentTransformUpdated)
{
    int i = 0;

    if (!_children.empty())
    {
        sortAllChildren();

        // draw children zOrder &lt; 0
        for(; i &lt; _children.size(); i++)
        {
            auto node = _children.at(i);
            if (node &amp;&amp; node-&gt;_localZorder &lt; 0)
                node-&gt;visit(renderer, _modelViewTransform,  dirty);
            else
                break;
        }

        // self draw
        this-&gt;draw(renderer, _modelViewTransform, dirty);

        for (auto it = _children.cbegin() + i; it != _children.cend(); ++it)
            (*it)-&gt;visit(renderer, _modelViewTransform, dirty);

    } else {
        this-&gt;draw(renderer, _modelViewTransform, dirty);
    }
}
</code></pre><h5 id="2-2-逻辑深度"><a href="#2-2-逻辑深度" class="headerlink" title="2.2 逻辑深度"></a>2.2 逻辑深度</h5><p>在visit方法开始遍历了元素之前，会对所有了元素按逻辑深度从小到大顺序进行排序。逻辑深度用localZorder属性表示，如果两个元素的逻辑深度一致，则按它们添加到UI树中顺序排序。这个顺序决定了元素被访问的顺序，因此也决定了元素被绘制的顺序，每个元素都使用Node:draw来绘制自己。</p>
<pre><code>void Node::sortAllChildren()
{
    if(_reorderChildDirty)
    {
        std::sort(std::begin(_children), std::end(_children), nodeComparisonLess);
        _reorderChildDirty = false;
    }
}
</code></pre><p>localZorder方法提供了一种简单的方式，使程序可以控制每个元素的绘制顺序。然而也使程序不能通过指定元素的实际深度，参与UI树中其他不同级别的元素之间排序。例如，我们想让一个低层级的元素始终可见，也许不得不把它移至UI树的根部。这种将逻辑组织与UI元素的绘制顺序绑定在一起的方式使程序失去了灵活性，而且这种灵活性在游戏开发中十分重要。</p>
<p>Cocos2d-3.0新增globalZOrder来解决这个问题，新的元素绘制顺序的判断逻辑如下：</p>
<p>（1）默认每个元素的globalZOreder值为0。</p>
<p>（2）如果一个元素的globalZorder的值不为0，则按globalZOrder值进行排序。</p>
<p>（3）否则按localZOrder值进行排序</p>
<pre><code>class CC_DLL Node : public Ref
{
public:
    virtual void setGlobalZOrder(float globalZOrder);
    virtual float getGlobalZorder() const { return _globalZOrder; }
}
</code></pre><p>如此就能更灵活地控制元素之间的层级关系了。然而，使用globalZOrder也有一个限制，就是不能对SpriteBatchNode的子元素单独设置globalZOrder。因为SpriteBatchNode将所有元素组成一个BatchCommand，所以SpriteBatchNode中的子元素根本没有机会应用globalZOrder。</p>
<p>在Cocos2d-x3.0中，元素的绘制顺序还影响着事件的分发，一个事件接受者可以与一个元素相关联，最后所有的接收者与元素绘制顺序相反的顺序被分发。</p>
<h5 id="2-3-模型视图变换矩阵"><a href="#2-3-模型视图变换矩阵" class="headerlink" title="2.3 模型视图变换矩阵"></a>2.3 模型视图变换矩阵</h5><p>UI树在遍历的时候还要计算坐标变换。虽然相对坐标对开发者而言是很友好的，但是场景中和每个元素发送OpenGL ES命令并进行绘制时，必须徐告诉每个元素的世界坐标，在OpenGL ES中并没有树的概念。</p>
<p>当然在实际绘制的时候不会计算每个元素的世界坐标发送给OpenGL ES，毕竟在开发中对程序最友好的是相对坐标。在OpenGL ES的渲染管线中，更通用的做法是将程序中的相对坐标和元素相对世界坐标的模型视图变换矩阵传输至渲染管线，然后在渲染管线中对每个相对位置执行该坐标变换。</p>
<p>Node维护了一个模型视图变换矩阵，这个矩阵由父级的模型视力变换矩阵右乘当前节点在本地坐标第中的变换矩阵得到。在遍历的时候，根节点的变换矩阵为单位矩阵，依次向下传入自身的模型视力变换矩阵来计算子元素的模型视力变换矩阵。最后，这个变换矩阵连同元素相对坐标信息被传入OpenGL ES渲染管线。如下是模型视力变换矩阵相关源码。</p>
<pre><code>void Node::visit(Rederer *renderer, const kmMat4 &amp;parentTransform, bool parentTransformUpdated)
{
    bool dirty = _transformUpdated || parentTansform;

    if (dirty)
        _modelViewTransform = this-&gt;transform(parentTransform);

    _transformUpdated = false;

    for (auto it = _children.cbegin() + i; it != _children.cend(); ++i)
        (*it)-&gt;visit(renderer, _modelViewTransform, dirty);
}
</code></pre><p>其中transform用来计算模型视图的变换矩阵：</p>
<pre><code>Mate4 Node::transform(const Mat4&amp; parentTransform)
{
    Mat4 ret = this-&gt;getNodeToParentTransform();
    ret parentTransForm * ret;
    return ret;
}
</code></pre><p>在场景中每个元素执行模型视图变换矩阵的计算是UI树很重要的职责，要确保每个元素最终被绘制到屏幕正确的位置。另外场景中可能包含成千上万个UI元素，因此，需要小心的计算，否则将会影响应用程序的性能。从上面的源码可以看出，每个元素的模型视图矩阵的计算只有在场景中某些相关位置发生变更时才会重新进行，这里主要指自身位置发生了变化，或者父级链上某个元素的位置发生了变化，这能够很大的提高遍历性能。</p>
<h5 id="2-4-运行时游戏对象"><a href="#2-4-运行时游戏对象" class="headerlink" title="2.4 运行时游戏对象"></a>2.4 运行时游戏对象</h5><p>UI树还必须提供运行时元素查找功能。</p>
<pre><code>class CC_DLL Node : public Ref
{
public:
    virtual int getTag() const;
    virtual void setTag(int tag);
    virtual Node * getChildByTag(int tag);
}
</code></pre><p>在这里，Cocos2d-x之所以没有提供更易读的字符串来标识一个元素，仍然是出于性能的考虑——游戏运行中需要高速返回游戏对象，比较一个整型数比比较一个字符串的速度快很多。</p>
<p>Cocos2d-x只提供在当前子元素中查找字符串的功能，这使程序必须依赖一定的逻辑关系来查找运行时的元素，有时会不够显得灵活。另外，开发者通常将Node视为一个游戏对象，然后对附加游戏逻辑。</p>
<h3 id="3-UI元素与内存管理"><a href="#3-UI元素与内存管理" class="headerlink" title="3 UI元素与内存管理"></a>3 UI元素与内存管理</h3><p>为便于内存管理，Cocos2d-x中所有UI元素都实现了相关的create()静态方法以返回一个autorelease对象，示例如下：</p>
<pre><code>Node * Node::create(void)
{
    Node *ret = new Node();
    if (ret &amp;&amp; ret-&gt;init()){
        ret-&gt;autorelease();
    } else {
        CC_SAFE_DELETE(ret);
    }
    return ret;
}
</code></pre><p>当我们创建一个Node对象时，其引用计数为1，并加入当前AutoreleasePool，所以，当前帧结束时会被释放一次。如果我们在这一帧中并没有将该对象添加到UI树中，则该对象会在帧结束的时候被释放。</p>
<p>当我们将其加入UI树中，Node使用Cocos2d-x自身提供的Vector<t>来存放子元素，Vector<t>对插入的元素执行retain()方法，并在移除的时候执行release()方法，如下：</t></t></p>
<pre><code>template&lt;class T&gt;
class CC_DLL Vector
{
public:
    void pushBack(T object);
    {
        _data.push_back(object);
        object-&gt;retain();
    }

    void popBack()
    {
        auto last = _data.back();
        _data.pop_back();
        last-&gt;release();
    }
}
</code></pre><p>所以我们很容易计算出在帧结束时元素的引用计数仍为1，将不会被释放。而在元素被移出UI树的时候，Vector<t>对其执行release()方法，该对象将立即被释放。</t></p>
<p>如果我们想重用一个元素该怎么办？从一个父元素移动到另一个父元素，这里我们需要将被移除的元素转换为一个新的autorelease()对象，并且要防止对象在被移出UI树的时候释放，源码如下：</p>
<pre><code>auto node = parent-&gt;getChildByTag(10);   // 引用计数为1
node-&gt;retain();                          // 引用计数为2
node-&gt;removeFromParent();                // 引用计数为1
node-&gt;autorelease();                     // 加入autoreleasePool

parent2-&gt;addChild(node);                 // 引用计数为2
</code></pre><p>在该帧结束后，AutoreleasePool会对其执行一次release操作，使其引用计数为1，成为正常的UI树中的元素。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/2.6 UI树及运行时游戏对象/" data-id="cjov31rjn003588ri441e0f9r" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/2.5 Cocos2d-x的主线程" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/2.5 Cocos2d-x的主线程/" class="article-date">
  <time datetime="2018-11-24T03:37:30.681Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/2.5 Cocos2d-x的主线程/">2.5 Cocos2d-x主线程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在游戏开发中，为游戏对象设计并行系统往往是困难的。一方面，游戏对象之间会存在大量的相互依赖，游戏对象也可能和多个引擎子系统所产生的数据相互依赖；另一方面，游戏对象会与其游戏对象交流，有时在更新循环中会多次交流，而交流的模式是不可预期且受玩家输入影响的。这些都使游戏对象在多线程中的更新变得困难。</p>
<p>所以大多数的引擎都是以单线程为主。更底层的引擎子系统中，可以做到部分并行化，使其不影响上层的游戏对象模型。例如，目前很多游戏引擎都将绘制从游戏引擎分离。使之可以再不同的线程中绘制。</p>
<p>Cocos2d-x目前仍是一个单线程的游戏引擎，这使我们几乎不需要考虑游戏对象更新的线程安全性。然而，我们仍然需要关注一些情形，如网络请求，异步加载文件或者异步处理一些逻辑算法。</p>
<h3 id="1-在主线程中执行异步处理"><a href="#1-在主线程中执行异步处理" class="headerlink" title="1 在主线程中执行异步处理"></a>1 在主线程中执行异步处理</h3><p>有一些方法必须在主线程中执行，如与GL相关的方法。另一些时候，为了保证如Ref对象引用计数的线程安全，我们也应该在主线程中执行这些操作。Scheduler提供了一种简单的机制，使我们可以在主线程中执行一个方法。</p>
<pre><code>void Scheduler::performFunctionInCocosThread(const std::function&lt;voidv()&gt; &amp;function)
{
    _performMutex.lock();
    _functionToPerform.push_back(function);
    _performMutex.unlock();
}
</code></pre><p>向Scheduler注册一个方法指针。Scheduler中存储了一个需要在主线程执行的方法的指针数组，在当前帧所有的系统或自定义的scheduler执行完成后，Scheduler就会检查该数组并执行其中方法。</p>
<pre><code>void Scheduler::update(float dt)
{
    if(!_functionsToPerform.empty())
    {
        _performMutex.lock();
        auto temp = _functionsToperform;
        _functionToperform.clear();
        _performMutex.unlock();
        for (const auto &amp;function : temp)
        {
            function();
        }
    }
}
</code></pre><p>通过上面这种方法，我们可以将一个方法转移到主线程中执行。这里需要注意的是：这些方法在主线程中被执行的时机是所有系统和自定义Scheduler之后，即在UI树遍历之前。</p>
<h3 id="2-纹理的异步的加载"><a href="#2-纹理的异步的加载" class="headerlink" title="2 纹理的异步的加载"></a>2 纹理的异步的加载</h3><p>对于一些耗时的操作，为了不影响游戏的性能，我们需要将一系列耗时的方法分布在每一帧中去执行。</p>
<p>Cocos2d-x纹理的异步加载完成之后，需要将纹理上传至GL内存中，因此，这个传输的过程必须要在主线程中执行。但是，上传纹理使用的glTexture2D命令是一个耗时的操作，试想如果有多个图片同时完成加载，这些纹理需要在同一帧上传到GL内存，这可能会使UI界面出现卡顿。</p>
<p>因此，Cocos2d-x纹理的加载回调使用了一个自定义的Schedule，在该Scheduele内部，检查已经完成加载的纹理每一帧处理一个纹理，直至所有纹理被处理完毕，则注销该Schedule。</p>
<p>TextureCacha异步加载纹理：</p>
<pre><code>void TextureCache:addImageAsync(const std::string &amp;path, const std::function&lt;void(Texture2D*)&gt;&amp; callback)
{
    // 创建一个纹理对象指针
    Texture2D *texture = nullptr;

    // 获取资源路径
    std::string fullPath = FileUtils::getInstance()-&gt;fullPathForFilename(path);

    // 如果这个纹理已经加载，则返回
    auto it = _textures.find(fullpath);
    if(it != _textures.end())
        texture = it-&gt;second;    // second为key-value中的value

    if (texture != nullptr)
    {
        // 纹理加载过了直接执行回调函数并返回
        callback(texture);
        return;
    }

    if (fullpath.empty() || !FileUtils::getInstance()-&gt;isFileExist(fullpath)) {
        if (callback) callback(nullptr);
        return;
    }


    // 第一次执行异步加载的函数需要对保存消息结构体的队列初始化
    if (_loadingThread == nullptr)
    {
        // 创建一个新线程加载纹理
        _loadingThread = new std::thread(&amp;TextureCache::loadImage, this);

        // 是否退出变量
        _needQuit = false;
    }

    if (0 == _asyncRefCount)
    {
        /** 
        向Scheculer注册一个更新回调函数
        Cocos2d-x会在这个更新函数中检查已经加载完成的纹理
        然后每一帧对一个纹理进行处理，将这里纹理的信息缓存到TextureCache中
        */
        Director::getInstance()-&gt;getScheduler()-&gt;schedule(schedule_selector(TextureCache::addImageAsyncCallBack), this, 0, false);
    }

    // 异步加载纹理的数量
    ++_asyncRefCount;

    // 生成异步加载纹理信息的消息结构体
    AysncStruct *data = new (std::nothrow) AsyncStruct(fullPaht, callback);

    // 将生成的结构体加入到队列中
    _asyncStructQueue.push_back(data);
    _requestMutex.lock();
    _requestQueue.push_back(data);
    _requestMutex.unlock();

    // 将线程移除阻塞。表示已有空位置
    _sleepCondition.notify_one();
}
</code></pre><p>TextureCacha向Scheduler注册一个更新回调addImagesAsyncCallBack，该方法用来检查异步加载完成后的纹理的，第一次调用addImageAsync时便会开启。如下：</p>
<pre><code>void TextureCache::addImageAsyncCallBack(float dt)
{
    // 创建一个纹理对象指针
    Texture2D *texture = nullptr;
    // 创建一个异步加载消息结构体
    AsyncStruct *asyncStruct = nullptr;
    while (true)
    {
        // 锁定互斥锁
        _responseMutex.lock();
        if (_responseQueue.empty())
        {
            asyncStruct = nullptr;
        }
        else
        {
            // 获取消息结构体
            asyncStruct = _responseQueue.front();
            _responseQueue.pop_front();

            CC_ASSERT(asyncStruct == _asyncStructQueue.front());
            _asyncStructQueue.pop_front();
        }
        _responseMutex.unlock();

        if (nullptr == asyncStruct) {
            break;
        }

        // check the image has been convert to texture or not
        auto it = _textures.find(asyncStruct-&gt;filename);
        if (it != _textures.end())
        {
            texture = it-&gt;second;
        }
        else
        {
            if (asyncStruct-&gt;loadSuccess)
            {
                Image* image = &amp;(asyncStruct-&gt;image);
                texture = new (std::nothrow) Texture2D();

                texture-&gt;initWithImage(image, asyncStruct-&gt;pixelFormat);
                this-&gt;parseNinePatchImage(image, texture, asyncStruct-&gt;filename);
#if CC_ENABLE_CACHE_TEXTURE_DATA
                // cache the texture file name
                VolatileTextureMgr::addImageTexture(texture, asyncStruct-&gt;filename);
#endif
                // cache the texture. retain it, since it is added in the map
                _textures.emplace(asyncStruct-&gt;filename, texture);
                texture-&gt;retain();

                texture-&gt;autorelease();
                // ETC1 ALPHA supports.
                if (asyncStruct-&gt;imageAlpha.getFileType() == Image::Format::ETC) {
                    auto alphaTexture = new(std::nothrow) Texture2D();
                    if(alphaTexture != nullptr &amp;&amp; alphaTexture-&gt;initWithImage(&amp;asyncStruct-&gt;imageAlpha, asyncStruct-&gt;pixelFormat)) {
                        texture-&gt;setAlphaTexture(alphaTexture);
                    }
                    CC_SAFE_RELEASE(alphaTexture);
                }
            }
            else {
                texture = nullptr;
                CCLOG(&quot;cocos2d: failed to call TextureCache::addImageAsync(%s)&quot;, asyncStruct-&gt;filename.c_str());
            }
        }

        if (asyncStruct-&gt;callback)
        {
            (asyncStruct-&gt;callback)(texture);
        }

        // release the asyncStruct
        delete asyncStruct;
        --_asyncRefCount;
    }

    if (0 == _asyncRefCount)
    {
        Director::getInstance()-&gt;getScheduler()-&gt;unschedule(CC_SCHEDULE_SELECTOR(TextureCache::addImageAsyncCallBack), this);
    }
}
</code></pre><p>在向TextureCache发起一个异步文件加载请求时，TextureCache会向Scheduler注册一个更新回调addImageAdyncCallback，然后示开启一个新的线异步加载文件。在新的线程中，文件加载完毕时将其纹理存储在_imageInfoQueue中，主线程每帧被更新回调时检查其是否有数据，如果有，则将其纹理数据缓存到TextureCache中，然后删除_imageInfoQueue中的数据。最后，当所有文件都加载完毕，则注册更新回调。</p>
<h3 id="3-异步处理的单元测试"><a href="#3-异步处理的单元测试" class="headerlink" title="3 异步处理的单元测试"></a>3 异步处理的单元测试</h3><p>在主线程上执行所有的逻辑算法，可以使程序的复杂度大大将低，并且可以经比较自由的在某些方面使用多线程。然而，Cocos2d-x的这种回调枫丹白露也使单元测试变得困难，因为它依赖于主循环。</p>
<p>单元测试通常来测试一个同步的方法，只要执行该方法，就能知道其运行结果。单元测试甚至不依赖太多的上下文，实际上太多的上下文会使单元测试变得困难。</p>
<p>对于异步方法，人们通过单元测试加入一个等待时间监听回调函数对某个布尔变量值的修改，并告知回调完成，从而完成其单元测试方法。通过这样的访问就可以测试异步方法。</p>
<p>Cocos2d-x中的回调需要通过游戏循环来驱动。单元测试除了监听异步回调，还需要驱动游戏循环才能执行Schedule，这使单元测试变得困难。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/2.5 Cocos2d-x的主线程/" data-id="cjov31rjh002z88riqhqxh5l5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/2.4 触摸" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/2.4 触摸/" class="article-date">
  <time datetime="2018-11-24T03:37:30.677Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/2.4 触摸/">2.4 触摸</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-触摸原理"><a href="#1-触摸原理" class="headerlink" title="1 触摸原理"></a>1 触摸原理</h3><p>Cocos2d跨越了多个平台，而不同平台对用户的操作存在着不同的响应机制，是怎样把它们整合起来的？以iOS为例，引擎使用了EAGLview来处理画面显示与用户交互。根据iOSSDK的设计，它为开发者提供了4个用于响应用户操作的函数。它们与Cocos2d-x中的函数十分相似。</p>
<pre><code>// 触摸开始
 - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    if (isKeyboardShown_)
    {
        [self handleTouchesAfterKeyboardShow];
        return;
    }

    int ids[IOS_MAX_TOUCHES_COUNT] = {0};
    float xs[IOS_MAX_TOUCHES_COUNT] = {0.0f};
    float ys[IOS_MAX_TOUCHES_COUNT] = {0.0f};

    int i = 0;
    for (UITouch *touch in touches)
    {
        ids[i] = (int)touch;
        xs[i] = [touch locationInView:[touch view].x * self.contentScaleFactor];
        ys[i] = [touch locationInView:[touch view].y * self.contentScaleFactor];
        ++i;
    }

    // 调用引擎用户操作处理机制
    auto glview = cocos2d::Director::getInstance()-&gt;getOpenGLView();
    glview-&gt;handleTouchesBegin(i, (intptr_t*)ids, xs, ys);
}

// 触摸移动

// 触摸结束

// 触摸取消
</code></pre><p>以上代码来自于\cocos2dx\plantform\ios\EAGLView.mm。这是段Objective-C语言编写的代码。它是引擎的开发者针对iOS平台编写的，它的功能是将iOS平台中的用户操作信息传递到引擎当中。然后让引擎的用户操作机制来处理。</p>
<p>这也是Cocos2d-X引擎实现跨平台的核心，针对各个设备平台使用不同的CCEGLView文件来处理相同的用户操作信息，然后将信息传递到引擎中。由引擎提供统一的对外接口，在开发者使用时，可以忽略各个平台的差异。</p>
<p>通过以上，我们已经找到了用户操作信息的来源，只有用户执行某一操作，才会触发对应机制的运行。在引擎中，触摸操作如同其事件一样，将会经过接收、分发、处理3个步骤。</p>
<h3 id="2-触摸的处理"><a href="#2-触摸的处理" class="headerlink" title="2.触摸的处理"></a>2.触摸的处理</h3><p>上面内容介绍了最初用户操作信息来源，引擎提供了专门有些人用户操作的类Touch。Touch的成员函数如下：</p>
<pre><code>// 构造函数
Touch ();
// view转换后的坐标
Vec2 locationInView();
// 前一次用户操作的View转换坐标
Vec2 perviousLocationInView();
// 设置用户操作数据
void setTouchInfo(int id, float x, float y);
// 返回id标识
int getID () const;
</code></pre><p>上面是类Touch的成员函数。每个Touch的对象都包含了一个用户扣件信息，其属性当中存储了id标识、X坐标、Y坐标，Touch类作用就是采集不同平台的触摸信息保存为统一格式，为后面的用户操作而准备。</p>
<p>那么，采集信息后，引擎是如何将用户操作的信息来源转化为类Touch对象的呢？并且将Touch作为EventTouch一个数据呢？承上如下：</p>
<pre><code>void EGLView::handleTouchBegin(int num, int ids[], float xs[], float ys[])
{
    intptr_t id = 0;
    float x = 0.0f;
    float y = o.0f;
    int unusedIndex = 0;
    EventTouch touchEvent;

    for (int i = 0, i &lt; numb, i++)
    {
        id = ids[i];
        x = xs[i];
        y = ys[i];

        auto iter = g_touchIdReorderMap.find(id);

        // it is a new touch
        if (iter == g_touchIdReorderMap.end())
        {
            unusedIndex = getUnusedIndex();

            // The touch is more than MAX_TOUCHES?
            if (unusedIndex == -1) {
                CCLOG(&quot;The touches is more than MAX_TOUCHES, unusedIndex = %d&quot;, unusedIndext);
                continue;
            }

            Touch* touch = g_touches[unusedIndex] = new (std::nothrow) Touch();
            touch-&gt;setTouchInfo(unusedIndex, (x - _viewProtRect.origin.x)/_scaleX, (y - _viewProtRect.origin.y)/_scaleY);

            CCLOGINFO(&quot;x = %f y = %f, touch -&gt; getLocationInView().x, touch-&gt;getLocationInview().y&quot;);

            g_touchIdReorderMap.insert(std::make_pair(id, unusedIndex));
            touchEvent._touches.push_back(touch);
        }
    }

    if (touchEvent._touches.size() == 0)
    {
        CCLOG(&quot;touchesBegan: size = 0&quot;);
        return;
    }

    touchEvent._eventCode = EventTouch::EventCode::BEGAN;
    auto dispatcher = Director::getInstance()-&gt;getEventDispatcher();
    dispatcher-&gt;dispatcheEvent(&amp;touchEvent);
}
</code></pre><p>上述代码是来自CCEGLView.cpp文件的代码片段，函数handleTouchBegin是将各个平台的用户操作数据转化为引擎所用的用户操作数据。新创建的Touch对象，被作为用户操作信息传递给了一个m_pDelegate对象，这是一个用户操作的分发对象。</p>
<h3 id="3-触摸事件"><a href="#3-触摸事件" class="headerlink" title="3 触摸事件"></a>3 触摸事件</h3><p>触摸事件也是最复杂的事件，它除了要区分多个触摸点，同一个点的事件还要通过多次分发以表示开始、移到、结束、取消等触摸状态。</p>
<p>Cocos2d-x使用EventTouch来表示一个触摸事件，每个EventTouch记录了当前屏幕上处于相同状态的一组触摸点的集合，触摸点的状态使用EventCode表示，示例如下：</p>
<pre><code>class EventTouch : public Event
{
    static const int MAX_TOUCHES = 5;
    enums class EventCode{
        GEBAN,
        MOVED,
        ENDED,
        CANCELLED
    }
    EventTouch();

    inline EventCode getEventCode() const { return _eventCode;};
    inline const std::vector&lt;Touch *&gt; getTouches() const { return _touches ;};
}
</code></pre><p>根据状态不同，同一个触摸点会经历多次事件分发。为了在多次事件中跟踪同一个触摸点，每个Touch点包含唯一一个ID，可以通过getID()来获取。</p>
<p>应用程序中通常更多的是使用单点触摸，为了简化单点触摸的处理，Cocos2d-x将一个触摸事件分为单点触摸和多点触摸两种类型，相应地对应单点和多点两种订阅者类型。</p>
<h5 id="3-1-单点触摸"><a href="#3-1-单点触摸" class="headerlink" title="3.1 单点触摸"></a>3.1 单点触摸</h5><pre><code>class EventListenerTouchOneByOne : public EventListener
{
public:
    void setSwallowTouches(bool needSwallow);
    bool isSwallowTouches();
    std::function&lt;bool(Touch*, Event*)&gt; onTouchBegan;
    std::function&lt;void(Touch*, Event*)&gt; onTouchMoved;
    std::function&lt;void(Touch*, Event*)&gt; onTouchEnded;
    std::function&lt;void(Touch*, Event*)&gt; onTouchCancelled;
}
</code></pre><p>其中，onTouchBegan具有一个布尔类型的返回值，且onTouchBegan是必须实现的，否则将接收不到任何触摸事件的通知。onTouchBegan的返回值用来告诉EventDispatcher是否应该将该触摸点后续的触摸状态传递给该订阅者，如果为false，onTouchMoved、onTouchEnded及onTouchCanceeled将接受不到任何回调。</p>
<p>如果我们希望阻止一个触摸点向后面的订阅者继续分发，可以使用setSwallowTouches(true)来实现。例如通常两个按钮不能同时处理同一个触摸点。注意，swallowTouch设置需要在onTouchBegan返回true的情况下才生效。</p>
<p>EventListenerTouchOneByOne只是将多个触摸点分成多次分发，假如屏幕上同时有4个触摸点，则一个EventListenerTouchOneByOne会分发4次。这有时候是不符合预期的，如一个元素只希望处理一个触摸点，则需要在应用程序中加入状态判定，开始处理一个触摸点之后，在该触摸点处理结束之前，拒绝其任触摸点的事件调用。否则会通常导致一些潜在bug出现，如玩家连续单击两次，会导致两次逻辑的执行。</p>
<p>Menu类使用两种状态来区分等待和处理触摸事件。</p>
<pre><code>class CC_DLL Menu : public Layer
{
public:
    enum class State{
        WAITING,
        TRACKING_TOUCH,
    };
};
</code></pre><p>然后在当前状态进行判断</p>
<pre><code>bool Menu::onTouchBegan(Touch* touch, Event* evetn)
{
    if (_state != Menu::State::WAITING || !_visible || !_enabled)
    {
        return false;
    }
}
</code></pre><h5 id="3-2-多点触摸"><a href="#3-2-多点触摸" class="headerlink" title="3.2 多点触摸"></a>3.2 多点触摸</h5><p>EventListenerTouchAllAtOnce表示一个多点触摸事件的订阅者，它包含4个回调函数，分别用来处理触摸点的开始、移动、结束及取消4种不同的状态。</p>
<pre><code>class EventListenerTouchAllAtOnce: public EventListener
{
public:
    std::function&lt;void(const std::vector&lt;Touch*&gt;&amp;, Event*)&gt; onTouchesBegan;
    std::function&lt;void(const std::vector&lt;Touch*&gt;&amp;, Event*)&gt; onTouchesMoved;
    std::function&lt;void(const std::vector&lt;Touch*&gt;&amp;, Event*)&gt; onTouchesEnded;
    std::function&lt;void(const std::vector&lt;Touch*&gt;&amp;, Event*)&gt; onTouchesCancelled;
}
</code></pre><p>每一个状态的回调都包含当前所有处于该种状态的触摸点，开发者需要使用触摸点的ID来区分每一个触摸点。</p>
<h5 id="3-3-单点和多点触摸之间的关系"><a href="#3-3-单点和多点触摸之间的关系" class="headerlink" title="3.3 单点和多点触摸之间的关系"></a>3.3 单点和多点触摸之间的关系</h5><p>在EventDispatcher内部，对于每次触摸事件，它首先将每个触摸点单独作用在每个EventListenerTouchOneByOne订阅者上面，然后将所有触摸点的集合作用在每个EventListenerTouchAllAtOnce订阅者上面。</p>
<p>但是单点触摸的操作会通过swallowTouch影响多点触摸的操作。表12.4列出了它们之间的一些影响，仅当onTouchBegain和swallowTouches同时为true时才会阻止事件的分发。</p>
<p>swallowTouches的影响</p>
<p><img src="http://7xqzxs.com1.z0.glb.clouddn.com/0814swallowTouches%E7%9A%84%E5%BD%B1%E5%93%8D.JPG" alt=""></p>
<p>当然，和其他任何事件一样，任何时候我们都可以使用stopPropagation来停止该事件的分发。不过需要注意的是，stopPropagation只停止当前触摸下的所有分发，例如MOVED状态会触发多次，则第二次不受前一次的影响；某个状态也不会影响另一个状态的分发。例如Move不影响Ended事件的分发。所有这些都需要明白，每个状态每次分发都是一个独立的事件通知。</p>
<h5 id="3-4-触摸点的的位置判断"><a href="#3-4-触摸点的的位置判断" class="headerlink" title="3.4 触摸点的的位置判断"></a>3.4 触摸点的的位置判断</h5><p>在触摸事件的处理中，通常需要利用触摸点的位置和一些元素进行碰撞检测。Touch类包含了一组不同意义的位置信息，示例如下：</p>
<pre><code>class CC_DLL Touch : public Ref
{
public:
    Vec2 getLocation() const;
    Vec2 getPreviousLocation() const;
    Vec2 getStartLocation() const;
    Vec2 getDelta() const;
    Vec2 getLocationInView() const;
    Vec2 getPreviousLocationInView() const;
    Vec2 getStartLocationInView() const;
}
</code></pre><p>它包含触摸点的当前位置、上一个位置、开始位置以及这些位置在屏幕坐标系中位置。</p>
<p>要判断一个点是否在某个元素上，首先将触摸点转换到该元素的本地坐标系，然后判断其是否在元素的范围内，示例如下：</p>
<pre><code>auto localPoint = this-&gt;convertToNodeSpace(touch-&gt;getLocation());
</code></pre><p>接下来，只要判断其在本地坐标系的坐标值范围在contentSize之内即可，这可以通过构造一个Rect变量来实现，示例如下：</p>
<pre><code>auto localPoint = this-&gt;convertToNodeSpace(touch-&gt;getLocation());
auto size = this-&gt;getContentSize();
auto rect = Rect(0, 0, size.width, size.heght);
if (rect.containsPoint(localPoint)){

}
</code></pre><h5 id="3-5-可见性与触摸事件"><a href="#3-5-可见性与触摸事件" class="headerlink" title="3.5 可见性与触摸事件"></a>3.5 可见性与触摸事件</h5><p>触摸事件的最后一个问题是与元素的可见性相关。当一个元素通过setVisible设置其为不可见的时候，它是不应该再接受触摸事件的。但元素可见性并不影响EventDispatcher对事件的分发，这要留给事件的实现者去处理。参见Menu的做法：每次onTouchBegan的时候都要去检查元素的可见性，以及所有父级链中元素的可见性。如果有任何导致该元素不可见的事件，则放弃处理，示例如下：</p>
<pre><code>bool Menu::onTouchBegan(Touch* touch, Event* event)
{
    if (_state != Menu::State::WAITING || ! _visible || !_enabled)
    {
        return false;
    }
    for (Node *c = this-&gt;_parent; c != nullptr; c = c-&gt;getParent()){
        if (c-&gt;isVisible() == false){
            return false;
        }
    }
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/2.4 触摸/" data-id="cjov31rjd002s88rimjhiexel" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Cococs2d与OpenGL-ES/">Cococs2d与OpenGL ES</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos2d-Lua/">Cocos2d-Lua</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos2d与OpenGL-ES/">Cocos2d与OpenGL ES</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cococs2d与OpenGL-ES/">Cococs2d与OpenGL ES</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cocos-Lua/">Cocos-Lua</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lua/">Lua</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Cococs2d与OpenGL-ES/" style="font-size: 12.5px;">Cococs2d与OpenGL ES</a> <a href="/tags/Cocos-C/" style="font-size: 20px;">Cocos-C++</a> <a href="/tags/Cocos-Lua/" style="font-size: 17.5px;">Cocos-Lua</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Lua/" style="font-size: 15px;">Lua</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/3.2 精灵/">3.2 精灵</a>
          </li>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/3.1（2） 纹理压缩及应用/">3.1(2) 纹理压缩及应用</a>
          </li>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/3.1（1） 纹理/">3.1 纹理</a>
          </li>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/3 全新的绘制系统/">全新的绘制系统</a>
          </li>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/2.2 OpenGL ES 着色程序/">OpenGL ES着色程序</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Zenos<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>