<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>ArrayStars</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="ArrayStars">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="ArrayStars">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ArrayStars">
  
    <link rel="alternate" href="/atom.xml" title="ArrayStars" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ArrayStars</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一些个人的总结，辩证来看，不保证完全正确。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Cocos-C++/2.3 事件机制" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/2.3 事件机制/" class="article-date">
  <time datetime="2018-11-24T03:37:30.673Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/2.3 事件机制/">2.3 事件机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Cocos2d-x3.0，较2.0较版本仅用来处理触摸、键盘、加速计等系统事件，3.0的EventDispatcher演变成一个更通用的事件分发器。它不仅用来分发系统事件，还可以分发开发者自定义事件，另外，EventDispatcher的事件分发可以根据某个元素的绘制顺序来决定其处理顺序的优先级，厦大提高了管理事件的效率。</p>
<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><p>大部分事件系统是基于订阅者设计模式来实现的，针对不同软件系统的特点，它们在使用上会有一些差别，但是其核心机制都是一致的。</p>
<h5 id="1-1-什么是事件？"><a href="#1-1-什么是事件？" class="headerlink" title="1.1 什么是事件？"></a>1.1 什么是事件？</h5><p>玩家的输入、程序内部某个处理逻辑完成，其他模块针对该行为进行一些响应操作。例如用户点击了屏幕、角色血量低于0时触发死亡事件等。</p>
<p>与其模块相比，事件可以不用依赖事件响应者的实现而预先定义一组事件类型，事件的响应者可以甚至可以在运行时动态地添加各移除，从而增加了事件分发的灵活性。例如玩家点击了屏幕，游戏中任何元素或者逻辑可以对其作出响应。</p>
<h5 id="1-2-事件的工作机制"><a href="#1-2-事件的工作机制" class="headerlink" title="1.2 事件的工作机制"></a>1.2 事件的工作机制</h5><p>事件是用来处理模块之间通信的模型。在传统实现中，模块A触发某个事件时，直接调用B的某个方法进行处理，如图所示，模块A直接调用b-&gt;method()方法进行处理。但是这使得模块A的实现依赖于模块B的实现。</p>
<p><img src="http://7xqzxs.com1.z0.glb.clouddn.com/0814%E4%BC%A0%E7%BB%9F%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F.JPG" alt=""></p>
<p>订阅者模式将事件的触发者和响应者分开，事件触发向一个公共的事件的分发器发送一个消息，而事件的响应者向事件订阅一个类型的消息。如上图，在运行时，模块B首先向事件分发器注册了一个订阅者listenerb，表明自己需要处理某个类型typeA的事件消息，listenerb中带有处理事件的一个回调方法地址func；然后模块A在事件发生时向事件分发器发出类型为typeA的事件消息通知，并传入一些事件参数args；事件颁发器在接受到事件消息之后，从订阅者列表中查找到订阅者listernerb，触发listenerb回调func，并传入事件参数args。</p>
<h5 id="1-3-事件系统的特点"><a href="#1-3-事件系统的特点" class="headerlink" title="1.3 事件系统的特点"></a>1.3 事件系统的特点</h5><p>（1）事件系统使得系统或者中间件可以提前预定义一些事件。</p>
<p>如上图，由于模块A不依赖于模块B的实现，所以可以提前定义一些事件类型，在运行时动态加入一些订阅者也会响应这些事件。例如Cocos2d-x提供触摸、加速计等系统事件，游戏在运行时可以决定时是否需要处理这些事件。</p>
<p>（2）解除了模块之间的耦合</p>
<p>事件系统使得模块之间更加独立，这对于单元测试更加重要，因为B模块可能是一个UI模块，引入UI元素会给模块A的单元测试带来困难。</p>
<p>（3）一个事件对应多个订阅者</p>
<p>多个订阅者可以对一个事件进行响应，以执行不同职能上的逻辑处理。例如一个物理碰撞事件发生时，物理引擎需要计算碰撞后的位置，AI系统需要做一些数值计算，而动画系统可能会播放一些动画特效。</p>
<p>（4）有局限，不是通用的。</p>
<p>比如对于性能要求高的部分，一个AI算法可能要在每帧时时更新上百个角色游戏状态，这就不适合使用事件来分发，因为事件分发会做一些查询、排序先等操作，会影响实时性；另外，事件机制不能很好的处理回调，虽然可以在事件参数中加入回调的方法地址，但是直接调用会更加直观得多。</p>
<h3 id="2-订阅者"><a href="#2-订阅者" class="headerlink" title="2 订阅者"></a>2 订阅者</h3><p>一个订阅者是一个EventListener的子类，如果某个修理程序关心某个事件，则创建一个对应的EventListener子类的实例，例如EventListenerTouch用来响应触摸事件。</p>
<p>每个EventListener由一个回调函数、一个订阅者类型type、一个listenerID组成。当然，有些事件对应多个处理函数，例如EventListenerKeyboard就根据其键按下（Pressd）和释放（Released）状态提供两个回调函数。</p>
<pre><code>class EventListener : public Ref
{
publick:
    enum class Type
    {
        UNKNOWN,
        TOUCH_ONT_BY_ONE,
        TOUCH_ALL_AT_ONECE,
        KEYBOARD,
        MOUSE,
        ACCELERATION,
        FOCUS,
        CUSTOM,
    }
    typedef std::string ListenerID;
        inline Type getType() const {return _type;};
        inline const ListenerID&amp; getListenerID() const {return _listenerID; };
        std::function&lt;void(Event*)&gt; _onEvent;
}
</code></pre><p>EventDispatcher能够根据事件的类型找到对应的listenerID，进而找到所有处理该事件的订阅者。这是有两种类型：type和listenerID。</p>
<p>（1）listnerID是在订阅事件的类里初始化的，即EventListener的子类。在Dispatcher里面，可以通过事件的类型EventType，获取到对应事件监听者类，并访问它的LISTENER_ID，然后通过该LISTENER_ID查找所有离经订阅者，调用回调。</p>
<p>（2）type是EventDispatcher来区分使用哪个EventListener的，根据type获取该类后访问获取该类的LISTENER_ID。</p>
<p>listernerID对应一个事件源，它可以根据一个事件源的类型找到一个对应的listernerID；而type是Cocos2d-x用来区分EventListener类型的，主要体现在开发者定义的所有事件类型的type都是EventListener::Type::CUSTOM。订阅者类型及listenerId如下：</p>
<p><img src="http://7xqzxs.com1.z0.glb.clouddn.com/0814%E8%AE%A2%E9%98%85%E8%80%85%E7%B1%BB%E5%9E%8B%E5%8F%8AlistenerID.JPG" alt=""></p>
<h5 id="2-1-事件"><a href="#2-1-事件" class="headerlink" title="2.1 事件"></a>2.1 事件</h5><p>一个事件用一个Event的子类描述，它也是事件分发到订阅者时事件源传递绘订阅者的参数，里面包含了一些处理该事件相关的信息，例如EventAcceleration就包含了x、y、z三个方向的加速度数据。</p>
<p>Event的子类由一个类型Event::Type和一些整体数据组成，示例如下：</p>
<pre><code>class Event : public Ref
{
public:
    enum class Type{
        TOUCH,
        KEYBOARD,
        ACCELERATION,
        MOUSE,
        FOCUS,
        CUSTOM
    }

protected:
    Event(Type type);

public:
    inline Type getType() const {return _type};
}
</code></pre><p>EVENTTYPE可以用来查找listenerID，从而将事件分发到正确的订阅者进行处理。Event::Type与listenerID对应关系如下：</p>
<p><img src="http://7xqzxs.com1.z0.glb.clouddn.com/0814%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%90%84%E8%AE%A2%E9%98%85%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.JPG" alt=""></p>
<p>对于触摸事件，它对应TOUCH_ONE_BY_ONE和TOUCH_ALL_AT_ONCE两个订阅者，这是经过EventDispatcher特殊处理的。</p>
<p>对于自定义事件，参数EventName作为listenerID，对应EventListener::Type::CUSTOM中的eventName，所以每个不同eventName的自定义事件都是一个新的事件类型，但他们共享一个type名称。</p>
<h5 id="2-2-注册与管理订阅者"><a href="#2-2-注册与管理订阅者" class="headerlink" title="2.2 注册与管理订阅者"></a>2.2 注册与管理订阅者</h5><p>开发者需要向EventDispatcher注册以接受事件通知。EventDispatcher提供了一些注册注册和管理订阅者的接口，大概分为：注册、删除、修改3组。</p>
<p>（1）注册订阅者</p>
<pre><code>// 注册场景图（主要为UI）的一个订阅者，优先级默认为0
void addEventListenerWithSceneGraphPriority(EventListener* listener, Node* node);

// 注册一个指定优先级的订阅者
void addEventListenerWithFixedPriority(EventListner* listener, int fixedPriority);

// 注册一个自定义事件的订阅者，最后会调用addEventListenerWithFixedPriority
EventListenerCustom* EventDispatcher::addCustomEventListener(const std::string &amp;eventName, const std::function&lt;void(EventCustom*)&gt;&amp; callback)
</code></pre><p>除了传入listener参数，还有指定一个关联的Node或者一个整数的优先级，这些用来决定同一个事件源的多个订阅者应该按照怎样的顺序分发事件。</p>
<p>给订阅者指定处理优先级，可以让某些元素优先处理触摸事件，这样它可以使此事件不再向后面的订阅者传递，但是开发者也可怜使用它来处理逻辑上的优先级。</p>
<p>对于UI元素，如果指定整数的优先级，通常要求开发者记住大量的优先级数字，如果一个更下层的UI元素被错误地指定了一个更高的优先级，会给触摸带来麻烦。因此，Cocos2d-x3.0新增加了一种将分发优先级与一个Node元素关联的方式：EventDispatcher将自动根据该Node元素绘制的相反顺序来决定分发优先级，所以，即使该UI元素层级发生变更，它也能正确处理，这样就简化了对触摸优先级的管理。</p>
<p>EventDispatcher分发事件的优先级如下：</p>
<ul>
<li>prority &lt; 0</li>
<li>prority = 0 (scene graph)</li>
<li>prority &gt; 0</li>
</ul>
<p>所有的与Node关联的订阅者优先级都被设置为0，而且开发者无法注册一个指定优先级为0的订阅者。</p>
<p>（2） 删除订阅者</p>
<pre><code>void removeEventListener(EventListener* listener);
void removeEventListenerForType(EventListener::Type listenerType);
void removeEventListenerForTarget(Node* target, bool recursive = false);
void removeCustomEventListeners(std::string&amp; customEventName);
void removeAllEventListeners();
</code></pre><p>另外，对于与一个Node元素关联的订阅者，它会在该Node元素被移除的时候自动删除与该Node关联的所有订阅者，但是也可以提前手动删除某个Node关联的所有订阅者。</p>
<p>（3）修改订阅者</p>
<p>当Node元素的onEnter方法和onExit方法被调用时，它将恢复和暂停所有的动画。计时更新，以及所有与之关联的事件订阅者。对于事件订阅者，它使用以下两个方法来关闭和开启订阅者是否接受事件通知。</p>
<pre><code>void pauseEventListenersForTarget(Node* target, bool recursive = false);
void resumeEventListenersForTarget(Node* target, bool recursive = false);
</code></pre><p>上述方法只用于Node事件，对于使用优先级定义的订阅者，则需要使用setEnabled</p>
<pre><code>class EventListener : public Ref
{
    public:
    inline void setEnabled(bool enabled) {_isEnabled = enabled; };
    inline bool isEnabled() const { return _isEnabled };
}
</code></pre><p>然而遗憾的是，我们无法动态判断一个订阅者是通过优先级定义的还是通过与Node元素关联定义的，因为getAssociateNode是私有方法。</p>
<p>我们可以通过setPriority()方法来修改订阅者的优先级。但这是也要确保该订阅者是一个通过优先级定义的订阅者。</p>
<pre><code>void setPrority(EventListener* listener, int fixedPriority);
</code></pre><h3 id="3-事件分发"><a href="#3-事件分发" class="headerlink" title="3 事件分发"></a>3 事件分发</h3><p>Event定义了一个事件类型，以及处理该事件相关的一些数据，EventDispatcher能够根据Event的类型找到与之相匹配的订阅者进行事件分发。示例如下：</p>
<pre><code>void dispatchEvent(Event* event);
void dispatchCustomEvent(const std::string &amp;eventName, void *optionalUserData = nullptr);
</code></pre><p>对于一个自定义事件也可以直接传递一个事件名称及一个数据对象，由EventDispatcher帮助构造一个EventCustom对象。并通过getUserData来获取事件参数进行处理。EventCustom的定义如下：</p>
<pre><code>class EventCustom : public Event
{
public:
    EventCustom(const std::string&amp; eventName);
    inline void setUserData(void* data) { _userData = data; };
    inline void* getUsetData const (return _userData);
    inline const std::string&amp; getEventName() const {return _eventName; };

protected:
    void* _userData;
    std::string _eventName;
}
</code></pre><p>触发一个事件，在使用上很简单，但是却经过了很多处理。例如怎样保证分发的顺序，一个事件分发过程中触发一个循环事件会发生什么，以及注册、删除一个订阅者会发生什么，高优先级的订阅者怎样停止向低优先级的订阅者继续传递。diapatchEvent方法如下：</p>
<pre><code>void EventDispatcher::dispatchEvent(Event* event)
{
    if (!_isEnabled)
        return;

    updateDirtyFlagForSceneGraph();

    DispatchGuard guard(_inDispatche);

    if (event-&gt;getType() == Event::Type::TOUCH)
    {
        dispatchTouchEvent(static_cast&lt;EventTouch*&gt;(event));
        return;
    }

    auto listenerID = __getListenerID(event);
    sortEventListeners(listenerID);

    auto iter = _listenerMap.find(listenerID);
    if (iter != _listenerMap.end())
    {
        auto listeners = iter-&gt;second;
        auto onEvent = [&amp;event](EventListener* listener) -&gt; bool{
            event-&gt;setCurrentTarget(listener-&gt;getAssociatedNode());
            listener-&gt;_onEvent(event);
            return event-&gt;isStopped();
        }
        dispatchEventToListeners(listeners, onEvent);
    }
    updateListeners(event);
}
</code></pre><h5 id="3-1-订阅者的排序"><a href="#3-1-订阅者的排序" class="headerlink" title="3.1 订阅者的排序"></a>3.1 订阅者的排序</h5><p>EventDispatcher在什么时候及怎样保证订阅者的顺序呢？</p>
<p>订阅者的优先级或者相关联的Node的层级可能随时发生变动，为了保证事件分发能够按正确的顺序进行，并且尽量避免频繁的重新排序带来分发的性能问题，EventDispatcher采取了一种策略来对订阅者进行排序：在变动时标记，在分发前重新排序，并且只对当前事件类型对应的listenerID订阅者进行排序。</p>
<p>下图是影响排序的一些操作，这些操作包括对Node和Priority订阅者的影响。一旦这些操作发生，EventDispatcher会将这些订阅者保存到一个dirty表，在事件分发前对其进行重新排序。如当改变Node的Zorder时会调用如下方法：</p>
<pre><code>void EventDispatcher::setDirtyForNode(Node* node)
{
    // 当该Node是一个已存在的订阅者的时候添加
    if (_nodeListenersMap.find(node) != _nodeListenersMap.end())
    {
        _dirtyNodes.insert(node);
    }

    // 递归将其所有子类也标记
    const auto&amp; children = node-&gt;getChildren();
    for (const auto&amp; child : children)
    {
        setDirtyForNode(child);
    }
}
</code></pre><p>影响订阅者排序的操作并调用setDirtyForNode方法如下：</p>
<p><img src="http://7xqzxs.com1.z0.glb.clouddn.com/0814%E5%BD%B1%E5%93%8D%E8%AE%A2%E9%98%85%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C.JPG" alt=""></p>
<p>需要注意的是EventDispatcher只对当前正在处理的事件类型对应的订阅者进行排序，参见如下sortEventListener()方法：</p>
<pre><code>void EventDispatcher::sortEventListeners(const EventListener::ListenerID&amp; listenerID)
{
    DirtyFlag dirtyFlag = DirtyFlag::NONE;

    auto dirtyIter = _priorityDirtyFlagMap.find(listenerID);
    if (dirtyIter != _priorityDirtyFlagMap.end()){
        dirtyFlag = dirtyIter-&gt;second;
    }

    if (dirtyFlag != DirtyFlag::NONE)
    {
        dirtyIter-&gt;second = DirtyFlag::NONE;

        if ((int)dirtyFlag &amp; (int)DirtyFlag::FIXED_PRIORITY)
        {
            sortEventListenersOfFixedPriority(listenerID);
        }

        if ((int)dirtyFlag &amp; (int)DirtyFlag::SCENE_GRAPH_PRIORITY)
        {
            auto rootNode = Director::getInstance()-&gt;getRunningScene();
            if (rootNode)
            {
                sortEventListenersOfSceneGraphPriority(listenerID, rootNode);
            } else {
                dirtyIter-&gt;sceond = DirtyFlag::SCENE_GRAPH_PRIORITY;
            }
        }            
    }
}
</code></pre><p>Node订阅者排序需要遍历整个UI树，具体参考EventDispatcher::visitTarget方法。这样的操作是十分昂贵的操作，所以Cocos2d-x只对那些被用作关联订阅者的Node的绘制进行顺序发生变更时才进行标记以重新排序，这也包括Node的某一级子元素被用作关联订阅者的情形。</p>
<p>所以，对于应用程序中被用作关联订阅者的Node，应该尽量修改其绘制顺序，以此来增加事件分发的性能。</p>
<h5 id="3-2-嵌套事件"><a href="#3-2-嵌套事件" class="headerlink" title="3.2 嵌套事件"></a>3.2 嵌套事件</h5><p>事件分发是可以嵌套的，即可以在一个事件中触发另一个事件，Cocos2d-x使用一个_inDispatch来保存当前嵌套的深度，其值为0时表示没有事件分发。</p>
<p>每次调用分发事件，dispatchEvent方法会使用一个自动变量DispatchGuard来记录当前分发的深度，DispatchGuard会对_inDispatch执行加1，并在变量生命周期结束时减1.</p>
<pre><code>class DispatchGuard
{
public:
    DispatchGuard(int&amp; count):_count(count){
        ++_count;
    }

    ~DispatchGuard(){
        --_count;
    }
private:
int&amp; _count;
}
</code></pre><p>在一个嵌套事件中执行一个相同的事件会导致死循环，如下：</p>
<pre><code>auto dispatcher = getEventDispatcher();
auto eventFunc = [dispatcher](EventCustom* custom){
    dispatcher-&gt;dispatchCustomEvent(&quot;test&quot;);
}
dispatcher-&gt;addCustomEventListener(&quot;test&quot;, eventFunc);
dispatcher-&gt;dispatchCustomEvent(&quot;test&quot;);
</code></pre><h5 id="3-3-在事件分发中修改订阅者"><a href="#3-3-在事件分发中修改订阅者" class="headerlink" title="3.3 在事件分发中修改订阅者"></a>3.3 在事件分发中修改订阅者</h5><p>如果在事件分发过程中对订阅者列表进行修改，例如修改订阅者优先级、添加和删除订阅者等，会发生什么？</p>
<p>首先，在当前嵌套深度内，任何导致订阅者优先级的变更不会影响到后面订阅者的分发顺序。因为对于订阅者重新排序是在dispatchEvent中开始分发前执行的，对于优先级的修改将在下一个嵌套深度内生效，因为新事件的分发会重新对订阅者排序。</p>
<p>其次，修改后序订阅者使得其不可处理事件时，将会立即生效，这包括通过setEnabled()、setPaused()、setRegisterd()方法修改订阅者。参见如下：</p>
<pre><code>void EventDispatcher::dispatchEventToListeners(EventListenerVectors* listeners, const std::function&lt;bool(EventListener*)&gt;&amp; onEvent)
{
    bool shouldStopPropagation = false;
    auto fixedPriorityListeners = listeners-&gt;getFixedPriorityListeners();
    auto sceneGraphPriorityListeners = listeners-&gt;getSceneGraphPriorityListeners();

    ssize_t i = 0;
    // priority &lt; 0
    if (fixedPriorityListeners)
    {
        if(!fixedPriorityListeners-&gt;empty())
        {
            for (; i &lt; listeners-&gt;getGtoIndex(); ++i)
            {
                auto l = fixedPriorityListeners-&gt;at(i);
                if (l-&gt;isEnabled() &amp;&amp; !l-&gt;isPaused() &amp;&amp; l-&gt;isRegistered() &amp;&amp; onEvent(1))
                {
                    shouldStopPropagetion = true;
                    break;
                }
            }
        }
    }
}
</code></pre><p>其中，在分发过程中移除一个订阅者时并不会直接从订阅者列表移除，而是将其标记为setRegistered(false)，使得该订阅者在分发的过程中不再生效，而在分发结束时将其移除。</p>
<p>最后，如果在事件分发过程中添加了一个订阅者，则它不会立即生效，而量添加到一个临时的_toRegistered(false)，在所有事件分发结束后才加入订阅者列表。这意味着在一次分发中，不管在哪个嵌套级别新加入订阅者，在_inDispatch变为0之前都不会生效。</p>
<p>当所有嵌套事件的事件分发结束，以及_inDispatch变为0时，EventDispatcher开始更新事件分发过程中对订阅者列表的修改，移除那些registered被标记为false的订阅者，添加_toAddListeners数组的订阅者到_listenerMap，以使其在后面发生的事件中生效。具体参阅updateListener()方法。</p>
<h5 id="3-4-停止分发事件"><a href="#3-4-停止分发事件" class="headerlink" title="3.4 停止分发事件"></a>3.4 停止分发事件</h5><p>在一个事件分发过程中，优先级较高的订阅者可以选择让事件停止继续传播，这可以通过Event的stopPropagation()方法来实现。</p>
<pre><code>class Event : public Ref
{
public:
    inline void stopPropagation() {_isStopped = true;};
}
</code></pre><p>这可能适用来实现如有些任务只能被一个角色执行，但是可能有多个候选的角色，开发者只需要根据需设置它们的优先级即可。</p>
<h3 id="4-事件与Node"><a href="#4-事件与Node" class="headerlink" title="4 事件与Node"></a>4 事件与Node</h3><p>在Cocos2d-x3.0中，Node可以用来和订阅者建立联系，使订阅者的颁发顺序与该Node元素在屏幕上的层级保持一致。上面讲述了Node怎样影响EventDispatcher对订阅者的分发进行排序。除此之外，Node类还从另外两个方面影响着开发者对事件分发人使用。</p>
<h4 id="4-1-暂停与恢复"><a href="#4-1-暂停与恢复" class="headerlink" title="4.1 暂停与恢复"></a>4.1 暂停与恢复</h4><p>到目前，Cocos2d中Node除了用来显示场景，还用来执行3种逻辑相关的操作：动画（Action）、更新回调(Scheduler)、事件(Event)。</p>
<p>这些操作在Node从场景中移除之后变得毫无意义。而在另外一些情况下，开发者可能也需要让一个Node元素停止这些操作，即使它依然显示在场景中。</p>
<p>Cocos2d-x中提供了两个方法用来暂停与恢复这些操作的执行，分别是pause()方法各resume()方法，示例如下：</p>
<pre><code>void Node::pause()
{
    _scheduler-&gt;pauseTarget(this);
    _actionManager-&gt;pauseTarget(this);
    _eventDispatcher-&gt;pauseEventListenersForTarget(this);
}

 void Node::resume()
 {
    _scheduler-&gt;resumeTaget(this);
    _actionManager-&gt;resumeTarget(this);
    _eventDispatcher-&gt;resumeEventListenersForTarget(this);
 }
</code></pre><p>这可以在任何时间阻止或允许与该Node相关联的订阅者接受事件通知，但是这会同时影响更新回调和动画的执行。如果只是想控制事件相关的逻辑，则可以直接调用resumeEventListenerForTarget()和pauseEventListenerForTarget()方法。</p>
<p>在Node元素内部，当onEnter()和onExit()方法被调用时，会分别自动调用resume()和pause()方法。这也会导致所有子元素的动画、更新回调及事件订阅者都会被恢复与暂停。</p>
<h4 id="4-2-删除订阅者"><a href="#4-2-删除订阅者" class="headerlink" title="4.2 删除订阅者"></a>4.2 删除订阅者</h4><p>当一个订阅者不再被使用，或者被销毁时，需要向EventDispatcher移除该订阅者。但是使用Node订阅者则可以简化这步操作，Node元素在被释放的时候会自动移除所有与该Node关联的订阅者。</p>
<pre><code>Node::~Node()
{
    _eventDispatcher-&gt;removeEventListenersForTarget(this);
}
</code></pre><p>所以，除非需要提前移除所有订阅者，否则可以不用管理订阅者的移除。</p>
<h3 id="5-触摸事件"><a href="#5-触摸事件" class="headerlink" title="5 触摸事件"></a>5 触摸事件</h3><h5 id="5-1-多点触摸"><a href="#5-1-多点触摸" class="headerlink" title="5.1 多点触摸"></a>5.1 多点触摸</h5><h5 id="5-2-单点触摸"><a href="#5-2-单点触摸" class="headerlink" title="5.2 单点触摸"></a>5.2 单点触摸</h5><h5 id="5-3-单点和多点之间的联系"><a href="#5-3-单点和多点之间的联系" class="headerlink" title="5.3 单点和多点之间的联系"></a>5.3 单点和多点之间的联系</h5><h5 id="5-4-触摸点的位置判断"><a href="#5-4-触摸点的位置判断" class="headerlink" title="5.4 触摸点的位置判断"></a>5.4 触摸点的位置判断</h5><h5 id="5-5-可见性与触摸事件"><a href="#5-5-可见性与触摸事件" class="headerlink" title="5.5 可见性与触摸事件"></a>5.5 可见性与触摸事件</h5><p>在后面单独小结里面总。</p>
<h3 id="6-其他"><a href="#6-其他" class="headerlink" title="6 其他"></a>6 其他</h3><h5 id="6-1-其他操作系统事件"><a href="#6-1-其他操作系统事件" class="headerlink" title="6.1 其他操作系统事件"></a>6.1 其他操作系统事件</h5><p>除了EventTouch以外，Cococs2d-x还提供了其他一些事件，如EventMouse、EventAcceleration、EventKeyboard、EventFocus等事件，分别用来处理鼠标、重力加速度、键盘、焦点事件。</p>
<h5 id="6-2-自定义事件"><a href="#6-2-自定义事件" class="headerlink" title="6.2 自定义事件"></a>6.2 自定义事件</h5><p>Cocos2d-x提供了一个EventCustom用来方便使用自定义事件，开发者不需要自己去定义一种订阅者类型和事件参数就可以使用自定义事件。</p>
<p>EventCustom指定一个名字字符串名字作为listenerID创建一种类型的事件，它同时接受一个指针用来传递事件数据；而EventListenerCustom作为自定义事件的统一订阅者，每个实例的listenerID是由eventName来决定的。例如，创建一个名为“test”的自定义事件的订阅者：</p>
<pre><code>auto listener = EventListenerCustom::create(&quot;test&quot;, [](EventCustom* event){});
getEventDispatcher()-&gt;addEventListenerWithSceneGraphPriority(listener, this);
</code></pre><p>然后就可以在其他地方触发test自定义事件来传消息给EventListenerCustom。</p>
<pre><code>EventCustom event(&quot;test&quot;);
event.setUserData(this);
getEventDispatcher()-&gt;dispatcherEvent(&amp;event);
</code></pre><h5 id="6-3-内存管理"><a href="#6-3-内存管理" class="headerlink" title="6.3 内存管理"></a>6.3 内存管理</h5><p>dispatchEvent方法接受一个Event子类的指针，当事件分发完毕之后，是需要手动释放其内存的。为了简化内存管理，这里常用的做法是将其声明为自动变量而非指针。</p>
<pre><code>EventCustom event(&quot;test&quot;)
</code></pre><p>这样事件结束后，当其生命周期结束时会被自动释放。</p>
<p>如果因为某些原因，例如需要保存Event实例供多次事件使用，这里有一个问题需要注意：事件订阅者可以通过调用stopPropagation来停止事件的继续分发，但是这样直接修改Event实例，如果下一次还使用同一个实例，就会导致分发失败，而通过Event类无法还原其初始状态。</p>
<h5 id="6-4-回调与返回值"><a href="#6-4-回调与返回值" class="headerlink" title="6.4 回调与返回值"></a>6.4 回调与返回值</h5><p>如果某个事件需要返回值，则可以将这些数据保存在Event实例中，这需要自定义Event子类来保存数据；同时可以避免疏漏，可以自定义带有返回值的回调函数EventListener业强制订阅者返回数据。</p>
<p>如果事件的处理是异步的，则可以传入一个回调函数指针给订阅者，当订阅者处理完毕再回调这个函数。</p>
<p>但是，事件枫丹白露通常用来发出一种通知，大多数时候是不关心结果的。</p>
<h5 id="6-6-其他事件"><a href="#6-6-其他事件" class="headerlink" title="6.6 其他事件"></a>6.6 其他事件</h5><p>Cocos2d-x还提供了一些系统事件，它们大都通过EventCustom来实现，表12.5列出了这些事件的名称及描述。</p>
<p><img src="http://7xqzxs.com1.z0.glb.clouddn.com/0814Cocos2d%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%BA%8B%E4%BB%B6.JPG" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/2.3 事件机制/" data-id="cjov31rjf002x88ri7b4qt17m" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/2.2 Scheduler调度器" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/2.2 Scheduler调度器/" class="article-date">
  <time datetime="2018-11-24T03:37:30.669Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/2.2 Scheduler调度器/">2.2 Scheduler调度器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们知道，Cocos2d中使用一种更灵活的机制来实现游戏对象状态的更新。Scheduler负责了游戏的自定义更新、及时更新的操作。开发者通过向Scheduler注册一个回调函数来更新逻辑。</p>
<h3 id="1-Scheduler的创建与调用"><a href="#1-Scheduler的创建与调用" class="headerlink" title="1 Scheduler的创建与调用"></a>1 Scheduler的创建与调用</h3><p>Cocos2d引擎启动后，在Director初化的时候会创建一个默认的调度管理器，调试管理器会在Director的mainLoop里的drawScene方法里面调用。代码如下：</p>
<pre><code>// director初始化函数
bool Director::init(void)
{
    _scheduler = new (std::nothrow) Scheduler();
}

// 程序入口run函数
while(!glview-&gt;windowShouldClose())
{
    QueryPerformanceCounter(&amp;nNow);
    interval = nNow.QuadPart - nLast.QuadPart;
    if (interval &gt;= _animationInterval.QuadPart)
    {
        nLast.QuadPart = nNow.QuadPart;
        director-&gt;mainLoop();
        glview-&gt;pollEvents();
    }
}

// Director主循环
void Director::mainLoop()
{
    if (! _invalid)
    {
        drawScene();
        PoolManager::getInstance()-&gt;getCurrentPool()-&gt;clear();
    }
}

// 场景绘制
void CCDirector::drawScene(void)  
{  
   // 计算时间差
    calculateDeltaTime();

    if (! m_bPaused)  
    {  
        _eventDispatcher-&gt;dispatchEvent(_eventBeforeUpdate);
        _scheduler-&gt;update(_deltaTime);
        _eventDispatcher-&gt;dispatchEvent(_eventAfterUpdate);
    }  
}  
</code></pre><p>通过以上代码可以知道，游戏每一帧，会刷新一次场景，让Scheduler更新一次，Scheduler会根传入的时间间隔，轮询每个timer，看timer累计时间是否达到触发条件，然后触发。</p>
<h3 id="2-Scheduler的update"><a href="#2-Scheduler的update" class="headerlink" title="2 Scheduler的update"></a>2 Scheduler的update</h3><p>通过上面我们知道，Scheduler的update方法是在每一帧都调用的，也是引擎驱动的灵魂。那么Scheduler的updata都做了哪些事情呢？</p>
<pre><code>void Scheduler::update(float dt)
{
    // 加一个状态锁
    _updateHashLocked = true;

    // 时间速率调整
    if (_timeScele != 1.0f)
    {
        dt *= _timeScale;
    }

    // 定义两个链表遍历指针
    tListEntry *entry, *tmp;

    // 处理优先级小于0的定时器(永久重复)
    DL_FOREACH_SAFE(_updatesNegList, entry, tmp)
    {
        if ((!entry-&gt;paused) &amp;&amp; (!entry-&gt;markedForDeletion))
        {
            entry-&gt;callback(dt);
        }
    }

    // 处理优先级为0的定时器(永久重复)
    DL_FOREACH_SAFE(_updates0List, entry, tmp)
    {
        if ((!entry-&gt;paused) &amp;&amp; (!entry-&gt;markedForDeletion))
        {
            entry-&gt;callback(dt);
        }
    }

    // 处理优先级大于的定时器(永久重复)
    DL_FOREACH_SAFE(_updatesPosList, entry, tmp)
    {
        if ((!entry-&gt;paused) &amp;&amp; (!entry-&gt;markedForDeletion))
        {
            entry-&gt;callback(dt);
        }
    }

    // 遍历_hashForTimers里自定义的计时器对象列表
    for (tHashTimerEntry *elt = _hashForTimers; elt != nullptr;)
    {
        // 设置当前遍历的对象
        _currentTarget = els;
        // 标记当前定c对象是否被回收
        _currentTargetSalvaged = false;

        if (!_currentTarget-&gt;paused)
        {
            // 遍历每个对象的定时器列表
            for (elt-&gt;timerIndex = 0; elt-&gt;timerIndex &lt; elt-&gt;timers-&gt;num; ++elt-timerIndex))
            {
                elt-&gt;currentTimer = (Timer*)(elt-&gt;timers-&gt;arr[elt-&gt;timerIndex]);
                elt-&gt;currentTimerSalvaged = false;
                // 定时器进行时间更新
                elt-&gt;currentTimer-&gt;update(dt);

                if(elt-&gt;currentTimerSalvaged)
                {
                    elt-&gt;currentTimer-&gt;release();
                }
                // currentTimer指针使用完了，设置成空指针
                elt-&gt;currentTimer = nullptr;
            }
        }
        // 因为下面可能要清除这个对象currentTarget，为了继续循环下去，这里先在currentTarget对象还存在的状态找到下一个链表。
        elt = (tHashTimerEntry)elt-&gt;hh.next;

        // 如果_currentTargetSalvaged为true且这个对象的定时器列表为空，那么这个对象要从_hashForTimers列表里移除。
        if (_currentTargetSalvaged &amp;&amp; _currentTarget-&gt;timers-&gt;nums == 0)
        {
            removeHashElement(_currentTarget);
        }
    }

    // 下面继续一些清理工作
    for (auto &amp;e : _updateDeleteVector)
        delete e;
    _updateDeleteVector.clear();
    _updateHashLocked = false;
    _currentTarget = nullptr;

    //清理脚本回调 
    #if CC_ENABLE_SCRIPT_BINDING
    // Iterate over all the script callbacks
    if (!_scriptHandlerEntries.empty())
    {
        for (auto i = _scriptHandlerEntries.size() - 1; i &gt;= 0; i--)
        {
            SchedulerScriptHandlerEntry* eachEntry = _scriptHandlerEntries.at(i);
            if (eachEntry-&gt;isMarkedForDeletion())
            {
                _scriptHandlerEntries.erase(i);
            }
            else if (!eachEntry-&gt;isPaused())
            {
                eachEntry-&gt;getTimer()-&gt;update(dt);
            }
        }
    }
#endif
    // 上面是对象的定时任务，这里多线程处理函数的定时任务
    // Testing size is faster than locking / unlocking.
    // And almost never there will be functions scheduled to be called.
    if( !_functionsToPerform.empty() ) {
        _performMutex.lock();
        auto temp = _functionsToPerform;
        _functionsToPerform.clear();
        _performMutex.unlock();
        for( const auto &amp;function : temp ) {
            function();
        }
    }

}
</code></pre><p>Scheduler主要处理了所有的定时器，以及相关方法的回调？那么处理的这些定时器又是什么时候创建的呢？这会在下面Node与Scheduler中说明。</p>
<h3 id="3-Node的更新与Scheduler"><a href="#3-Node的更新与Scheduler" class="headerlink" title="3 Node的更新与Scheduler"></a>3 Node的更新与Scheduler</h3><p>每个Node的Scheduler之所以能正常工作，是因为他在构造函数中直接用的director的，靠application的死循环触发工作。代码如下：</p>
<pre><code>_scheduler = _director-&gt;getScheduler();
_scheduler-&gt;retain();
</code></pre><p>在Node中并没有创建新的Scheduler而是使用了Director中创建人Scheduler，所以在Node中调用Scheduler是调用了Director中Scheduler的相关操作。</p>
<p>Node提供了两种注册更新回调方法的类型，一种是每帧都会调用，一种是按时间间隔来调用，既自定义更新回调。这两种方法分别调用了Scheduler中与之对应的方法来注册回调函数。</p>
<p>Node中的方法如下：</p>
<pre><code>// 注册自定义更新（update）
void Node::schedule(SEL_SCHEDULE selector, float interval, unsigned int repeat, float delay)
{
    _scheduler-&gt;schedule(selector, this, interval, repeat, delay, !_running);
}

// 注册自定义更新回调方法
void Node::schedule(const std::function&lt;void(float)&gt;&amp; callback, float interval, unsigned int repeat, float delay, const std::string &amp;key)
{
    _scheduler-&gt;schedule(callback, this, interval, repeat, delay, !_running, key);
}

// 注册每帧回调
void Node::scheduleUpdate()
{
    scheduleUpdateWithPriority(0);
}

void Node::scheduleUpdateWithPriority(int priority)
{
    _scheduler-&gt;scheduleUpdate(this, priority, !_running);
}
</code></pre><p>上面Node注册更新回调的时候是通过Scheduler的scheule和schduleUpdata方法，并将回调自身、时间间隔、重复次数等参传了过去，那么Scheduler对应的方法中又做了那些操作？</p>
<pre><code>// 自定义更新（update）的实现
void Scheduler::schedule(SEL_SCHEDULE selector, Ref *target, float interval, unsigned int repeat, float delay, bool paused)
{

    // 从已注册了更新回调的对象表里查找是否有该对目标对象
    tHashTimerEntry *element = nullptr;
    HASH_FIND_PTR(_hashForTimers, &amp;target, element);

    // 如果不存在，则注册添加一个
    if (! element)
    {
        element = (tHashTimerEntry *)calloc(sizeof(*element), 1);
        element-&gt;target = target;

        HASH_ADD_PTR(_hashForTimers, target, element);
        element-&gt;paused = paused;
    }
    else
    {
        CCASSERT(element-&gt;paused == paused, &quot;element&apos;s paused should be paused.&quot;);
    }

    // 为该对象创建计时器
    if (element-&gt;timers == nullptr)
    {
        element-&gt;timers = ccArrayNew(10);
    }
    else
    {
        for (int i = 0; i &lt; element-&gt;timers-&gt;num; ++i)
        {
            TimerTargetSelector *timer = dynamic_cast&lt;TimerTargetSelector*&gt;(element-&gt;timers-&gt;arr[i]);

            if (timer &amp;&amp; selector == timer-&gt;getSelector())
            {
                timer-&gt;setInterval(interval);
                return;
            }
        }
        ccArrayEnsureExtraCapacity(element-&gt;timers, 1);
    }

    TimerTargetSelector *timer = new (std::nothrow) TimerTargetSelector();
    timer-&gt;initWithSelector(this, selector, target, interval, repeat, delay);
    ccArrayAppendObject(element-&gt;timers, timer);
    timer-&gt;release();

}

// 自定义回调方法的实现
void Scheduler::schedule(const ccSchedulerFunc&amp; callback, void *target, float interval unsigned int repeat, float delay, bool paused)
{
    // 和上面自定义更新一致，只不过多了个callback回调方法的绑定和标识key
}

// 每帧回调的实现
template &lt;class T&gt;
void scheduleUpdate(T *target, int priority, bool paused)
{
    this-&gt;schedulePerFrame([target](float dt){
        target-&gt;update(dt);
    }, target, priority, paused);
}

void Scheduler::schedulePerFrame(const ccSchedulerFunc&amp; callback, void *target, int priority, bool paused)
{
    tHashUpdateEntry *hashElement = nullptr;
    HASH_FIND_PTR(_hashForUpdates, &amp;target, hashElement);
    if (hashElement)
    {
        if (hashElement-&gt;entry-&gt;priority != priority)
        {
            unscheduleUpdate(target);
        }
        else
        {
            return;
        }
    }

    if (priority == 0)
    {
        appendIn(&amp;_updates0List, callback, target, paused);
    }
    else if (priority &lt; 0)
    {
        priorityIn(&amp;_updatesNegList, callback, target, priority, paused);
    }
    else
    {
        priorityIn(&amp;_updatesPosList, callback, target, priority, paused);
    }
}
</code></pre><p>Scheduler提供了一种简单、灵活的机制，使游戏中任何对象都可以简单地注册一个更新回调方法，并指定处理的优先级。但这种按游戏对象来划分游戏更新优先级的方式并不是一种合理的方式，尤其是当多个对象之间有交叉的状态读取的时候，各个对象的优先级较难排序。</p>
<p>在游戏中，对逻辑，而不是游戏对象设计优先级往往更有意义，这样我们只用关注逻辑的优先级即可，如此，一个逻辑可以成为一个子系统或者组件。</p>
<p>在Cocos2d中就有这样的例子——ActionManager和PhysicsWorld。二者都向Scheduler注册了一个更新回调，ActionManager处理所有Node对象的动画更新，PhysicsWorld处理所有与物理模拟相关的计算，而不是单独对一个Node对象进行动画和物理相关的计算。这样，ActionManager各Physice可以作为一个逻辑了系统，我们只需关注两个子系统的优先级。实际上，ActionManager更新优先级为Scheduler::PRIOTITY_NON_SYSTEM_MIN，它是整个游戏循环中优先级别最高的，以保证ActionManage始终被优先执行。PhysicsWorld的优先级为0，所以程序可以使用优先级物理模拟更高的逻辑更新。</p>
<p>如上，ActionManager和PhysicsWorld给了我们一个启示：我们应该对一个逻辑注册一个更新回调，而不是对使用该逻辑的某个对象注册更新回调，这样的好处是我们只需要关心逻辑优先级，而不需要考虑对象优先级。</p>
<h3 id="5-时间线"><a href="#5-时间线" class="headerlink" title="5 时间线"></a>5 时间线</h3><p>通常情况下我们使用真实的时间线处理游戏更新。但在某些时候，我们需要使用一种相对时间线，比如加快、减慢甚至回退。</p>
<pre><code>void Scheduler::update(float dt)
{
    if(_timeScale != 1.0f)
    {
        dt *= _timeScale;
    }
}
</code></pre><p>timeScale的值会影响所有使用向Scheduler注册的更新回调，包括ActionManger及物理碰撞检测。</p>
<h3 id="6-性能问题"><a href="#6-性能问题" class="headerlink" title="6 性能问题"></a>6 性能问题</h3><p>游戏逻辑更新对游戏的性能特别敏感，因此需要小心地处理，如下原则。</p>
<p>（1）避免每帧查找。很多算法都需要从数组或者字典中某些条件的数据，进行计算，如果每一帧中有大量的查找计算，则会严重影响游戏性能，尤其是std::map查找复杂度和数量n成对数关系，所以我们应该尽量缓存查找结果。对于字典std::unordered_map使用整型作为索引。</p>
<p>（2）对一些频繁更新的状态进行缓存，确保在必要的时候再重新进行计算。例如在UI遍历的时候，如果元素的位置没有发生变化，则不会对每帧计算模型实图变换矩阵。</p>
<p>（3）对于一些与UI绘制无关。即时性不强的算法，应减少其update()方法调用的频率。</p>
<p>总之，要严格控制算法复杂度，尤其要优化一些迭代和查找算法，在某些地方可以使用内存来换取执行速度。例如，使用额外的数组来缓存一些结果，存储相同的数据的不同形式的数组来减少查找。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/2.2 Scheduler调度器/" data-id="cjov31rjb002q88ripk1tiz97" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/2.1 应用程序框架" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/2.1 应用程序框架/" class="article-date">
  <time datetime="2018-11-24T03:37:30.663Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/2.1 应用程序框架/">2.1 应用程序框架</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Cocos2d应用程序框架包括程序从哪里开始，怎样构建场景，怎样切换场景以及通过循环更新游戏逻辑。</p>
<h3 id="1-游戏生命周期"><a href="#1-游戏生命周期" class="headerlink" title="1 游戏生命周期"></a>1 游戏生命周期</h3><p>一个应用程序对应一个Application对象。Application对象的功能是管理游戏生命周期、设置默认窗口、获取平台及本地化信息。</p>
<h5 id="1-1-程序入口"><a href="#1-1-程序入口" class="headerlink" title="1.1 程序入口"></a>1.1 程序入口</h5><p>各个平台根据相应的入口，初始化一个Application对象。在Cocos2d-x中，通常不直接创建Application对象。Cocos2d-x脚本在帮助我们创建程序项目的同时会实现一个Application子类AppDelegate供开发人员自定义生命周期各个阶段的处理，示例如下：</p>
<pre><code>AppDelegate app;
return Application::getInstance()-&gt;run();
</code></pre><p>上面的代码中为何不是app-&gt;run()呢？AppDelegate是Application的子类，在Application的构造函数中会传递自身给sm_pSharedApplication变量，而getInstance返回的就是sm_pSharedApplication变量。</p>
<pre><code>class AppDelegate : private cocos2d::Application
{
public:
    AppDelegate();
    virtual ~AppDelegate();

    virtual bool applicationDidFinishLaunching();
    virtual void applicationDidEnterBackground();
    virtual void applicationWillEnterForeground();
}
</code></pre><h5 id="1-2-初始化"><a href="#1-2-初始化" class="headerlink" title="1.2 初始化"></a>1.2 初始化</h5><p>在applicationDidFinishLaunching事件中，我们需要创建一个Director，并为Director创建一个OpenGL ES窗口（Cocos2d-x中封装为 GL View），然后创建一个场景，并将它交给Director绘制出来。</p>
<p>在多屏设备中还可以创建多个Director，每个Director对应一个屏幕。Director控制着一个游戏场景中的一切，包括OpenGL ES的初始化、窗口管理、场景管理及切换、游戏循环。</p>
<p>此外，在程序启动事件中还可以做一些设置工作，例如分辨率、帧率、资源搜索目录。如下表示一个基本的应用程序初始化工作。</p>
<pre><code>bool AppDelegate::applicationDidFinishLaunching()
{
    auto director = Director::getInstance();
    auto glview = director-&gt;getOpenGLView();
    if(!glview)
    {
        glview = GLView::create(&quot;Cpp Test&quot;);
        director-&gt;setOpenGLView(glview);
    }

    director-&gt;setAnimationInterval(1.0 / 60);

    auto scene = Scene::create();
    director-&gt;runWithScene(scene);

    return;
}
</code></pre><h5 id="1-3-程序切换"><a href="#1-3-程序切换" class="headerlink" title="1.3 程序切换"></a>1.3 程序切换</h5><p>应用程序启动后，需要响应可能出现的一些切换，当玩家离开游戏应当暂停，回到游戏中应当恢复。</p>
<pre><code>void Applegate::applicationDidEnterBackground()
{
    Director::getInstance()-&gt;stopAnimation();
}

void Applegate::applicationWillEnterForeground()
{
    Directro::getInstance()-&gt;startAnimation()
}
</code></pre><h3 id="2-游戏窗口"><a href="#2-游戏窗口" class="headerlink" title="2 游戏窗口"></a>2 游戏窗口</h3><p>Director管理着一个GL View对象，它表示一个OpenGL ES窗口。GL View会初始化与OpenGL ES相关的工作，在游戏中的每一帧，Director通过该GL View来绘制场景中的元素。</p>
<p>在程序中关于窗口方面最常用的操作是通过Director查询当前窗口尺寸。Director提供了几种不同概念的窗口尺寸，示例如下：</p>
<pre><code>class CC_DLL Director:publick Ref
{
public:
    const Size&amp; getWinSize() const;       // 画布大小
    Size getWinSizeInPixels() const;      // 获取屏幕的实际分辨率
    Size getVisibleSize() const;          // 屏幕上可见区域，总是小于或等于winSize
    Vec2 getVisibleOrigin() const;        // 可视区域的起点坐标
    Vec2 convertToGL(const Vec2&amp; point);
    Vec2 convertToUI(const Vec2&amp; point);
}
</code></pre><p>画布大小可根据一定的策略被裁剪。</p>
<h3 id="3-场景管理"><a href="#3-场景管理" class="headerlink" title="3 场景管理"></a>3 场景管理</h3><p>在Cocos2d-x中一个场景是一棵以Scene为根节点的UI树，Scene包含一个专题中所有的UI元素，如按钮、人物、道路等。每个时刻最多只有一个当前场景在运行，Director管理着当前场景，并提供了在不同场景之间切换的方法。</p>
<p>通过Director:runWithScene()方法指定了一个场景，之后就可以通过getRunningScene()方法取得当前正在运行的场景。Director与场景相关的方法如下：</p>
<pre><code>class CC_DLL Director : public Ref
{
publick:
    inline Scene* getRuningScene() {return _runningScene;}
    void runWithScene(Scene *scene);
    void pushScene(Scene *scene);
    void popScene();
    void popToRootScene();
    void popToSceneStackLevel(int level);
    void replaceScene(Scene *scene);
    void drawScene();
}
</code></pre><p>Director有两种方法切换到另一个场景。一种是用replaceScene()方法直接替换，这会直接删除并释放之前的场景。如果想切换到另一个场景并且很快会切换回之前的场景，则使用pushScene和popScene。</p>
<h3 id="4-游戏循环"><a href="#4-游戏循环" class="headerlink" title="4 游戏循环"></a>4 游戏循环</h3><p>Application被初始化之后，就会开始根据设定的帧率开始循环。Application::run()是整个应用程序的入口，Director::mainLoop则定义了一个游戏循环的事件和内容。MacOS平台的Application:run示例如下：</p>
<pre><code>int Application::run()
{
    if(!applicationDidFinishLaunching())
    {
        return 0;
    }

    long lastTime = 0L;
    long curTime = 0L;

    auto director = Director::getInstance();
    auto glview = director-&gt;getOpenGLView();
    glview-&gt;retain();

    while(!glView-&gt;windowShouldClose())
    {
        lastTime = getCurrentMillSecond();
        director-&gt;mainLoop();
        glview-&gt;pollEvents();

        curTime = getCurrentMillSecond();

        if (curTime - lastTime &lt; _animationInterval)
        {
            usleep(static_case&lt;useconds_t&gt;((_animationInterval - vurTime + lasetTime)*1000)
        }

    }
    return true;
}
</code></pre><p>Cocos2d-x在每帧中发生的事情如下所示：</p>
<p><img src="http://7xqzxs.com1.z0.glb.clouddn.com/0801%E5%B8%A7%E5%BE%AA%E7%8E%AF.jpg" alt=""></p>
<p>(1)用户输入</p>
<p> 在每一帧的开始，Cocos2d-x首先检查是否有用户输入事件发生，如触摸、鼠标、重力，如有则处理和分发这些事件。</p>
<p> 这样做是合理的，因为玩家操作的是他看到的内容，而一些元素的位置都是由上一帧绘制确定的。这样做保证程序处理也是玩家所期望的结果。如果用户操作在后面处理，则元素位置可能被动画更新或者其操作所更改，可能无法实现玩家期望的操作。</p>
<p> （2）动画更新</p>
<p> ActionManger会对每个元素注册的所有动画进行响应计算，并更新其对应的属性值。</p>
<p> 动画也应该被优先处理，因为在动画计算之后，程序逻辑可能还会对值进行修改。如，一个物理世界中的怪物正在执行一个MoveTo的动作，当遇到一个障碍物，两者发生碰撞，怪物被阻止移动。如果动画放到后面处理，则可能是物理模拟或其他逻辑对元素的修改不起作用。</p>
<p> （3）物理模拟碰撞</p>
<p> 动画更新之后，默认处理物理模拟碰撞。注意，这里并不是绝对的。</p>
<p> Cocos2d-x物理实现为Scene向Scheduler注册一个优先级为0的更新处理，应用程序可能注册一个优先级更高的逻辑更新，先于物理模拟被处理。开发者有机会区分哪些逻辑更新应该发生在物理碰撞之前。但是在Cocos2d中这一点并不明显，示例如下：</p>
<pre><code>bool Scene::initWithPhysices()
{
   bool ret = false;
   do
   {
       Director *director;
       CC_BREAK_IF(!(director = Director::getInstance()));
       this-&gt;setContentSize(director-&gt;getWinSize());
       cc_BREAK_IF(!(_physicsWorld = PhysicsWorld::construct(*this)));

       this-&gt;schedulerUpdate();
       ret = true;
   } while(0);
   return rect;
}
</code></pre><p>（4）逻辑更新</p>
<p>程序大部分的算法和逻辑在这里处理，这里是修改元素属性的最后机会。由于Scheduler管理优先级的灵活性，应该小心处理逻辑计算的优先级。</p>
<p>（5）UI树的遍历</p>
<p>逻辑更新后，开始UI树的遍历。UI树的遍历主要是给每个元素云计算坐标变换矩阵，以及根据程序指定的逻辑深度进行排序，以便生成正确的绘制顺序。每个节点被遍历之后将会发送绘制命令至绘制栈。</p>
<p>（6）绘制</p>
<p>UI树遍历完成之后，渲染系统开始根据元素的逻辑顺序进行绘制，这一部分是与OpenGL ES相关的内容。全部绘制完成之后，交换前后缓冲区，以当前帧的内容绘制到屏幕上。</p>
<p>（7）释放</p>
<p>最后，PoolManager会释放当前帧所有autorelease对象，使我们可以只关心对象的创建和使用。</p>
<h3 id="5-更新游戏对象Scheduler"><a href="#5-更新游戏对象Scheduler" class="headerlink" title="5 更新游戏对象Scheduler"></a>5 更新游戏对象Scheduler</h3><p>游戏不同于传统游戏的最大差别是，游戏是一个实时、动态的模拟系统，每一刻游戏中各个对象的状态都可能发生改变。因此，游戏系统使用一种游戏循环机制来更新游戏对象的状态。</p>
<p>游戏使用一定的时间频率来更新游戏对象的状态，以及各种游戏引擎子系统，如物理碰撞、动画、渲染系统等。游戏引擎的更新不仅要解决性能问题，还要保证各个子系统及逻辑更新的时序。</p>
<p>（1）以游戏对象为单位更新</p>
<p>有些引擎使用通用的游戏对象基类来更新游戏对象，这种设计中，游戏引擎会管理游戏对象，并在每一帧执行其虚函数。</p>
<p>但是以游戏对象为单位的更新系统有一些缺点。一是很多游戏对象可能不需要更新游戏状态；二，这些对象通常表示一种特定的类型，如Unity中的GameObject，如果是其他类型，则需要特殊的处理方式；三，以游戏对象为单位的更新在处理多个对象有交叉逻辑关系时的更新优先级问题上存在着一些麻烦。</p>
<p>（2）Cocos2d的如何实现游戏对象的更新</p>
<p>Cocos2d-x使用一种更灵活的的机制来实现游戏对象状态的更新，开发者通过向Scheduler注册一个回调函数来更新逻辑。</p>
<p>至于Scheduler将单独在下一节中整理。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/2.1 应用程序框架/" data-id="cjov31rj9002l88riyqu37q8b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/2 引擎架构" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/2 引擎架构/" class="article-date">
  <time datetime="2018-11-24T03:37:30.659Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/2 引擎架构/">2 cocos2d-x 引擎架构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>大多数游戏引擎都是按照其使用方式构建的，各个系统之间可能交叉在一起。下面是一般游戏引擎的大概架构。</p>
<p><img src="http://7xqzxs.com1.z0.glb.clouddn.com/0728Coco2d%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84.PNG" alt=""></p>
<p>了解Cocos2d-x可以从以下几个方面来看：</p>
<h3 id="1-开源库"><a href="#1-开源库" class="headerlink" title="1 开源库"></a>1 开源库</h3><p>Cocos2d使用了许多第三方开源库，如下图。用于支持文件解压、图片解析、网络支持、物理引擎、音频等功能。从而使Cocos2d能够更专注于引擎的开发。</p>
<p><img src="http://7xqzxs.com1.z0.glb.clouddn.com/0728Cocos2d%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BC%80%E6%BA%90%E5%BA%93.JPG" alt=""></p>
<h3 id="2-跨平台"><a href="#2-跨平台" class="headerlink" title="2 跨平台"></a>2 跨平台</h3><p>Cocos2d-x封装了一些与平台无关的接口，如文件的加载、纹理的解析、线程的操作，这使得渲染与其系统的设计与平台无关。此外，Cocos2d-x封装了基础的啊功能模块，这些供上层所有游戏系统使用，包括内存管理模式、纹理资源的加载各缓存。</p>
<h3 id="3-数据"><a href="#3-数据" class="headerlink" title="3 数据"></a>3 数据</h3><p>Cocos2d还提供了一组数据容器，使STL中的容器可以与Cocos2d内存管理模式相结合。</p>
<h3 id="3-渲染"><a href="#3-渲染" class="headerlink" title="3 渲染"></a>3 渲染</h3><p>渲染系统是Cocos2d-x系统的核心部分，它包含了场景中元素的层级结构、关系。还有元素的管理、遍历、绘制等。这些元素包括Node、Sprite、Layer、TileMap、Particle等。这一层也是与OpenGL ES交互的部分。</p>
<h3 id="4-动画"><a href="#4-动画" class="headerlink" title="4 动画"></a>4 动画</h3><p>Cocos2d-x有一套优秀的动画系统，它不仅支持第三方设计工具，使用起来非常简单。Cocos2d将一些非动画的特性（如回调函数）与动画结合起来，简化了游戏开发工作，这是Cocos2d在2D领域非常出色的重要原因。</p>
<h3 id="5-工具"><a href="#5-工具" class="headerlink" title="5 工具"></a>5 工具</h3><p>Cocos2d支持非常丰富的第三方工具，如TexturePacker、SpriteHelper、Tiled、zwoptx、ParticleDesigner、GlyphDesigner、CocosBuiler，而且Cocos也有自己的工具CocosStudio，它集成的场景编辑、动画设计、粒子特效。骨骼等功能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/2 引擎架构/" data-id="cjov31rj4002e88ri909gk2po" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/1.4 内存管理总结" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/1.4 内存管理总结/" class="article-date">
  <time datetime="2018-11-24T03:37:30.655Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/1.4 内存管理总结/">1.4 内存管理总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Cocos2d-x内存管理使用注意事项如下：</p>
<p>（1） Ref的引用计数并不是线程安全的。在多线程中，我们需要通过处理互斥锁来保证线程安全。在Objective-C中，由于AutoreleasePool是是语言级别的系统实现，所以每个线程都有自己的AutoreleasePool队列。在Cocos2d-x中，从性能等方面考虑，没有提供线程的安全实现。</p>
<p>（2）对自定义Node的子类，为该类添加create()方法，并使该方法返回一个autorelease对象。</p>
<p>（3）对自定义的数据类型，如果需要动态分配内存，继承自Ref，使用智能指针RefPtr来管理其内存的释放。</p>
<p>（4）对只在一个方法内部使用的Ref对象，需要使用自动回发池的，应该使用自定义的AutoreleasePool来即时清理对内存的占用。</p>
<p>（5）不要动态分配AutoreleasePool对象，要始终使用自动变量。</p>
<p>（6）不要显式地调用RefPtr的构造函数，始终使用隐式方式调用构造函数，因为显式的构造函数会导致同时执行构造函数各赋值操作符，这会造成一次不必要的临时智能指针变量的产生。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/1.4 内存管理总结/" data-id="cjov31riw002188ribcda6rlu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/1.3 Cocos2d-x智能指针" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/1.3 Cocos2d-x智能指针/" class="article-date">
  <time datetime="2018-11-24T03:37:30.649Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/1.3 Cocos2d-x智能指针/">1.3 Cocos2d-x智能指针</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>（1）Cocos2d autorelease内存管理的梳理：</p>
<p>Cocos2d-x中所有的内存管理方式基础是引用计数，动态分配一个Ref对象后，其引用计数为1，并通过retain()方法和release()方法来增加和减少其引用计数。</p>
<p>为了正确的释放内存，Cocos2d-x使用自动回发池来管理对象。autorelease类似于一个共享的智能指针，该指针的作用域为一帧，该帧结束后，自动释放池将会清空，它将释放它自己的那个引用。如果此时没用其他共享指针的引用，引用计数为0，该对象被delete，如果有其他引用，则保留。</p>
<p>对于其他引用，我们通常会将一个autorelease对象加入到Vector或者Map中，如Node的所有子元素存储在一个Vector&lt;Node*&gt;中，Vector和Map对新加入的元素执行retain操作，并对从中移除元素执行release操作。这样元素在Vector或者Map中正确管理对象。</p>
<p>（2）为什么使用智能指针？</p>
<p>对于单个的非集合元素对象，我们往往不会通过Autorelease来管理，除非它是一个临时对象，如果此时使用retain()或release()，等价于new()和delete()，容易导致内存管理问题。因此，Cocos2d-x3.1中引入了RefPtr<t>智能指针。</t></p>
<p>（3）什么是智能指针？</p>
<p>RefPtr基于RALL实现，动态资源的持有发生在一个对象的生命周期之内，也就是在对象的构造函数中分配内存，析构函数中释放内存。这就是我们之前讲到的将动态资源映射到一个自动变量，通过自动变量的构造函数和析构函数来进行内存管理。这可以保证资源始终被释放（即使出现异常），这也是各种智能指针（如std::shared_ptr）的实现原理。</p>
<p>RefPtr实际上是模仿C++ 11中的std::shared_ptr实现的，它保持着一个Ref*对象的强引用，并使用Cocos2d-x自身的引用计数来管理多个智能指针对内存的共享，并且能够与Cocos2d-x的内存管理模式相结合，但是它无法保证内存的安全。与shared_ptr相比，它更轻量级，更高效。但是cocos2d并没有提供与std::unique_ptr和std::weak_ptr的功能类似的智能指针。</p>
<h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1 构造函数"></a>1 构造函数</h3><p>RefPtr需要依赖Ref的引用计数来管理内存，所有类型T必须是Ref类型，Cocos2d-x通过静态转换static_const在编译时进行类型检查。RefPtr变量和Ref指针是一种强引用关系，所以构造函数会对任何值不是nullptr的Ref指针增加其引用计数，除非它是右值。</p>
<p>RefPtr提供了多个构造函数，可以用默认构造函数声明一个空智能指针、用别的指针来声明一个智能指针、也提供了移动构造函数将内存偷过来、复制构造函数保护内存的强引用。源码如下：</p>
<pre><code>RefPtr()
    :_ptr(nullptr)
{   
}

RefPtr(T * ptr)
    :_ptr(ptr)
{
    CC_REF_PRT_SAFE_RETAIN(_ptr);
}

RefPtr(const RefPtr&lt;T&gt; &amp; other)
    :_ptr(other._ptr)
{
    CC_REF_PTR_SAFE_RETAIN(_ptr);
}

RefPtr(RefPtr&lt;T&gt; &amp;&amp; other)
{
    _ptr = other._ptr;
    other._ptr = nullptr;
}

RefPtr(std::nullptr_t ptr)
    :_ptr(nullptr)
{
}
</code></pre><p>构造函数最为重要的莫过于CC_REF_PTR_SAFE_RETAIN宏，它是智能指针专用的宏，外部无法引用，核心就是retain，保持一个强引用。</p>
<pre><code>#defint CC_REF_PTR_SAFE_RETAIN(ptr) \
    \
    do \
    {\
        if (ptr)\
        {\
            const_cast&lt;Ref*&gt;(static_cast&lt;const Ref*&gt;(ptr))-&gt;retain();\
        }\
    }\
</code></pre><p>对于右值的复制构造函数，则不会增加其引用计数，因为通常对于返回右值的方法，该方法不再负责对该对象进行内存管理，这个时候接受者不应该是共享的一方，而应该将其对内存的占用转移过来。</p>
<p>示例如下：</p>
<pre><code>// RefPtr()构造函数   
RefPtr&lt;Ref&gt; ref1;

// RefPtr&lt;T *ptr&gt; 转换函数
// 只有一个参数的构造函数可以看成一个转换函数
RefPtr&lt;__String&gt; ref2(cocos2d::String::crate(&quot;Hello&quot;));

// RefPtr(const RefPtr&lt;T&gt; &amp; other) 复制构造函数
RefPtr&lt;__String&gt; ref4(ref2);

// RefPtr(RefPtr&lt;T&gt; &amp;&amp; other)移动复制构造函数
RefPrt&lt;__String&gt; getRefPrt()
{
    RefPtr&lt;__String&gt; ref2(cocos2d::String::create(&quot;Hello&quot;));
    return ref2;
}
RefPtr&lt;_String&gt; ref4(getRefPrt);

// RefPtr(std::nullptr_t ptr) 空指针构造函数
RefPtr&lt;__String&gt; ref5(nullptr)
</code></pre><p>构造空智能指针还可以通过空引用（如ref1）的智能指针构造:</p>
<pre><code>RefPtr&lt;Ref&gt; ref5(ref1);
</code></pre><h3 id="2-赋值操作符"><a href="#2-赋值操作符" class="headerlink" title="2 赋值操作符"></a>2 赋值操作符</h3><p>与构造函数类似，对于任何左值变量的赋值，RefPtr都应该与该左值共享资源从而增加其引用计数，而对于右值，仍然应该转移而不是共享。与共享构造函数不同，赋值操作符除了会增加其资源的引用计数，还会释放对之前旧资源的引用计数。</p>
<p>RefPtr的构造函数中提供一个对类型T*的转换函数，在C++中该转换函数会被用来执行强制转换或者赋值的隐式转换，示例如下：</p>
<pre><code>RefPrt&lt;__String&gt; = ptr = cocos2d::String::create(&quot;Hello&quot;);
</code></pre><p>实际上，会调用T*到RefPtr<t>的转换构造函数，但这并不是我们想要的，因为ptr变量可能正持有其他资源。我们首先对旧资源进行释放，新资源进行引用计数加一。操作符重载如下：</t></p>
<pre><code>inline RefPtr&lt;T&gt; &amp; operator = (T * other)
{
    if (other != _ptr)
    {
        CC_REF_PTR_SAFE_RETAIN(other);
        CC_REF_PTR_SATE_RELEASE(_ptr);
        _ptr = const_cast&lt;typename std::remove_const&lt;T&gt;::type*&gt;(other);
    }
    return *this;
}
</code></pre><p>同样还提供了移动赋值函数和置空函数：</p>
<pre><code>// 移动赋值函数
inline RefPtr&lt;T&gt; &amp; operator = (RefPtr&lt;T&gt; &amp;&amp; other)
{
    if (&amp;other != this)
    {
        CC_REF_PTR_SAFE_RELEASE(_ptr);
        _ptr = other._ptr
        pther._ptr = nullptr;
    }
    return *this;
}

// 置空函数
inline RefPtr&lt;T&gt; &amp; operator = (std::nullptr_t other)
{
    CC_REF_PTR_SAFE_RELEASE_NULL(_ptr);
    return *this;
}
</code></pre><h3 id="3-弱引用赋值"><a href="#3-弱引用赋值" class="headerlink" title="3 弱引用赋值"></a>3 弱引用赋值</h3><p>无论是赋值构造函数，还是赋值操作，RefPtr都会对任何非空的左值的资源保持一种强引用的关系。但是有时候，我们仍然可能希望对左值的资源保持弱引用的关系。RefPtr通过使用weakAssign()方法来实现弱引用。如下：</p>
<pre><code>inline void weakAssign(const RefPtr&lt;T&gt; &amp; other)
{
    CC_REF_PTR_SAFE_RELEASE(_ptr);
    _ptr = other._ptr;
}
</code></pre><p>相对于其他函数，它少了retain操作，说明它并不保持对other的强引用，但是析构时我们发现依旧会release一次，这个函数有什么作用呢？</p>
<pre><code>void a()
{
    RefPtr&lt;Texture2D&gt; test;
    test.weakAssign(new Texture2d);
    // doSomething

    retain;
}

上面函数并没有delete，但是依旧不会内存泄露，相当于如下方法：

auto test = new Texture2D;
test-&gt;autorelease();

RefPtr&lt;cocos2d::Image&gt; image;
image = new cocos2d::Image();
image-&gt;release();
</code></pre><h3 id="4-其他操作"><a href="#4-其他操作" class="headerlink" title="4 其他操作"></a>4 其他操作</h3><p>RefPtr在析构函数中释放资源，这是遵循RALL原则在对象的生命周期结束时释放资源。也可以通过reset()方法来释放对其资源的占用，使其变为一个空的智能指针。</p>
<p>此外，RefPtr还重载了指针操作符*和-&gt;方便直接调用内部指针，所以其他使用方法和普通指针一样，也提供了get方法获取指针。如下：</p>
<pre><code>inline operator T * () const {return reinterpret_cast&lt;T*&gt;(_ptr);}

inline T &amp; operator * () const
{
    CCASSERT(_ptr, &quot;Attempt to dereference a null pointer&quot;);
    return reinterpret_case&lt;T&amp;&gt;(*_ptr);
}

inline T* operator-&gt;() const
{
    CCASSERT(_ptr, &quot;Attempt to dereference a null pointer&quot;);
    return reinterpret_cast&lt;T*&gt;(_ptr);
}

inline T * get() const {return reinterpret_cast&lt;T*&gt;(_ptr);}
</code></pre><h3 id="5-RefPtr与容器"><a href="#5-RefPtr与容器" class="headerlink" title="5 RefPtr与容器"></a>5 RefPtr<t>与容器</t></h3><p>如果将一个元素加入容器，它还需要结合容器对内存的使用进行内存管理，那么，RefPtr<t>能否直接加入Vector和Map中呢？答案是肯定的。</t></p>
<p>PetPtr提供了一个转换构造函数将T<em>转换为RefPtr<t>。另外，RefPtr还提供了一个到T</t></em>的转换操作符：</p>
<pre><code>inline operator T * () const { return reinterpret_cast&lt;T*&gt; (_ptr);}
</code></pre><p>当Vector<t>的pushback方法接受T的一个指针， oprator T*将会被自动调用，加入Vector。加入Vector中的元素内存也由Vector进行共享管理。示例如下：</t></p>
<pre><code>auto str = new __String(&quot;Hello&quot;);
RefPtr&lt;__String&gt; ref1 = str;

Vector&lt;__String*&gt; v;
v.pushBack(ref1)
</code></pre><p>这样，RefPtr可以同时结合Cocos2d-x中的容器一起管理内存，使对内存的管理变得更加灵活。当然，也可以直接使用“*”操作符或者get()方法获取资源的地址并将其传递给Vector.</p>
<h3 id="6-RefPtr与自动回收池的比较"><a href="#6-RefPtr与自动回收池的比较" class="headerlink" title="6 RefPtr与自动回收池的比较"></a>6 RefPtr<t>与自动回收池的比较</t></h3><p>Cocos2d-x提供了两种管理内存的方式，分别是autorelease和RefPtr，那么怎么选择这两种内存管理方式呢？我们尝用它们想到代替。</p>
<p>autorelease代替RefPtr，由于autorelease守住依赖于自动回收池的释放，所以各个共享的变量几乎无法控制对资源的使用。</p>
<p>用RefPtr代替aurorelease，那么任何一个对Node资源的引用都是一个强引用，这使得当Node从UI树中移除的时候，还需要作用reset释放其对Node资源的占用，这显然是无法控制的。</p>
<p>因此，对UI元素，我们需要使用一种弱引用类型的内存管理，只有UI树本身才可以分配释放内存，其任何地方只能是弱引用。虽然RefPtr提供了弱引用赋值，但是RefPtr不能很好地与Vector协作。用RefPtr来管理UI元素变得极其复杂。</p>
<p>所以，对于这两种内存管理方式，所有的Ui元素都需要使用autorelease来管理，而游戏中的数据则使用RefPtr.</p>
<h3 id="7-RefPtr的缺陷"><a href="#7-RefPtr的缺陷" class="headerlink" title="7 RefPtr的缺陷"></a>7 RefPtr<t>的缺陷</t></h3><p>（1）引用计数可以被RefPtr从外部控制</p>
<p>示例：</p>
<pre><code>auto str = new __String(&quot;Hello&quot;);
RefPtr&lt;__String&gt; ptr;
ptr.weakAssign(str);
str.release();
(*ptr)-&gt;getCString();           //将会访问野指针报错
</code></pre><p>由于可以从外部修改引用计数，这会使RefPtr中资源的情况变得很复杂，它可能已经被释放，所以构造函数对其释放时会导致运行时错误。开发者需要谨慎地结合使用手动内存管理和智能指针。这种情况在std:shared_pre中则不存在，因为开发者无法在外部修改引用计数。</p>
<p>（2）Ref弱引用依然可以对资源进行修改</p>
<p>虽然RefPtr提供了一种弱引用，但是这种弱引用的智能指针仍然表现为一个强类型的智能指针的行为，它仍然可以对其资源进行修改，从而导致原智能指针的行为变得不可预期。如下：</p>
<pre><code>RetPtr&lt;__String&gt; ptr1(new __String(&quot;Hello&quot;));       // 引用计数2
RefPtr&lt;__String&gt; ptr2;                              
ptr2.weakAssign(ptr1);                              // 引用计数2 
prt2.reset();                                       // 引用计数1
ptr2.reset();                                       // 被释放
(*ptr)-&gt;getCString();                               // 导致错误
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/1.3 Cocos2d-x智能指针/" data-id="cjov31ris001u88ri4efel576" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/1.2 自动释放池" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/1.2 自动释放池/" class="article-date">
  <time datetime="2018-11-24T03:37:30.644Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/1.2 自动释放池/">1.2 自动释放池</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Cocos2d-X引擎结合了手动管理和自动管理的两种内存管理方式。</p>
<p>C++是没有提供自动内存管理的，自动管理通过引擎提供的自动释放池实现。</p>
<p>对于手动管理方式，使用者需要控制对象的分配与释放过程。自动内存管理方案，无需关心释放的问题。</p>
<h3 id="1-autorelease-声明智能指针"><a href="#1-autorelease-声明智能指针" class="headerlink" title="1. autorelease()声明智能指针"></a>1. autorelease()声明智能指针</h3><p>只要继承了类Ref的任何类，就可以调用autorelease()来将此对象放入到自动释放池中进行管理。</p>
<pre><code>Node *obj = new Node();
obj-&gt;autorelease()
// 在Ref类中，m_bManaged是用来标识对象是否采用了自动释放池。
</code></pre><h5 id="1-1-在cocos2d-x中的应用"><a href="#1-1-在cocos2d-x中的应用" class="headerlink" title="1.1 在cocos2d-x中的应用"></a>1.1 在cocos2d-x中的应用</h5><p>为了简化这种声明，Cocos2d-x使用静态的create()方法来返回一个智能指针对象。Cocos2d-x中的大部分的类都可以通过create()方法返回一个智能指针对象，如Node、Action等。示例如下：</p>
<pre><code>Node *Node::create(void)
{
    Node *ret = new Node();
    if (ret &amp;&amp; ret-&gt;init()){
        ret-&gt;autorelease();
    }
    else
    {
        CC_SAFE_DELETE(ret);
    }
    return ret;
}
</code></pre><h3 id="2-AutoreleasePool"><a href="#2-AutoreleasePool" class="headerlink" title="2 AutoreleasePool"></a>2 AutoreleasePool</h3><p>用autorelease声明的这些对象并不单独关联某个变量，而是全部加入一个AutoreleasePool中，在每一帧结束的时候会对这些对象清理。也就是说，在Cocos2d-x中智能指针的生命同期为从被创建时开始，到当前帧结束。</p>
<pre><code>// 管理者获得当前自动释放池
AutoreleasePool* poolManager::getCurrentPool()
{
    returen _releasePoolStack.back();
}


//////// 添加对象

// 对象添加到释放池当中
Ref* Ref::autorelease()
{
    PoolManager::getInstance()-&gt;getCurrentPool-&gt;addObject(this);
    return this;
}

// 自动释放池添加对象
void AutoreleasePool::addObject(Ref* pObject)
{
    _managerObjectArray.push_back(pObject);
}

// poolManager它会将对象传递给自动释放池，最后的函数是将代码添加到自动释放池的具体操作。
// 自动释放池中有一个专门存放自动释放对象的数组m_pManagedObjectArray。


/////// 释放对象

// 每一帧结束清理当前AutoreleasePool()中的对象
void DisplayLinkDirector::mainLoop()
{
    if (! _invalid)
    {
        drawScene();
        PoolManager::getInstance()-&gt;getCurrentPool()-&gt;clear();
    }
}

// 对象的释放函数
void AutoreleasePool::clear()
{
#if defined(COCOS2D_DEBUG) &amp;&amp; (COCOS2D_DEBUG &gt; 0)
    _isClearing = true;
#endif

    for (const auto &amp;obj : _managedObjectArray)
    {
        obj-&gt;release();
    }
    // 清空回收池
    _managerObjectArray.clear();

#if definde(COCOS2D_DEBUG) &amp;&amp; (COCOS2D_DEBUG &gt; 0)
    _isCleaing = false;
#endif
}

// 采用多个释放池对象，虽然会增加操作的复杂，但是同时也会带来灵活。可以根据游戏内容来划分池对象，比如为每一个场景创建一个自动释放池。
</code></pre><h5 id="2-1-AutoreleasePool的具体应用"><a href="#2-1-AutoreleasePool的具体应用" class="headerlink" title="2.1 AutoreleasePool的具体应用"></a>2.1 AutoreleasePool的具体应用</h5><p>AutoreleasePool对池中的每个对象执行一次release操作，假设该对象的引用计数为1，表示其从末被使用，则执行release操作后引用计数为0，对象被释放。创建一个不被用使用的Node，示例如下：</p>
<pre><code>auto node = new Node();    // 引用计数为1
node-&gt;autorelease();       // 加入智能指针池
</code></pre><p>在该帧结束之前被使用：</p>
<pre><code>auto node = new Node();    // 引用计数为1
node-&gt;autorelease();       // 加入智能指针池
addChild(node);            // 引用计数为2
</code></pre><h3 id="3-PoolManager"><a href="#3-PoolManager" class="headerlink" title="3.PoolManager"></a>3.PoolManager</h3><h5 id="3-1-PoolManager"><a href="#3-1-PoolManager" class="headerlink" title="3.1 PoolManager"></a>3.1 PoolManager</h5><p>将对象放入自动释放池后，等到特定时期，例如场景销毁、渲染周期结束、程序退出，内存管理者就会遍历其所管理的每一个对象，逐个调用对象的释放函数进行释放。</p>
<p>默认Autorelease一帧被清理一次，但主要是用来清理UI元素的。因为UI元素大部分都是添加到UI树中的，会一直占用内存，所以这种情况每帧清理并不会对内存占用有太大影响。</p>
<p>但对于一些其他的游戏对象，一帧的生命周期则有些长。假设一帧中会调用100个方法，每个方法创建10个autorelease对象，并且这些对象只在每个方法的作用内使用，则当该帧结束的时候则有1000个对象占用内存，使得内存占用量大大增加。</p>
<p>显然，我们需要能够自定义AutoreleasePool的生命周期。</p>
<p>Cocos2d-x中通过实现一个AutoreleasePool队列来实现智能指针生命周期的自定义，并由PoolManager来管理这个队列。</p>
<pre><code>class CC_DLL PoolManager
{
public:
    static PoolManager* getInstance();
    static void destroyInstance();

    AutoreleasePool *getCurrentPool() const;
    bool isObjectInPools(Ref* obj) const;

    friend class AutoreleasePool;

private:
    PoolManager();
    ~PoolManger();

    void push(AutoreleasePool *pool);
    void pop();

    static PoolManager* s_singleInstance;

    std::deque&lt;AutoreleasePool*&gt; _releasePoolStack;
    AutoreleasePool *_curReleasePool;
}
</code></pre><h5 id="3-2-自动释放池的管理"><a href="#3-2-自动释放池的管理" class="headerlink" title="3.2 自动释放池的管理"></a>3.2 自动释放池的管理</h5><pre><code>// 压入自动释放池
void PoolManager::push(AutoreleasePool *pool)
{
    _releasePoolStack.push_back(pool);
}

// 弹出自动释放池对象
void PoolManager::pop()
{
    CC_ASSERT(!_releasePoolStack.empty());
    releasePoolStack.pop_back();
}

// 引擎内部可以存在多个自动释放池对象的。
// 自动释放池对象调用释放函数clear()时，就会将池内的对象全部释放出去。
// 引擎中的第一个自动释放池是在Director构造函数中创建的。
</code></pre><h3 id="4-自定义AutoreleasePool的生命周期"><a href="#4-自定义AutoreleasePool的生命周期" class="headerlink" title="4.自定义AutoreleasePool的生命周期"></a>4.自定义AutoreleasePool的生命周期</h3><p>PoolManager初始化至少有一个AutoreleasePool，主要用来存储UI对象，我们可以创建自己的Autorelease对象。</p>
<p>如果使用New来创建，则要手动释放，为了达到和智能指针用自动变量来管理内存相同的效果，Cocos2d-x对AutoreleasePool的构造各析构函数作了特殊处理， 使得我们可以通过自动变量来管理内存的释放。</p>
<p>Autorelease在构造函数中将自身指针添加到PoolManager的AutoreleasePool队列中，并在析构函数中从队列中移除自己。</p>
<pre><code>AutoreleasePool::AutoreleasePool():_name(&quot;&quot;)
{
    _managerdObjectArray.reverse(150);
    PoolManager::getInstance()-&gt;push(this);
}

AutoreleasePool::AutoreleasePool(const std::string &amp;name):_name(name)
{
    _managerdObjectArray.reserve(150);
    PoolManager::getInstance()-&gt;push(this);
}

AutoreleasePool::~AutoreleasePool()
{
    clear();
    PoolManager::getInstance()-&gt;pop();
}
</code></pre><p>前面讲到Ref::aurorelease()始终将自己添加到当前AutoreleasePool对象中，只要当前AutoreleasePool始终为队列尾端的元素，声明一个AutoreleasePool中，声明一个AutoreleasePool对象就可以影响之后的对象，直到该AutoreleasePool对象可以影响之后的对象，直到该AutoreleasePool对象被移除队列为止。</p>
<pre><code>Class MyClass : public Ref
{
    static MyClass* create()
    {
        auto ref = new MyClass();
        return ref-&gt;autorelease();
    }
}

void customAutoreleasePool()
{
    AutoreleasePool pool;
    auto ref1 = MyClass::create();
    auto ref2 = MyClass::create();
}

// 声明一个AutoreleasePool类型的自动变量pool,其构造函数会将其加入PoolManager的AutoreleasePool队列的尾端。接下来，ref1和ref2都会被添加到pool池中。该方法结束的时候，自动变量pool的生命周期结束，其析构函数将其释放，并从队列中移除自己。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/1.2 自动释放池/" data-id="cjov31riu001z88rid6p3981g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/1.1 引用计数Ref" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/1.1 引用计数Ref/" class="article-date">
  <time datetime="2018-11-24T03:37:30.640Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/1.1 引用计数Ref/">1. 内存管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在对象内部增加一个计数器，当外资引用增加时，计数器就加一。当外部引用消失时，其计数器就减一。</p>
<p>Cocos2D-X中任何对象都可以使用引用计数的方式。这主要因为Ref提供了基本引用计数功能。</p>
<p>Ref是抽象类（包含纯虚函数的类，只能用于被继承不能直接创建对象的类）。</p>
<ul>
<li>Ref构造函数是protected保护类型，不能被实例化（即new），只能被继承使用。</li>
<li>Ref的实现,在构造函数的列表中将他的成员_referenceCount初始化为1了。</li>
</ul>
<p>###1 类Ref的声明代码</p>
<pre><code>class CC_DLL Ref
{
public:
    // 对象id标识
    unsigned int _ID;
    // Lua脚本的id
    int _luaID;

private:
    // 引用计数
    unsigned int _referenceCount;

public:
    Ref(void);
    virtual ~Ref(void);
    // 引用释放
    void release(void);
    // 增加引用
    void retain(void);
    // 自动释放
    Ref* autoRelease(void);
    // 返回计数器的数字
    unsigned int getReferenceCount(void);
}
</code></pre><h3 id="2-引用计数的实现"><a href="#2-引用计数的实现" class="headerlink" title="2 引用计数的实现"></a>2 引用计数的实现</h3><p>#####2.1 引用计数的实现函数</p>
<pre><code>Ref::Ref(void):_referenceCount(1)
{
    #if CC_ENABLE_SCRIPT_BINDING
        static unsigned int uObjectCount = 0;
        _luaId = 0;
        _ID = ++uObjectCount;
        _scriptObject = nullptr;
    #endif

    #if CC_REF_LEAK_DETECTION
        trackRef(this);
    # endif
}

// 释放对象
void Ref::release(void)
{
    CCASSERT(_referenceCount &gt; 0, &quot;reference count should greater than 0&quot;)

    -- _referenceCount;

    if (_referenceCount == 0)
    {
    #if defined(COCOS2D_DEBIG) &amp;&amp; (COCOS2D_DEBUG &gt; 0)
        auto poolManager = PoolManager::getInstance();
        if (!poolManager-&gt;getCurrentPool()-&gt;isClearing() &amp;&amp; poolManager-&gt;isObjectInpools(this))
        {
            CCASSERT(false, &quot;The reference should not be 0 because it is still in autorelease&quot;)
        }
    #endif

    #if CC_REF_LEAK_DETECTION
        untrackRef(this);
    #endif

        delete this;
    }
}

// 增加引用
void Ref::retain(void)
{
    CCASSERT(_referenceCount &gt; 0, &quot;referece count should greater than 0&quot;);
    ++ _referenceCount;
}
</code></pre><p>#####2.2 引用计数的三条原则</p>
<p>（1）有开始就要有结束。当在程序创建一个对象，就一定要释放它。通常创建对象的方式有两种new和copy,在对象不再使用的时候一定要用release()来释放。</p>
<p>（2）有引用就要有释放。当代码调用了对象的retain函数后，引用计数就会加一，所以当对象不再引用之时，调用release来释放。</p>
<p>（3）参数传递要更替引用。当对象指针作为参数来传递时，在函数内有需要引用对象，则此时首先需要释放旧的引用对象，则此时首先需要释放旧的引用对象，然后再增加新的引用对象。具体代码如下：</p>
<pre><code>void Node::setGrid(GridBase* pGrid)
{
    CC_SAFE_RELEASE(_nodeGrid);
    CC_SAFE_RETAIN(grid);
    _nodeGrid = grid;
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/1.1 引用计数Ref/" data-id="cjov31rik001n88ri7hyl2qo9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/1 内存管理" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/1 内存管理/" class="article-date">
  <time datetime="2018-11-24T03:37:30.634Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/1 内存管理/">1. 内存管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>C++中，动态内存分配是一把双刃剑，一方面直接访问内存提高了应用程序的性能及内存使用的灵活性;另一方面，由于没有正确的分配与释放内存造成的野指针、重复释放、内存泄露又严重影响着应用程序的稳定性。</p>
<p>人们尝试用智能指针、自动垃圾回发等进行C++内存管理，但这些要么影响了应用程序的性能，要么仍然需要开发者注意一些规则。</p>
<p>因为优秀的C++内存管理方案需要兼顾性能和易用性，到目前为此C++标准中都没有给出真正的内存管理方案。</p>
<h3 id="1-C-显式堆内存管理"><a href="#1-C-显式堆内存管理" class="headerlink" title="1.C++显式堆内存管理"></a>1.C++显式堆内存管理</h3><p>C++使用new关键字时在运行时给对象动态分配内存，并返回堆上内存的地址供程序访问，当对象不再使用时delete运算符将内存释放。</p>
<p>不能正确处理堆内存的分配与释放通常会导致以下问题：</p>
<p>1）.野指针。指针指向的内存单元已经释放，但是其他的指针还可能指向它，这些内存很可能已经重新分配给其他对象，从而导致无法取得正确的结果。</p>
<p>2）.重复释放。释放一个已经被释放的内存单元，或者释放一个野指针。</p>
<p>3）.内存泄露。不再使用的内存单元没有被释放，导致内存占用不断增加。</p>
<h3 id="2-智能指针"><a href="#2-智能指针" class="headerlink" title="2.智能指针"></a>2.智能指针</h3><p>C++有三种管理内存方式，自动存储、静态存储、动态存储。</p>
<p>1).静态存储用于存储一些在整个应用程序执行期间都存在的静态变量。</p>
<p>2).动态存储用于存储通过new分配的内存单元。</p>
<p>3).自动存储用于函数内部自定义的常规变量。自动变量在函数被调用时自动产生，在函数结束时消亡。</p>
<p>由于自动变量不会导致内存问题，所以智能指针试图通过将一个动态分配的内存与一个自动变量相关联，让这个自动变量自动释放的时候释放其所管理指针的内存单元，这使不再需要显式地调用delete运算符就可以很好地管理动态分配内存。</p>
<h5 id="2-1-智能指针"><a href="#2-1-智能指针" class="headerlink" title="2.1 智能指针"></a>2.1 智能指针</h5><p>C++使用三种不同的智能指针，分别是unique_ptr、shared_ptr、weak_ptr都属于模板类型。</p>
<pre><code>int main
{
    unique_ptr&lt;int&gt; up1(new int(11));
    unique_ptr&lt;int&gt; upll = upl;    // 编译报错

    shared_ptr&lt;int&gt; up2(new int(22));
    weak_ptr&lt;int&gt; up3 = up2;
}

(1)unique_ptr：不能与其他指针共享所指对象的内存。如将up1赋给up11将导致编译错误。可以通过标准库的move函数来转移unique_ptr指针对象的所有权。

(2)shared_ptr：可以共享同一堆分配对象的内存，采用引用计数，只有归零时，才会释放所占的所有的堆内存。

(3)weak_ptr：用来指向shared_ptr指针分配的对象内存，但不拥有该内存。
</code></pre><h5 id="2-2-为什么不使用智能指针？"><a href="#2-2-为什么不使用智能指针？" class="headerlink" title="2.2 为什么不使用智能指针？"></a>2.2 为什么不使用智能指针？</h5><p>shared_ptr是一个完美有内存管理方案，实际上至少有两个原因使Cocos2d-x不应该使用智能指针。</p>
<p>1).较大的性能损耗。 shared_ptr为了保证线程安全，必须使用一定形式的互斥锁来保证所有线程访问时其引用计数正确。</p>
<p>2).仍然需要显式的声明智能指针。另外，在需要引用的地方，一般使用weak_ptr指针的引用 ，示例如下：</p>
<pre><code>weak_ptr&lt;Node*&gt; refNode = node;
</code></pre><h3 id="3-垃圾回发"><a href="#3-垃圾回发" class="headerlink" title="3.垃圾回发"></a>3.垃圾回发</h3><p>垃圾回收主要有如下两种方式：</p>
<p>1）基于引用计数</p>
<p>当对象引用计数变为零时，该对象会被视作垃圾而被回收。</p>
<p>2）基于跟踪处理</p>
<p>先产生跟踪对象的关系图，再进行垃圾回收。</p>
<h3 id="4-智能指针的变体——Cocos内存管理"><a href="#4-智能指针的变体——Cocos内存管理" class="headerlink" title="4.智能指针的变体——Cocos内存管理"></a>4.智能指针的变体——Cocos内存管理</h3><p>Cocos2d-x内存管理机制可以看成基于智能指针的一个变体，但它同时使程序可以像使用垃圾回收机制那样不需要声明智能指针。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/1 内存管理/" data-id="cjov31riq001s88ri8aqnp78y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-C++/11.1粒子的属性" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-C++/11.1粒子的属性/" class="article-date">
  <time datetime="2018-11-24T03:37:30.630Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-C++/11.1粒子的属性/">11.1 粒子的属性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="粒子属性"><a href="#粒子属性" class="headerlink" title="粒子属性"></a>粒子属性</h1><h3 id="1-粒子的属性"><a href="#1-粒子的属性" class="headerlink" title="1.粒子的属性"></a>1.粒子的属性</h3><pre><code>// 粒子结构体的定义，包含了所有粒子属性

// 位置属性
Vec2 pos;

// 开始位置
Vec2 startPos;

// 颜色属性
Color4F color;

// 颜色紊乱值
Color4F deltaColor;

// 尺寸属性
float size;

// 尺寸紊乱值
float deltaSize;

// 旋转属性
float rotation;

// 旋转紊乱值
float deltaRotation;

// 生存时间
float timeToLive;

// 纹理序号
unsigned int atlasIndex;

// 重力属性：方向、角加速度、线加速度
struct{
    Vec2 dir;
    float radialAccel;
    float degreesPerSecond;
} madeA;

// 半径属性：角度、加速度、半径、半径紊乱值
struct{
    float angle;
    float degreesPerSecond;
    float radius;
    float deltaRadius;
} modeB;
</code></pre><h3 id="2-粒子发射器的属性"><a href="#2-粒子发射器的属性" class="headerlink" title="2.粒子发射器的属性"></a>2.粒子发射器的属性</h3><p>Cocos2d-X引擎中存在重力模式、半径模式两种类型的粒子发射器，它们具有一些公共的属性，同时也有一些特殊的属性。</p>
<p>#####2.1 公共属性</p>
<pre><code>// 发射器是否在激活状态
bool _isActive;

// 粒子数目
int _particleCount;

// 发射器的运行时间
float _duration;

// 发射器的源位置
Vec2 _sourcePosition;

// 源位置的紊乱值
Vec2 _posVar;

// 发射粒子的生命时间
float _life;

// 生命时间的紊乱值
float _lifeVar;

// 发射粒子角度
float _angle;

// 角度的紊乱值
float _angleVar;

// 发射粒子开始尺寸
float _startSize;

// 开始尺寸的紊乱值
float _startSizeVar;

// 发射粒子的结束尺寸
float _endSize;

// 结束尺寸的紊乱值
float _endSizeVar;

// 发射粒子开始颜色
Color4F _startColor;

// 开始颜色的紊乱值
Color4F _startColorVar;

// 发射粒子结束颜色
Color4F _endColor;

// 结束颜色的紊乱值
Color4F _endColorVar;

// 发射粒子的初始化角度
float _startSpin;

// 初始化角度的紊乱值
float _startSpinVar;

// 发射粒子的结束角度
float _endSpin;

// 结束角度紊乱值
float _endSpinVar;

// 发射频率
float _emissionRate;

// 粒子系统中最大粒子数
float _totalParticles;

// 发射粒子的纹理
Texture2D *_texture;

// 纹理的混合方式
BlendFunc _blendFunc;

// 是否修改透明度
bool _opacityModityRGB;
</code></pre><p>#####2.2 粒子位置</p>
<p>1) 点控制</p>
<pre><code>// 发射器位置
ParticleSystemQuad* m_emitter = new ParticleSystemQuad();
Size winSize = Director::getInstance()-&gt;getWinSize()
m_emitter-&gt;setPosition(Vec2(winSize.width/2, 60))
m_emitter-&gt;m_tPosVar = Vec2(0, 0);
</code></pre><p>2）线控制</p>
<pre><code>// 发射器位置
ParticleSystemQuad* m_emitter = new ParticleSystemQuad();
Size winSize = Director::getInstance()-&gt;getWinSize()
m_emitter-&gt;setPosition(Vec2(winSize.width/2, winSize.height + 10))
m_emitter-&gt;m_tPosVar = Vec2(winSize.width/2, 0);
</code></pre><p>3) 面控制</p>
<pre><code>// 发射器位置
ParticleSystemQuad* m_emitter = new ParticleSystemQuad();
Size winSize = Director::getInstance()-&gt;getWinSize()
m_emitter-&gt;setPosition(Vec2(winSize.width/2, winSize.height + 10))
m_emitter-&gt;m_tPosVar = Vec2(40, 20);
</code></pre><p>4) 其他效果</p>
<pre><code>// 控制已发射的粒子不围绕发射器来移动
_positionType = FREE;

// 跟随发射器，但不按照世界坐标来移动
_positionType = RELATIVE;

// 完全按照发射器的移动来计算坐标的
_positionType = GROUPED;
</code></pre><p>#####2.3 粒子颜色</p>
<pre><code>// 设置粒子的颜色属性
Color4F startColor = {0.5f, 0.5f, 0.5f, 1.0f};
particleSystem-&gt;setStartColor(startColor);

Color4F startColorVar = {0.5f, 0.5f, 0.5f, 1.0f};
particleSystem-&gt;setStartColor(startColorVar);

Color4F endColor = {0.1f, 0.1f, 0.1f, 0.2f};
particleSystem-&gt;setStartColor(endColor);

Color4F endColor = {0.5f, 0.5f, 0.5f, 1.0f};
particleSystem-&gt;setStartColor(endColorVar);
</code></pre><p>#####2.4 粒子纹理</p>
<p>粒子的继承关系中，其中包含了一个纹理协议的派生。如果没有纹理，所有粒子效果将是单调的色块。</p>
<pre><code>// 设置粒子的纹理属性
e_mitter-&gt;setTexture(TextureCache::getInstance()-&gt;addImage(&quot;Images/star-grayscale.png&quot;));
</code></pre><p>技巧：粒子系统的纹理图片的使用还有重要一点，就是图片的尺寸最好不要超过64*64,因为贴图的尺寸越小。粒子效果运行越流畅。</p>
<p>#####2.5 粒子混合</p>
<p>“混合”是指一个粒子的像素被显示在屏幕之上所需要经历的计算过程，被经常用于三维图形的渲染中，它表示一种颜色的叠加方式。</p>
<p>粒子发射器的混合属性值是以BlendFunc结构体作为数据的。BlendFunc提供了来源混合模式和目标混合模式，也是OpenGL ES渲染器惯用的一种混合方式。代码如下：</p>
<pre><code>_blendFunc = (BlendFunc){GL_SRC_ALPHA, GL_DST_ALPHA};
// 第一个参数为来源混合因子
// 第二个参数为“混合”的工作方式
</code></pre><p>混合的工作方式是在粒子渲染的时候，将用在粒子中的纹理图片（源图片）中红、绿、蓝各透明度信息与屏幕上已经存在的图片（目标源）颜色信息相混合。</p>
<p>其实际的效果就是，每个粒子将会和他所处的背景以某种方式混合，而blendFunc则决定混合方式，对粒子的视觉效果将会有很大的影响，混合方式如下：</p>
<p>在OpenGL ES渲染器中，会把来源颜色以及透明度和目标颜色以及透明度和目标颜色以及透明度各自取出，并乘以一个系数，这个系数就是上表中列出的属性值，然后将相乘后的数字相加，这样就可以得到新颜色以及透明度。</p>
<p>#####2.6 重力发射器模式（Gravity）</p>
<p>重力模式是产生一个指向发射器的向心力，可以让粒子围绕中心点运动。，运动方向可以远离。开发者需要如下代码才可以设置：</p>
<pre><code>_emitterMode = GRAVITY;
</code></pre><p>重力模式属性：</p>
<pre><code>// 重力模式:策略吸引
struct{
    // 重力值
    Vec2 gravity;

    // 粒子速度
    float speed;

    // 粒子速度紊乱值
    float speedVar;

    // 切线加速度
    float tangentialAccel;

    // 切线加速度紊乱值
    float tangentialAccelVar;

    // 径向加速度
    float radialAccelVar;
} modeA;
</code></pre><p>#####2.7 半径发射器模式</p>
<p>半径发射器模型会让粒子沿一个圆形旋转。</p>
<pre><code>// 半径模式
struct{

    // 开始角度
    float startRadius;

    // 开始角度的紊乱值
    float startRadiusVar;

    // 结束角度
    float endRaidus;

    // 结束角度紊乱值
    float endRadidusVar;

    // 粒子每秒旋转角度
    float rotatePerSecond;

    // 粒子旋转角度的紊乱值
    float rotatePerSecondVar;
} modeB;
</code></pre><p>#####2.7 其他属性</p>
<p>1） 粒子大小</p>
<pre><code>// 设置粒子的尺寸
_startSize = 30.f;
_startSizeVar = 0.0f;
_endSize = START_PADIUS_EQUAL_TO_END_RADIUS;
_endSizeVar = 1.0f;
</code></pre><p>2) 粒子角度</p>
<pre><code>// 设置粒子的角度
m_emitter-&gt;setStartSpin(0);
m_emitter-&gt;setStartSpinVar(0);
m_emitter-&gt;setEndSpin(0);
m_emitter-&gt;setEndSpinVar(2000);
</code></pre><p>3) 粒子生命期</p>
<pre><code>// 粒子的生命
m_emitter-&gt;setLife(3);
m_emitter-&gt;setLifeVar(1);
</code></pre><p>4) 发射速率</p>
<p>5）粒子总数</p>
<p>6）发射器持续时间</p>
<p>7）粒子颜色</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-C++/11.1粒子的属性/" data-id="cjov31rj7002j88rihnd39pgb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Cococs2d与OpenGL-ES/">Cococs2d与OpenGL ES</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos2d-Lua/">Cocos2d-Lua</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos2d与OpenGL-ES/">Cocos2d与OpenGL ES</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cococs2d与OpenGL-ES/">Cococs2d与OpenGL ES</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cocos-Lua/">Cocos-Lua</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lua/">Lua</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Cococs2d与OpenGL-ES/" style="font-size: 12.5px;">Cococs2d与OpenGL ES</a> <a href="/tags/Cocos-C/" style="font-size: 20px;">Cocos-C++</a> <a href="/tags/Cocos-Lua/" style="font-size: 17.5px;">Cocos-Lua</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Lua/" style="font-size: 15px;">Lua</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/3.2 精灵/">3.2 精灵</a>
          </li>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/3.1（2） 纹理压缩及应用/">3.1(2) 纹理压缩及应用</a>
          </li>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/3.1（1） 纹理/">3.1 纹理</a>
          </li>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/3 全新的绘制系统/">全新的绘制系统</a>
          </li>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/2.2 OpenGL ES 着色程序/">OpenGL ES着色程序</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Zenos<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>