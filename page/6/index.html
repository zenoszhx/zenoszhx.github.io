<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>ArrayStars</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="ArrayStars">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="ArrayStars">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ArrayStars">
  
    <link rel="alternate" href="/atom.xml" title="ArrayStars" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ArrayStars</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一些个人的总结，辩证来看，不保证完全正确。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Cocos-Lua/事件分发机制：触摸事件" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-Lua/事件分发机制：触摸事件/" class="article-date">
  <time datetime="2018-11-24T03:29:19.164Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-Lua/">Cocos2d-Lua</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-Lua/事件分发机制：触摸事件/">事件分发机制：触摸事件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#事件分发机制：触摸事件</p>
<p>Cocos2d-x原本的触摸机制存在一些限制，Quick提供了一套自己的触摸视你机制。</p>
<p>###1 显示层级</p>
<p>Cocos2d中的所有胡游戏画面是由五系列的Node、Scene、Layer、Sprite等对象构成，而所有的这些对象都是从Node继承而来。可以将Node称为显示节点构成一棵树。</p>
<p>Node所处垂直位置就是它们显示的层级。</p>
<p>###2 触摸区域</p>
<p>#####2.1 cocos2d的显示区域</p>
<p>Cocos2d-x的2.x版本中，只有Layer对象才能接受触摸事件，而Layer总是响应整个屏幕范围的触摸，这就要求开发者拿到触摸事件后需要再做进一步处理。</p>
<p>#####2.2 Quick的触摸区域</p>
<p>Quick允许任何一个Node接受一个触摸事件，并且触摸事件一开始只会出现在这个Node的触摸区域内，即一个Node和其所有子Node显示内容占据屏幕空间。</p>
<p>###3 单点触摸事件</p>
<p>使用触摸，需要开启Node的触摸功能，然后设置触摸模式为OneByOne：</p>
<pre><code>node:setTouchEnabled(true)

-- 可以不写，默认为单点触摸
node:setTouchMode(cc.TOUCHU_MODE_ONE_BY_ONT)
node:addNodeEventListener(cc.NODE_TOUCH_EVENT, function(event)

    printf(&quot;sprite:%s x, y:%0.2f, %0.2f&quot;, event.name, event.x, event.y)

    if event.name == &quot;begin&quot; then
        -- 手指开始触摸屏幕。在begin状态时如果要继续接该事件的变化，事件的处理函数必须返回true
        return true
    end

end)

--begin:手指开始触摸
--moved：手指在屏幕上移动
--ended：手指离开屏幕
--cancelld：因为其它原因取消触摸操作
</code></pre><p>###4 多点触摸</p>
<pre><code>node:setTouchEnabled(true)
node:setTouchMode(cc.TOUCH_MODE_AT_ONCE)
node:addEventListener(cc.NODE_TOUCH_EVENT, function(event)

    for id, point inpairs(event.points) do
        print(&quot;event[%s]%s = %0.2f, %0.2f&quot;, enent.name, id, point.x, point.y)    
    end

    if(event.name == &quot;began&quot;) then
        return true
    end

end)

-- 多点触摸增加了事件的状态added和removed状态
-- added：开始触摸后，如果有更多的点出现，则出现added状态
-- removed：如果触摸结束前有触摸点出现，出现removed状态。
</code></pre><p>###5 触摸事件吞噬</p>
<p>默认情况下，Node在响应触摸后（begin状态返回true表示要响应触摸），应付阻止事件传递给Node的父对象（更下层的Node），称为触摸事件的吞噬。</p>
<p>setTouchSwallowEnabled()可以改变这个行为，默认为true吞噬事件。如果设置为false，则Node响应事件后，仍然会将事件继续传递给父类。</p>
<p>isTouchSwallowEnabled()可以检查Node的吞噬状态。</p>
<p>###6 禁用事件</p>
<p>对于一个Node</p>
<ul>
<li>setTouchEnabled()是否允许Node响应触摸，默认为false。</li>
<li>isTouchEnabled()可以检查Node是否触摸</li>
</ul>
<p>setTouchNodeEnabled只能阻止这个Node的响应，而不能阻止子Node的响应触摸。setTouchCaptureEnable()同时影响当前Node和所有子Node。</p>
<ul>
<li>setTouchCaptureEnable()是否允许Node捕获触摸，默认为true。</li>
<li>isTouchCaptureEnabled()检查Node是否允许捕获</li>
</ul>
<p>###7 触摸事件的三个阶段</p>
<p>Quick构架中触摸事件分为三个阶段:capturing（捕获）、targeting（触发）、bubbling（冒泡）</p>
<p>#####7.1 捕获(capturing)</p>
<ol>
<li>用户触摸屏幕，产生一个触摸事件。</li>
<li>遍历所有响应触摸的Node，找出显示层级最高，并且触摸区域包含触摸位置的那个Node，即TargetNode。</li>
<li>从TargetNode的根Node上开始检查cc.NODE_TOUCHU_CAPTURE_EVENT事件，任何一个Node返回false都会阻止事件TargetNode上传递。并从步骤1开始查找符合其它条件的Node。</li>
</ol>
<p>#####7.2 触发(targeting)</p>
<ol start="4">
<li>在targetNode上触发事件，如果触发返回结果为false，表示TargetNode不响应该事件，并从捕获步骤一查找其他符合条件的Node.</li>
</ol>
<p>#####7.3 冒泡(bubbling)</p>
<ol start="5">
<li>完成响应事件后，检查TargetNode:isTouchSwallowEnabled()的返回值。如果是true，则取消bubbling阶段。</li>
<li>从TargetNode开始往其所有父Node触发事件，直到某个Node返回false或者事件被吞噬。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-Lua/事件分发机制：触摸事件/" data-id="cjov31rma006r88ri0eja6kar" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-Lua/">Cocos-Lua</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-Lua/事件分发机制" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-Lua/事件分发机制/" class="article-date">
  <time datetime="2018-11-24T03:29:19.161Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-Lua/">Cocos2d-Lua</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-Lua/事件分发机制/">事件分发机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="事件分发机制"><a href="#事件分发机制" class="headerlink" title="事件分发机制"></a>事件分发机制</h1><p>Cocos2d-Lua中的事件分发机制与Cocos2d-X不同，它结合Lua语言特性做改进。</p>
<p>Quick框架的事件按照功能各用途分为：</p>
<ul>
<li>节点事件</li>
<li>帧事件</li>
<li>触摸事件</li>
<li>键盘事件</li>
<li>加速计事件 </li>
</ul>
<h3 id="1-节点事件"><a href="#1-节点事件" class="headerlink" title="1 节点事件"></a>1 节点事件</h3><p>节点事件在一个Node对象进入各退出场景时触发，比如加入一个层或者其它的Node的子类的时候，想在子类进入或者退出时加一些数据清除的工作，可以通过这个事件来操作</p>
<p>就事件本身来讲，叫做场景事件更贴切，介它能被场景及所有子节点所监听</p>
<pre><code>node:addNodeEventListener(cc.NODE_EVENT, function(event)
    print(event.name)
)
</code></pre><p>参数event只有name属性，值如下：</p>
<ul>
<li>enter：加载场景</li>
<li>exit：退出场景</li>
<li>enterTransitionFinish：转场特效结束</li>
<li>exitTransitionStart：转场特效开始</li>
<li>cleanup：场景被完全清理并从内存删除</li>
</ul>
<p>例：把下面代码加入到MainScene的ctor()函数中</p>
<pre><code>local function creatTestScene()
    local scene = display.newScene(name)
    scene:addEventListener(cc.NODE_EVENT, function(event)
        print(name..&quot;---&quot;..event.name)
    end)
end

self:performWithDelay(function()

    lcoal scene1 = createTestScene(&quot;scene1&quot;)
    display.replaceScene(scene1)

    self:performWithDelay(function()

        print(&quot;-----------&quot;)
        local scene2 = createTestScene(&quot;scene2&quot;)
        display.replaceScene(scene2)            

    end, 1.0)

end, 1.0)
</code></pre><p>输出结果如下：</p>
<pre><code>scene1---enter
scene1---enterTransitonFinish
-----------
scene1---exitTransitionStart
scene1---exit
scene1---cleanup
scene2---enter
scene2---enterTransitionFinished
</code></pre><p>如果将测试代码display.replaceScene(scene2)修改为diplay.replaceScene(scene2, “random”, 1.0),事件的顺序会变为:</p>
<pre><code>scene1---enter
scene1---enterTransitionFinish
-----------
scene1---exitTransitionStart
scene2---enter
scene1---exit
scene2---enterTransition
scene1---cleanup
</code></pre><p>造成这种区别的原因就是因为场景切换特效播放期间，会同时渲染两个场景，所以会看到第二个场景enter事件出现后，第一个场景的exit事件才出现。</p>
<p>所以在使用节点事件的时候，不应该假定事件出现的顺序，而应该根据特定事件腰采用特定的处理措施。</p>
<p>通常建议如下：</p>
<ul>
<li>enter：可以做一些场景初始化工作。</li>
<li>exit：如果场景切换使用了特效，可以在这里停止一些动画，避免切换场景的特效导致帧率下降。</li>
<li>cleanup：适合估计一些清理工作</li>
</ul>
<h3 id="2-帧事件"><a href="#2-帧事件" class="headerlink" title="2 帧事件"></a>2 帧事件</h3><p>在cocos2d-x的中，C++可以通过加载updae函数在每帧刷新的时候执行自己想要的操作。Quick中，这种事件被称为帧事件，就是每帧刷新的时候都会执行的事件。例：将下面代码添加到MainScene的ctor()函数中。</p>
<pre><code>local scene = display.newScene()
self:addChild(scene)

-- 注册事件
scene:addNodeEventListener(cc.NODE_ENTER_FRAME, funtion(dt)
    print(dt)
end)

-- 启用帧事件
scene:scheduleUpdate()

-- 0.5秒后停止帧事件
scene:performWithDelay(function()

    -- 禁用帧事件
    scene:unscheduleUpdate()
    print(&quot;STOP&quot;)

    --0.5秒后再次启用帧事件
    scene:performWithDelay(function()

        -- 再次启用帧事件
        scene:scheduleUpdate()

    end, 0.5)

end, 0.5)    
</code></pre><h3 id="3-另立章节（事件分发机制：触摸事件）"><a href="#3-另立章节（事件分发机制：触摸事件）" class="headerlink" title="3 另立章节（事件分发机制：触摸事件）"></a>3 另立章节（事件分发机制：触摸事件）</h3><h3 id="4-键盘事件"><a href="#4-键盘事件" class="headerlink" title="4 键盘事件"></a>4 键盘事件</h3><h3 id="5-加速计事件"><a href="#5-加速计事件" class="headerlink" title="5 加速计事件"></a>5 加速计事件</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-Lua/事件分发机制/" data-id="cjov31rme006u88ric0v9unjv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-Lua/">Cocos-Lua</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-Lua/UI" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-Lua/UI/" class="article-date">
  <time datetime="2018-11-24T03:29:19.156Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-Lua/">Cocos2d-Lua</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-Lua/UI/">UI</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h1><p>align和valign参数可用的值：</p>
<ul>
<li>cc.TEXT_ALIGNMENT_LEFT 左对齐</li>
<li>cc.TEXT_ALIGNMENT_CENTER 水平剧中对齐</li>
<li>cc.TEXT_ALIGNMENT_RIGHT 左对齐</li>
<li>cc.VERTICAL_TEXT_ALIGNMENT_TOP 垂直顶部对齐</li>
<li>cc.VERTICAL_TEXT_ALIGNMENT_CENTER 垂直居中对齐</li>
<li>cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM 垂直底部对齐</li>
</ul>
<h3 id="1-文本标签"><a href="#1-文本标签" class="headerlink" title="1 文本标签"></a>1 文本标签</h3><h5 id="1-1-TTF"><a href="#1-1-TTF" class="headerlink" title="1.1 TTF"></a>1.1 TTF</h5><p>字体库规范</p>
<p>创建方式：</p>
<pre><code>display.newTTFLabel(parames)
</code></pre><p>属性：</p>
<ul>
<li>text：显示文本</li>
<li>font：字体名</li>
<li>size：字体大小</li>
<li>color：文字颜色</li>
<li>align：水平对齐方式</li>
<li>valign：垂直对齐方式</li>
<li>dimensions：文字显示对象的尺寸（可选）。用cc.size创建</li>
<li>x</li>
<li>y</li>
</ul>
<p>例：</p>
<pre><code>-- 左对齐，并且多行文字顶部对齐
local label = display.newTTFLabel({
    text = &quot;Hello World\n 您好世界&quot;,
    font = &quot;Markr Felt&quot;,
    size = 64,
    color = cc.c3b(255, 0, 0),
    align = cc.TEXT_ALGNMENT_CENTER,
    valign = cc.VERTICAL_TEXT_ALIGNMENT_TOP,
    dimensions = cc.size(400, 200)
})
</code></pre><h5 id="1-2-BMFont"><a href="#1-2-BMFont" class="headerlink" title="1.2 BMFont"></a>1.2 BMFont</h5><p>适用于频繁更新的场合，需要使用图片来创建字体。</p>
<p>使用前需要添加.png和一个字体坐标文件.fnt。</p>
<p>通常用来显示英文、数字等数量有限的文本。</p>
<p>创建方式：</p>
<pre><code>display.newBMFontLabel(params)
</code></pre><p>参数：</p>
<ul>
<li>text</li>
<li>font：字体的文件名</li>
<li>align：</li>
<li>maxLineWidth:最大行宽</li>
<li>offsetX：图像的X的偏移量</li>
<li>offsetY：图像Y的偏移量</li>
<li>x</li>
<li>y</li>
</ul>
<p>例:</p>
<pre><code>local labelbmf = display.newBMFontLabel({
    text = &quot;Hello&quot;,
    font = &quot;helvetica-32.fnt&quot;
})
</code></pre><h5 id="1-3-UILabel"><a href="#1-3-UILabel" class="headerlink" title="1.3 UILabel"></a>1.3 UILabel</h5><p>创建方式：</p>
<pre><code>cc.ui.UILabel.new({UILabelType = 2, text = &quot;Hello, World&quot;, size = 64})
    :algn(display.CENTER, display.cx, display.cy)
    :addTo(self)
</code></pre><p>参数：和TTFLabel与BMFontLabel相同。</p>
<h3 id="2-按钮"><a href="#2-按钮" class="headerlink" title="2 按钮"></a>2 按钮</h3><p>三个表现按钮仅是表现形式不一样，但内在的事件行为都继承自UIButton，可监听的事件如下：</p>
<ul>
<li>CLICKED，单击。UIButton:onButtonClicked(callback)监听</li>
<li>PRESSED，按下。UIButton:onButtonPressed(callback)监听</li>
<li>PELEASE，释放。UIButton:onButtonRelease(callback)监听</li>
<li>STATE_CHANGED，状态改变。UIButton:onButtonStateChange(callback)监听</li>
</ul>
<h5 id="2-1-UIPushButton"><a href="#2-1-UIPushButton" class="headerlink" title="2.1 UIPushButton"></a>2.1 UIPushButton</h5><p>创建方式：</p>
<pre><code>cc.ui.UIPushButton.new(images, options)
-- images：table类型。各个状态的图片。
-- options：table类型。可选参数，scale9, flipX,flipY
</code></pre><p>例：</p>
<pre><code>function MainScene:ctor()

    local images = {
        normal = &quot;button/Buttono1.png&quot;
        pressed = &quot;button/Buttono2.png&quot;
        disabled = &quot;button/Buttono3.png&quot;
    }    

    cc.ui.UIPushButton.new(images, {scale9 = true})
        :setButtonSize(240, 60),
        :setButtonLabel(&quot;normal&quot;, cc.ui.UILabel.new({
            UILabelType = 2,
            text = &quot;This is a PushButton&quot;,
            size = 18
        }))
        :setButtonLabel(&quot;pressed&quot;, cc.ui.UILabel.new({
            UILabelType = 2,
            text = &quot;This is a PushButton&quot;,
            size = 18
        }))
        :setButtonLabel(&quot;disabled&quot;, cc.ui.UILabel.new({
            UILabelType = 2,
            text = &quot;This is a PushButton&quot;,
            size = 18
        }))
        :onButtonClicked(function(event) 
            print(&quot;pushButton click&quot;)
        end)
        :align(display.LEFT_CENTER, display.left + 80, display.top - 80)
        :addTo(self)

end
</code></pre><h5 id="2-2-UICheckBoxButton"><a href="#2-2-UICheckBoxButton" class="headerlink" title="2.2 UICheckBoxButton"></a>2.2 UICheckBoxButton</h5><p>UICheckBoxButton相当于一个开关，单击按钮在on与off之间切换。创建方式：</p>
<pre><code>cc.ui.UICheckBoxButton.new(images, options)
-- 参数如同UIPushButton
</code></pre><p>例：</p>
<pre><code>function MainScene:ctor()

    local images = {
        off = &quot;button/button1.png&quot;,
        off_pressed = &quot;button/button2.png&quot;,
        off_disabled = &quot;button/button3.png&quot;,
        on = &quot;button/button4.png&quot;,
        on_pressed = &quot;button/button5.png&quot;,
        on_disabled = &quot;button/button6.png&quot;
    }

    local function updateCheckBoxButtonLabel(checkbox)
        local state = &quot;&quot;
        if checkbox:isButtonSelected() then
            state = &quot;on&quot;
        else
            state = &quot;off&quot;
        end
        if not checkbox:isButtonEnabled() then
            state = state..&quot;(disabled)&quot;
        end
        checkbox:setButtonLabelString(string.format(&quot;state is %s&quot;, state))
    end

    local checkBoxButton = cc.ui.UICheckBoxButton.new(image)
        :setButtonLabel(cc.ui.UILabel.new({text = &quot;&quot;, size = 22, color = cc.c3b(255, 96, 255)}))
        :setButtonLabelOffset(0, -40)
        :setButtonLabelAlignment(display.CENTER)
        :onButtonStateChange(function(event)
            updateCheckBoxButtonLabel(event.target) 
        end)
        :align(display.LEFT_CENTER, display.left + 40, display.top - 180) --设置锚点和位置
        ：addTo(self)

    updateCheckBoxButtonLabel(checkBoxButton1)

end
</code></pre><h5 id="2-3-UICheckBoxButtonGroup"><a href="#2-3-UICheckBoxButtonGroup" class="headerlink" title="2.3 UICheckBoxButtonGroup"></a>2.3 UICheckBoxButtonGroup</h5><p>UICheckBoxButtonGroup用来创建一组选项，一个时刻只有一项能被选中。创建方式：</p>
<pre><code>cc.ui.UICheckBoxButtonGroup.new(direction)
--direction,integer类型，可选值：
--display.LEFT_TO_RIGHT
--display.RIGHT_TO_LEFT
--display.TOP_TO_BOTTOM
--display.BOTTOM_TO_TOP

function MainScene:ctor()

    local images = {
        off = &quot;button/button1.png&quot;,
        off_pressed = &quot;button/button1.png&quot;,
        off_disabled = &quot;button/button1.png&quot;,
        on = &quot;button/button1.png&quot;,
        on_pressed = &quot;button/button1.png&quot;,
        on_disabled = &quot;button/button1.png&quot;,
    }

    local group = cc.ui.UICheckBoxButtonGroup.new(display.TOP_TO_BOTTOM)
        :addButton(cc.ui.UICheckBoxButton.new(images)
            :setButtonLabel(cc.ui.UILabel.new({text = &quot;option 1&quot;, color = display.COLOR_WHITE}))
            :setButtonLabelOffset(20, 0)
            :align(display.LEFT_CENTER))
        :addButton(cc.ui.UICheckBoxButton.new(images)
            :setButtonLabel(cc.ui.UILabel.new({text = &quot;option 2&quot;, color = display.COLOR_WHITE}))
            :setButtonLabelOffset(20, 0)
            :align(display.LEFT_CENTER))
        :addButton(cc.ui.UICheckBoxButton.new(images)
            :setButtonLabel(cc.ui.UILabel.new({text = &quot;option 3&quot;, color = display.COLOR_WHITE}))
            :setButtonLabelOffset(20, 0)
            :align(display.LEFT_CENTER))
        :addButton(cc.ui.UICheckBoxButton.new(images)
            :setButtonLabel(cc.ui.UILabel.new({text = &quot;option 4&quot;, color = display.COLOR_WHITE}))
            :setButtonLabelOffset(20, 0)
            :align(display.LEFT_CENTER))
        :setButtonLayoutMargin(10, 10, 10, 10)
        :onButtonSelectChanged(function(event)
            printf(&quot;-----------&quot;) 
        end)
        :align(display.LEFT_CENTER, diaplay.left + 40, display.top - 440)
        :addTo(self)
end
</code></pre><h3 id="3-输入控件"><a href="#3-输入控件" class="headerlink" title="3 输入控件"></a>3 输入控件</h3><p>#####3.1 创建</p>
<pre><code>cc.ui.UIInput.new(options)
--options可选参数如下：
--image：输入框的图像，可以是图像名或是display.newScale9Sprite()创建的Sprite9Scale对象。
--imagePressed：输入状态时显示的图像
--imageDisabled：禁止输入状态显示的图像
--listener：回调函数，监听输入事件
--size：输入框的尺寸
--x,y
</code></pre><p>#####3.2 获取文本</p>
<pre><code>local text = editbox:getText()
</code></pre><p>#####3.3 设置提示信息</p>
<pre><code>editbox:setPlaceHolder(&quot;请输入密码&quot;)
</code></pre><p>#####3.4 设置显示文本</p>
<pre><code>editbox：setText(“&quot;)
</code></pre><p>#####3.5 监听输入事件</p>
<p>#####3.6 密码输入</p>
<pre><code>editbox:setInputFlag(0)
</code></pre><p>例：</p>
<pre><code>local funciton onEdit(event, editbox)

    if event == &quot;begin&quot; then
        -- 开始输入，Player模拟器上没有这个事件
    elseif event == &quot;changed&quot; then
        -- 内容发生改变
    elseif event == &quot;ended&quot; then
        -- 输入结束
    elseif event == &quot;return&quot; then
        -- 从输入框返回，响应手机上的return按钮
    end

    local editbox = cc.ui.UIInput.new(
        image = &quot;editbox.png&quot;,
        listener = onEdit,
        x = display.width/2,
        y = display.height/2,
        size = cc.size(200, 40)
    )

    self:addChild(editbox)
    editbox:setPlaceHolder(&quot;&quot;)

end
</code></pre><h3 id="4-进度条"><a href="#4-进度条" class="headerlink" title="4 进度条"></a>4 进度条</h3><p>#####4.1 创建</p>
<pre><code>cc.ui.UILoadingBar.new(option)
-- option可选参数如下
-- scale9,boolean类型，表示是否缩放
-- capInsets，cc.rect类型，设置图片的绽放区域，避免缩放导致图片模糊失真。
-- image，string类型，表示进度条的图片
-- viewRect，cc.rect类型，表示显示区域
-- percent，int类型，表示初始化进度
-- direction，方向，默认从左到右。可选有：UILoadingBar.DIRECTION_LEFT_TO_RIGHT,UILoadingBar.DIRECTION_RIGHT_TO_LEFT
</code></pre><p>#####4.2 更新</p>
<pre><code>loadBar:setPercent(percent)
</code></pre><p>例：</p>
<pre><code>local loadBar = cc.ui.UILoadingBar.new({
    scale9 = true,
    capInsets = cc.rect(0, 0, 10, 10),
    image = &quot;loading.png&quot;,
    viewRect = cc.rect(0, 0, 200, 32),
    percent = 30,
    direction = DIRCTION_RIGHT_TO_LEFT
}) 
:addTo(self)
</code></pre><h3 id="5-滑动条"><a href="#5-滑动条" class="headerlink" title="5 滑动条"></a>5 滑动条</h3><p>#####5.1 创建</p>
<pre><code>cc.ui.UISlider.new(direction, images, options)

1.direction，number类型，表示滑动方向
    display.LETF_TO_RIGHT
    diaplay.TOP_TO_BOTTOM

2.images，table类型，可用参数如下：
    bar string类型，滑动条图片路径
    button string类型，滑块图片路径

3.options，table类型，可用参数如下：
    scale9 boolean，图片是否可缩放
    min number，最少的值是0
    max number，最大默认是100
    touchInButton boolean，是否只在触摸在滑动块上时才有效，默认为true。
</code></pre><p>#####5.2 修改滑动条大小</p>
<pre><code>UISlider:setSliderSize(barWidth, batHeight)
</code></pre><p>#####5.3 滑动块位置</p>
<pre><code>UISlider:setSliderValue(value)

UISlider:getSliderValue()
</code></pre><p>#####5.4 事件监听</p>
<ul>
<li><p>PRESSED_EVENT，按下滑动块事件，监听方法如下：</p>
<p>  UISlider:onSliderPressed(function(event) end)</p>
<p>  event.x，event.y触摸点y坐标</p>
</li>
<li><p>PELEASE_EVENT，释放滑动块事件，监听方法如下：</p>
<p>  UISlider:onSliderRelease(function(event) end)</p>
<p>  event.x, event.y，触摸点坐标</p>
</li>
<li><p>STATE_CHANGED_EVENT，状态改变事件，监听方法如下：</p>
<p>  UISlider:onSliderStateChange(function(event) end)</p>
<p>  调用UISlider:setSliderEnabled(enabled)的时候触发这个消息</p>
</li>
<li><p>VALUE_CHANGED_EVENT，值改变事件</p>
<p>  UISlider:onSliderValueChange(function(event) end)</p>
<p>  event.value中存放改变后的值</p>
</li>
</ul>
<p>例：</p>
<pre><code>local images = {
    bar = &quot;slider/SliderBar.png&quot;
    button = &quot;slider/SliderButton.png&quot;
}    

local barHeight = 40
local barWidth = 400
local balueLabel = cc.ui.UILabel.new({text = &quot;&quot;, size = 14, color = display.COLOR_BLACK})
    :align(display.LEFT_CENTER, display.left + barWidth + 60, dispaly.top - 60)
    :addTo(self)

cc.ui.UISlider.new(display.LEFT_TO_RIGHT, images, {scale9 = true})
    :onSliderValueChanged(function(event) 
        valueLabel:setString(string.format(&quot;value = %0.2f&quot;, event.value))
        print(event.name)
    end)
    :onSliderStateChange(function(event)
        print(event.name)
    end)
    :onSliderPressed(function(event)
        print(event.name)
    end)
    :onSliderRelease(function(event)
        print(event.name)
    end)
    :setSliderSize(barWidth, batHeight)
    :setSliderValue(75)
    :align(display.LEFT_CENTER, display.left + 40, display.top - 80)
    :addTo(self)
</code></pre><h3 id="6-滚动视图"><a href="#6-滚动视图" class="headerlink" title="6 滚动视图"></a>6 滚动视图</h3><p>#####6.1 创建</p>
<pre><code>cc.ui.UIScrollView.new(params)
--可选参数如下：
1.direction，可选：
    UIScrollView.DIRECTION_BOTH
    UIScrollView.DIRECTION_VERTICAL
    UIScrollView.DIRECTION_HORIZONTAL
2.viewRect：表示列表控件的显示区域
3.scrollbarImgH:string类型，表示水平方向的滚动条图片资源路径。
4.scrollbarImgV:string类型，表示垂直方向的滚动条图片资源路径。
5.bgColor：c4b类型，表示背景色，nil表示无背景色。
6.bgStarColor：c4b类型，表示渐变背景开始色，nil表示无背景色。
7.bgEndColor：c4b类型，表示渐变背景结束色，nil表示无背景色。
8.bg，string类型，表示背景图片资源路径。
9.bgScale9，boolean类型，表示背景图片是否可缩放。
10.capInsets，rect类型，表示缩放区域。
</code></pre><p>#####6.2 回弹效果</p>
<pre><code>UIScrollView:setBounceable(false)
-- 禁用回弹效果
</code></pre><p>#####6.3 事件监听</p>
<pre><code>UIScrollView:onScroll(function(event)
    print(&quot;ScrollListener:&quot;..event.name)
end)
1.began阶段
2.moved阶段
3.ended阶段
</code></pre><p>例：</p>
<pre><code>local sp = display.newSprite(&quot;scroll/cloud.png&quot;)
sp:pos(display.cx, display.cy)

cc.ui.UIScrollView.new({
    direction = cc.ui.UIScrollView.DIRECTION_BOTH,
    viewRect = {x = 0, y = 0, width = 320, height = 480},
    scrollbarImgH = &quot;scroll/barH.png&quot;,
    scrollbarImaV = &quot;scroll/bar.png&quot;,
    bgColor = cc.c4b(255, 255, 255, 255)
})
:addScrollNode(sp)
:setDirection(cc.ui.UIScrollView.DIRECTION_BOTH)
:onScroll(function(event)
    print(&quot;TestUIScrollViewSene - scrollListener:&quot;..event.name)
end)
:addTo(self)
:pos(display.cx - 160, display.cy - 240)
:setBounceable(false)
</code></pre><h3 id="7-列表"><a href="#7-列表" class="headerlink" title="7 列表"></a>7 列表</h3><p>#####7.1 创建</p>
<pre><code>cc.ui.UIListView.new(params)
可用参数如下：
1.direction，默认为垂直
    UIScrollView.DIRECTION_VERTICAL 垂直
    UIScrollView.DIRECTION_HORIZONTAL 水平
2.alignment content对齐方式，默认为垂直居中
    UIListView.ALIGNMENT_LEFT
    UIListView.ALIGNMENT_RIGHT
    UIListView.ALIGNMENT_VCENTER
    UIListView.ALIGNMENT_TOP
    UIListView.ALIGNMENT_BOTTOM
    UIListView.ALIGNMENT_HCENTER
3.viewRect，表示列表控件的显示区域
4.scrollbarImgH，string类型，表示水平方向的滚动条图片资源路径。
5.scrollbarImgV，string类型，表示水平方向的滚动条图片资源路径。
6.bgColor，c4b类型，背景色。
7.bgStartColor
8.bgEndColor
9.bg，string，表示背景图片资源
10. bgScale9，表示背景图是否可缩放
11. capInsets，rect类型，表示缩放区域
</code></pre><p>#####7.2 创建列表项</p>
<p>可以使用UIlistViewItem的new方法来创建一个表项，但这并不是推荐的方法。UIListView内部封装一个创建表项的成员函数，它针对当前表的属性在item上做了额外的初始化。</p>
<pre><code>local list = cc.ui.UIListView:new(params)
local item = list:newItem(contentNode)
--contentNode：可显示的节点类型
--可不传contentNode，通过item:addContent(contentNode)来设置显示节点
</code></pre><p>UIListViewItem是为UIListView服务的，除了contentNode，它还有重要的功能即约束当前列表的宽高。它提供如下接口：</p>
<ul>
<li>UIListViewItem:setItemSize(w, h, bNoMargin)设置表项的宽高。</li>
<li>UIListViewItem:setMargin(margin)设置表项之间的间隙。margin的默认为：{left = 0, right = 0, top = 0, bottom = 0}</li>
</ul>
<p>例：</p>
<pre><code>在MainScene的ctor方法中加入如下代码：

local function touchListener(event)
    local listView = event.listView
    if &quot;clicked&quot; == event.listView then
        if 3 == event.itemPos then
            listView:removeItem(event.item, true)
        end
    end
end

self.lv = cc.ui.UIListView.new{
    bgColor = cc.c4b(200, 200, 200, 200),
    -- bg = &quot;list/sunset.png&quot;,
    bgScale9 = true,
    viewRect = cc.rect(40, 80, 120, 400),
    direction = cc.ui.UIScrollView.DIRECTION_VERTICAL,
    scrollbarImgV = &quot;list/bar.png&quot;    --滚动条图片
}
    :onTouch(touchListener)
    :addTo(self)

for i = 1, 15 do

    local item = self.lv:newItem()
    local const

    if 2 == i then

        content = cc.ui.UIPushButton.new(&quot;list/GreenButton.png&quot;, {scale9 = true})
            :setButtonSize(120, 40)
            :setButtonLabel(cc.ui.UILabel.new({text = &quot;单击大小改变&quot;}..i, size = 16, color = display.COLOR_BLUE}))
            :onButtonPressed(function(event)
                event.target:getButtonLabel():setColor(display.COLOR_RED)
            end)            
            :onButtonReleased(function(event) 
                event.target:getButtonLabel():setColor(display.COLOR_BLUE)
            end)
            :onButtonClicked(function(event)

                if not self.lv:isItemInViewRect(item) then
                    print(&quot;TestUIListViewScene item not in view rect&quot;)
                    return
                end 
                print(&quot;TestUIListViewScene buttonClick&quot;)
                local _, h = item:getItemSize()

                if 40 = h then
                    item:setItemSize(120, 80)        
                else
                    item:setItemSize(120, 40)
                end                    
            end)

    elseif 3 == i then

        content = cc.ui.UILabel.new({
            text = &quot;单击删除它&quot;..i，
            size = 20,
            align = cc.ui.TEXT_ALIGN_GENTER,
            color = display.COLOR_BLACK
        })

        item:setBg(&quot;list/YellowBlock.png&quot;)

    elseif 4 == i then

        content = cc.ui.UILabel.new({
            text = &quot;有背景图&quot;..i,
            size = 20,
            align = cc.ui.TEXT_ALIGN_CENTER,
            color = display.COLOR_BLACK
        })

        item:setBg(&quot;list/YellowBlock.png&quot;)

    else

        content = cc.ui.UILabel.new({
            text = &quot;item&quot;..i,
            size = 20,
            align = cc.ui.TEXT_ALIGN_CENTER,
            color = display.COLOR_BLACK
        })

    end

    item:addContent(content)
    iten:setItemSize(120, 40)

    self.lv.addItem(item)

end

self.lv:reload()
</code></pre><p>上例展示了4种不同item用法，应用了UIListView的大部分功能。</p>
<p>（1） 列表1的contentNode是一个文本标签，显示当前item的编号。</p>
<p>（2） 列表2的contentNode是一个按钮</p>
<ul>
<li>self.lv:isItemInViewRect(item)列表视图可滚动查看这个接口判断item是否在可视区域内。</li>
<li>item:getItemSize()有两个返回值，item的高和宽</li>
</ul>
<p>（3） 列表3和列表1的区别仅仅在于文字，单击可以删除。实现该功能需要监听ListView的事件。</p>
<pre><code>self.lv:onTouch(function(event) end)
enent.name是事件类型，当它为clicked时，event还据有下面域：
1.item被单击的列表项实体
2.itemPos被单击在表中的位置
3.listView 表实例
4.point包含触摸点x,y的table

listView:removeItem(event.item, true)
第一个参数是被移除的项，第二个参数是是否使用移除动画。
</code></pre><p>（4） 列表4使用新的接口item:setBg(bgName)设置背景图片。</p>
<h3 id="8-分页"><a href="#8-分页" class="headerlink" title="8 分页"></a>8 分页</h3><p>#####8.1 视图</p>
<pre><code>cc.ui.UIPageView(params)
可选参数如下：
1.column，number类型，表示每一页的列数。
2.row，表示每一页的行数
3.columnSpace，表示列之间的间隙
4.rowSpace，表示行之间的间隙
5.viewRect，表示页面控件的显示区域
6.padding，table，表示页面四周的间隙 
    left
    rignt
    top
    bottom
7.bCirc，表示页面是否循环
</code></pre><p>#####8.2 创建项</p>
<p>同ListView一样，推荐使用UIPageView的成员函数来创建分页项。</p>
<pre><code>local page = cc.ui.UIPageViewItem.new();
local item = page.newItem
</code></pre><p>#####8.3 监听</p>
<pre><code>UIPageView:onTouch(function(event) 
    dump(event, &quot;TestUIPageViewScene--evnet&quot;)
end)
</code></pre><p>例：</p>
<pre><code>local funciton touchListener(event)
    dump(event, &quot;TestUIPageViewScene - event&quot;)
end

self.pv = cc.ui.UIPageView.new({
    viewRect = cc.rect(80, 240, 480, 480),
    column = 3,
    row = 3,
    padding = {left = 20, right = 20, top = 20, bottom = 20},
    columnSpace = 10,
    rowSpace = 10,
    bCirc = true
})
    :onTouch(touchListener)
    :addTo(self)

for i = 1, 18 do

    local item = self.pv.newItem()
    local content = cc.LayerColor:create(
        cc.c4b(
            math.random(250),
            math.random(250),
            math.random(250),
            250
        )
    )        

    content:setContentSize = (240, 140)
    content:setTouchEnabled(false)
    item:addChild(content)
    self.pv:addItem(item)
end

self.pv:reload()
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-Lua/UI/" data-id="cjov31rm8006n88rizr3qtbsg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-Lua/">Cocos-Lua</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-Lua/Lua-网络通信" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-Lua/Lua-网络通信/" class="article-date">
  <time datetime="2018-11-24T03:29:19.150Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-Lua/">Cocos2d-Lua</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-Lua/Lua-网络通信/">网络通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#网络通信</p>
<p>Cocos2d-Lua一共提供了以下三个通信模块</p>
<ul>
<li>network，http协议的客户端解决方案</li>
<li>SocketTCP，基于LuaSocket封装的tcp客户端解决方案</li>
<li>WebSocket，WebSocket协议客户端解决方案</li>
</ul>
<h3 id="1-HTTP请求"><a href="#1-HTTP请求" class="headerlink" title="1 HTTP请求"></a>1 HTTP请求</h3><p>Cocos2d-Lua的network模块封装了与网络相关的高层接口，可以方便地检测当前网络连接状态、网络类型、进行http网络请求。</p>
<h5 id="1-1-网络状态"><a href="#1-1-网络状态" class="headerlink" title="1.1 网络状态"></a>1.1 网络状态</h5><ol>
<li>network.isLocalWiFiAvailable()：本地WIFI网络是否可用，返回boolean类型。</li>
<li>network.isInternetConnectionAvailable()：用于检查互联连接是否可用，通常返回3G状态，具体情况和设备、操作系统有关。</li>
<li>network.isHostNameReachable()：用于检查是否可以解析指定的主机，返回boolean类型。</li>
<li><p>network.getInternetConnectionStatus()：返回互联网的状态值</p>
<p> cc.kCCNetworkStatusNotReachable：无法访问互联网<br> cc.kCCNetworkStatusReachableViaWiFi：通过WIFI<br> cc.kCCNetworkStatusReachableViaWAN：通过3G网络</p>
</li>
</ol>
<p>示例：</p>
<pre><code>print(&quot;WiFi status:&quot;..tostring(network.isLocalWiFiAvailable()))

pring(&quot;3G status:&quot;..toString(network.isInternetConnectionAvailable()))

pring(&quot;HomeName:&quot;..tostring(network.isHostNameReachable(&quot;cn.cocos2d-x.org&quot;)))


local netStatus = network.getInternetConnectionStatus()
if netStatus == cc.kCCNetworkStatusNotReachable then

    print(&quot;kCCNetworkStatusNotReachable&quot;)

elseif netStatus == cc.kCCNetworkStatusReachableViaWiFi then

    print(&quot;kCCNetworkStatusReachableViaWiFi&quot;)

elseif netStatus == cc.kCCNetworkStatusReachableViaWAN then

    print(&quot;kCCNetworkStatusReachableViaWAN&quot;)

else 

    print(&quot;Error&quot;)

end
</code></pre><h5 id="1-2-HTTP请求"><a href="#1-2-HTTP请求" class="headerlink" title="1.2 HTTP请求"></a>1.2 HTTP请求</h5><p>Quick中使用下面的接口向服务器发起HTTP请求。</p>
<pre><code>network.createHTTPRequest(callback, url, method)
参数：
1 callback：HTTP请求状态回调函数。一次请求会有多次状态回调。
2 url：请求的网络地址
3 method：GER和POST
</code></pre><p>示例：</p>
<p>GET：用于信息获取</p>
<pre><code>local function onRequestCallback(event)

    local request = event.request

    if event.name == &quot;completed&quot; then

        print(request:getResponseHeadersString())

        local code = request:getResponseStatusCode()
        if code ~= &quot;200&quot; then
            --请求结束，没有返回200响应代码
            print(code)
            return
        end

        --请求成功，显示内容
        print(&quot;response length&quot;..request:getResponseDataLength())
        local response = request:getResponseString()
        print(response)

    elseif event.name == &quot;progress&quot; then

        -- 获取当前进度
        print(&quot;progress&quot;..event.dltotal)

    else

        --请求失败，显示错误代码和错误信息
        print(event.name)
        print(request:getErrorCode(), request:getErrorMessage())
        return

    end

end

local request = network.createHTTPRequest(onRequestCallBack, &quot;http://www.baidu.com&quot;, &quot;GET&quot;)
request:start()
</code></pre><p>POST:用于更新数据</p>
<pre><code>local request = network.createHTTPRequest(onRequestCallback, &quot;http://127.0.0.1:1234/hello&quot;, &quot;POST&quot;)
request:addPOSTValue(&quot;name&quot;, &quot;laoliu&quot;)
request:start()

-- 回调方法和GET一致
-- 如果要传递自定义数据，使用以下接口
request:setPOSTData(&quot;this is&quot;)
</code></pre><h3 id="2-SocketTCP"><a href="#2-SocketTCP" class="headerlink" title="2 SocketTCP"></a>2 SocketTCP</h3><p> Cocos2d-Lua中集成了LuaSocket，但是使用略微复杂。SocketTCP后被Cocos2d-Lua所采纳，SocketTCP充分利用了Cocos2d-Lua中的事件机制。</p>
<h5 id="2-1基本用法"><a href="#2-1基本用法" class="headerlink" title="2.1基本用法"></a>2.1基本用法</h5><pre><code>--加载进内存
SocketTCP = require(&quot;FrameWork.cc.net.SocketTCP&quot;)
local socket = SocketTCP.new(&quot;127.0.0.1&quot;, 1234, false)
    1.参数1：服务器地址
    2.参数2：服务器端口号
    3.参数3：链接失败是否重连
-- 创建连接实例后，向实例中添加状态处理接口，以响应网络状态变化
socket:addEventListener(SockerTCP.EVENT_CONNECTED, onState)
-- 向服务器发送请求包
socket:connect()
</code></pre><h5 id="2-2完整示例"><a href="#2-2完整示例" class="headerlink" title="2.2完整示例"></a>2.2完整示例</h5><pre><code>SocketTCP = require(&quot;Framework.cc.net.SocketTCP&quot;)

local socket = SocketTCP.new(&quot;172.0.0.1&quot;, 1234, false)

local function onStatus(event)

    print(&quot;Socket status: %s&quot;, event.name)

    if event.name == SocketTCP.EVENT_CONNECTED then
        --向服务器发送数据，格式需要用Quick提供的ByteArray来转换
        socket:send(ByteArray.new():writeStirng(&quot;Hello server, i`m SocketTCP&quot;):getPack())
    end

    if event.name == SocketTCP.EVENT_DATA then
        -- 接受到服务器发送的数据保存在event.data中
        print(&quot;Socket Receive data : %s&quot;, event.data)
    end

    if event.name == SocketTCP.EVENT_CLOSE then
        print(&quot;Socket Close&quot;)
    end

    if event.name == SocketTCP.EVENT_CLOSED then
        socket = nil
    end

end

socket:addEventListener(SocketTCP.EVENT_CONNECTED, onState)
socket:addEventListener(SocketTCP.EVENT_CLOSE, onStatus)
socket:addEventListener(SocketTCP.EVENT_CLOSED, onStatus)
socket:addEventListener(SocketTCP.EVENT_CONNECT_FAILURE, onStatus)
socket:addEventListener(SocketTCP.EVENT_DATA, onStatus)

socker:connect()

上述把所有的事件都绑定在onStatus回调函数中，内部通过判断event.name来区分各个事件，也可以分开实现每个事件的回调函
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-Lua/Lua-网络通信/" data-id="cjov31rm3006e88riuwk6fzww" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-Lua/">Cocos-Lua</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-Lua/Lua篇：调度器" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-Lua/Lua篇：调度器/" class="article-date">
  <time datetime="2018-11-24T03:29:19.143Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-Lua/">Cocos2d-Lua</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-Lua/Lua篇：调度器/">调度器、定时器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Lua调度器、定时器"><a href="#Lua调度器、定时器" class="headerlink" title="Lua调度器、定时器"></a>Lua调度器、定时器</h1><p>###1 全局调度器</p>
<p>Cocos2d-Lua框架下默认不加载全局调度器，需要手动加载：</p>
<pre><code>local scheduler = require(cc.PACKAGE_NAME..&quot;.shceduler&quot;)
</code></pre><p>全局调度器模块提供了如下三种调度器：</p>
<ol>
<li>全局高度器：schedulerUpdateGlobal(listener)</li>
<li>全局自定义调度器:schedelerGlobal(listener, interval)</li>
<li>全局延时调度器:performWithDelayGlobal(listener, time)</li>
</ol>
<p>前两个调度器的生命周期需要手动管理，全局延时调度器会在回在回调后自动销毁，但也不是所有情况下都完全可靠，引擎提供了一个注销调度器的接口：scheduler.unscheduleGlobal(handle)</p>
<p>#####1.1 全局帧调试器</p>
<p>每一帧都会触发的高度器。主要用在碰撞检测等每一帧都要计算的地方。<br>全局帧调度器不依赖于任何场景，因此可以在整个游戏场景里实现较为精确的全局计时。例：</p>
<pre><code>local scheduler = require(cc.PACKAGE_NAME..&quot;.scheduler&quot;)

local function onInterval(dt)
    print(&quot;update&quot;)
end

scheduler.schedulerUpdateGlobal(onInterval)
</code></pre><p>#####1.2 全局自定义调度器</p>
<p>全局帧调试器是全局自定义调度器的特例，自定义调度器可以指定调度时间。例:</p>
<pre><code>local scheduler = require(cc.PACKAGE_NAME..&quot;.scheduler&quot;)

local function onInterval(dt)
    print(&quot;custom&quot;)
end

scheduler.scheduleGlobal(onInterval)
</code></pre><p>#####1.3 全局延时调度器</p>
<p>在游戏中的某些场合，只想实现一个单次的延时调用。scheduler.performWithDelayGlobal()会在等待指定的时间后执行一次回调函数，然后自动取消该schdeler。例:</p>
<pre><code>local scheduler = require(cc.PACKAGE_NAME..&quot;.scheduler&quot;)

local function onInterval(dt)
    print(&quot;once&quot;)
end

scheduler.performWithDelayGlobal(onInterval, 0.5)
</code></pre><p>###2.节点调度</p>
<p>调度器是Node提供的方法之一。Node的调度器只能在Node中使用，Node负责管理调度器的生命周期，当Node销毁时会自动注销节点名下的所有调度器。</p>
<p>大部分情况， 我们使用节点调度器，这样我们能把精灵集中在游戏逻辑实现，而不是调度器的生命周期管理。</p>
<p>节点调度器提供了三种调试器:</p>
<ul>
<li>节点帧调度器。（归类到节点帧事件，参考事件分发机制）</li>
<li>节点自定义调度器</li>
<li>节点延时调度器 </li>
</ul>
<p>#####2.1节点自定义调度器</p>
<p>自定义时间间隔必须大于两帧的间隔时间。例:</p>
<pre><code>self:scheduler(function() print(&quot;schedule&quot;)end, 1.0)
</code></pre><p>#####2.2节点延时调度器</p>
<p>等待指定时间后执行一次回调函数。例：</p>
<pre><code>self:performWithDelay(function()print(&quot;performWithDelay&quot;), 1.0)
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-Lua/Lua篇：调度器/" data-id="cjov31rm4006g88riz2nkv1os" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-Lua/">Cocos-Lua</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-Lua/Lua篇：函数和闭包" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-Lua/Lua篇：函数和闭包/" class="article-date">
  <time datetime="2018-11-24T03:29:19.139Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-Lua/">Cocos2d-Lua</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-Lua/Lua篇：函数和闭包/">函数和闭包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h3 id="1、函数定义"><a href="#1、函数定义" class="headerlink" title="1、函数定义"></a>1、函数定义</h3><pre><code>function func()
end
--以function开头、end结尾、必须加()
</code></pre><p>面向对象编程中经常会定义内部方法，在Lua中实现如下：</p>
<pre><code>class = {}    --一个对象

function class.func1()
end

function class:func2()
end

-- 首先定义了一个名为class的table，然后在table上定义了两个函数成员。
func1()和func2()使用了不同的定义方法，：自动传入一个名为self的变量，self同C++的this一样。
</code></pre><h3 id="2、函数参数与返回值"><a href="#2、函数参数与返回值" class="headerlink" title="2、函数参数与返回值"></a>2、函数参数与返回值</h3><h3 id="3、可变参数"><a href="#3、可变参数" class="headerlink" title="3、可变参数"></a>3、可变参数</h3><pre><code>function add(...)
    local s = 0
    for i, v in ipairs{...} do
        s = s + v
    end
    return s
end

print(add 1, 2, 3, 4, 5)--&gt;15
</code></pre><h3 id="4、闭包函数"><a href="#4、闭包函数" class="headerlink" title="4、闭包函数"></a>4、闭包函数</h3><p>闭包函数是指将一个函数写在另一个函数内部，这个内部函数可以访问外部函数中的局部变量。而内部函数一直在使用外部函数的局部变量，从而Lua一直维护外部函数局部变量的生命周期。<br>这个外部函数的局部变量，既不是局部变量，也不是全局变量，称之为外部局部变量或upvalue</p>
<pre><code>function newCounter()
    local i = 0
    return function()
        i = i + 1
        return i
    end
end

c1 = newCounter()

print(c1())--&gt;1
print(c1())--&gt;2
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-Lua/Lua篇：函数和闭包/" data-id="cjov31rmi007088ri0wkghked" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-Lua/">Cocos-Lua</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-Lua/Lua篇（一）：Lua语法速览" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-Lua/Lua篇（一）：Lua语法速览/" class="article-date">
  <time datetime="2018-11-24T03:29:19.132Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-Lua/">Cocos2d-Lua</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-Lua/Lua篇（一）：Lua语法速览/">Lua语法速览</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#Lua篇（一）：Lua语法速览</p>
<p>###1.注释、语句</p>
<p>###2.数据类型</p>
<p>###3.变量</p>
<p>###4.循环、逻辑、判断</p>
<p>###3.函数</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-Lua/Lua篇（一）：Lua语法速览/" data-id="cjov31rm0006c88rilc4f9tbm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-Lua/">Cocos-Lua</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-Lua/Lua篇（三）：面向对象" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-Lua/Lua篇（三）：面向对象/" class="article-date">
  <time datetime="2018-11-24T03:29:19.127Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-Lua/">Cocos2d-Lua</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-Lua/Lua篇（三）：面向对象/">面向对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#面向对象</p>
<h3 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h3><p>了解metatable之后，Lua类的封装就变的容易。只要为table添加metatable，并设置 _ _index元方法。如下例中People的new方法。</p>
<pre><code>Prople = {age = 18}
function People.new()
    local p = {}
    setmetatable(p, self)
    self.__index = self
    return p
end

function People:growUp()
    self.age = self.age + 1
    print(self.age)
end

--测试
p1 = People.new()
p1:growUp() --&gt; 19
p2 = People.new()
p2:growUp() --&gt; 19
</code></pre><p>从运行结果可以看出，两个对象拥有独立的age成员，而且所有有关People的方法都可以对外不可见，这样完全实现了面向对象中类的封装。</p>
<h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h3><p>依然使用上面People，展示Lua实现继承的方法。创建一个Pwo实例Man,再在Main上重写PeoPle同名方法。</p>
<pre><code>Man = People:new()
function Man:growUp()
    self.age = self.age + 1
    print(&quot;man`s growUp&quot;..self.age)
end

--测试
man1 = Man.new()
man1.growUp()    --&gt;man`s growUp:19
</code></pre><p>结果说明Man成功重写了growUp方法，并能使用People定义的age成员。实现了继承的基本方法。</p>
<h3 id="3-多态"><a href="#3-多态" class="headerlink" title="3.多态"></a>3.多态</h3><p>Lua不支持函数多态，而指针的多态由于Lua动态类型的特性，本身就能支持。</p>
<pre><code>person = People.new()
person:growUp()
person = Man.new()
person:growUp()

----&gt; People`s growUp:19
----&gt; Man`s growUp:19
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-Lua/Lua篇（三）：面向对象/" data-id="cjov31rm6006k88rimwljji06" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-Lua/">Cocos-Lua</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-Lua/Lua篇（二）：神奇的表" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-Lua/Lua篇（二）：神奇的表/" class="article-date">
  <time datetime="2018-11-24T03:29:19.123Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-Lua/">Cocos2d-Lua</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-Lua/Lua篇（二）：神奇的表/">神奇的表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="神奇的表"><a href="#神奇的表" class="headerlink" title="神奇的表"></a>神奇的表</h1><h3 id="1、table构造式"><a href="#1、table构造式" class="headerlink" title="1、table构造式"></a>1、table构造式</h3><p>（1）构造一个table的时候，如果不给key，则key默认从1开始。如要声明一个有关星期的table：</p>
<pre><code>t = {&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;...}
--这样一个table构造应该如下
t = {}
t[1] = &quot;Sunday&quot;
t[2] == &quot;Monday&quot;
</code></pre><p>（2）使用混合的方式给table赋值，未设置key的项，key会自动从1开始编号。</p>
<p>（3）删除一个table时直接给他赋值为nil就可以了。</p>
<h3 id="2-元表"><a href="#2-元表" class="headerlink" title="2.元表"></a>2.元表</h3><h5 id="2-1-元表概念"><a href="#2-1-元表概念" class="headerlink" title="2.1 元表概念"></a>2.1 元表概念</h5><p>metatable 是 table预定的一系列操作。比如把两个table相加，那么Lua就会先去检查table是否有metatable，然后检查metatable中是否有add方法。如果有就按照add中的方法来执行，如果没有则报错。</p>
<p>在Lua中的每一个值都有或者可以有一个元表。table和userdata可以拥有独立的元表。其他类型的值只能共享所属类型的元表，比如字符串就是使用的string的元表。</p>
<p>Lua丰创建table的时候是不会创建metatable的，需要使用setmetatable来设置元表。setmetatable的参数可以量任意table，包括要赋值的table本身。</p>
<p>例：实现一个table，能让它实现“+”运算</p>
<pre><code>Set = {}

function Set.new(t)
    local set = {}
    for i, v in ipairs(t) do
        set[v] = true
    end
end

function Set.union(a. b)
    local res = Set.new()
    for k in ipairs(a) do
        res[k] = true
    end
    for k in ipairs(b) do
        res[k] = true
    end
    return res
end

function Set.tostring(st)
    locas s = &quot;{&quot;
    local sep = &quot;&quot;
    for e in pairs(set) do
        s = s .. sep .. e,
        sep = &quot;,&quot;
    end
    return s..&quot;}&quot;
end

function Set.print(2)
    print(Set.tostring(s))
end

--定义metatable
Set.mt = {}
Set.mt.__add = Set.union

s1 = Set.new{10, 20, 30, 50}
s2 = Set.new{30, Set.mt}
s3 = s1 + s2
Set.print(s3)
</code></pre><h5 id="2-2-重要元方法"><a href="#2-2-重要元方法" class="headerlink" title="2.2 重要元方法"></a>2.2 重要元方法</h5><p>table的其他预定义元方法如图：</p>
<p><img src="http://7xqzxs.com1.z0.glb.clouddn.com/Metamethods.png" alt=""></p>
<p>（1）_  _ index元方法<br>Lua中访问table的元素量先通过__index元方法来查找是否有这个函数，如果没有则返回nil。<br>通过改变 _  _index元方法，能够改变检索之后的结果。 _  _index的值可以直接是一个table，也可以是一个函数。若是table，则会以该table作为索引进行查询。若是函数，Lua则将table和缺少的域作为参数调用这个函数。</p>
<pre><code>--改变 _ _ index元方法，用函数来检索
Window = {}
Window.mt = {}
Window.prototype = {x = 0, y = 0, width = 100, height = 100}
Window.mt.__index = function(table, key)
    return Window.prototype[key]
end

function Window.new(t)
    setmetatable(t, Window.mt)
    return t
end    

-- 测试
w = Window.new{x = 10, y = 20}
print(w.height)
--输出100
</code></pre><p>（2）__newindex元方法</p>
<p>_  _ newindex和 _ _ index的使用基本一样。区别在于 _ _ newindex的作用量用于table更新， _ _ index量用于table的查询操作。当table中不存在的索引赋值是，就会调用 _ _ newindex元方法。组合使用 _ _ index和 _ _ newIndex可以实现很多功能。</p>
<pre><code>Window = {}
Window.mt = {}
Window.prototype = {x = 0, y = 0, width = 100, height = 100}
Window.mt.__newindex = function(table, key, value)
    print(&quot;update of element&quot;..tostring(key)..tostring(value))
    rewset(table, key, value)
end

function Window.new(t)
    setmetatable(t, Window.mt)
    return t
end    

-- 测试
w = Window.new{x = 10, y = 20}
w.a = 10
print(w.a)
--输出10
</code></pre><p>（3） _ _ index在get表中未定义元素时触发，对应有rawget(table, key)来避免调用 _ _ index;  _ _ newindex在set表中未定义元素时触发，对应有rawset(table, key)来避免调用 _ _ newindex方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-Lua/Lua篇（二）：神奇的表/" data-id="cjov31rlx006688rihheg2gzm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-Lua/">Cocos-Lua</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-Lua/Lua粒子系统" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-Lua/Lua粒子系统/" class="article-date">
  <time datetime="2018-11-24T03:29:19.118Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-Lua/">Cocos2d-Lua</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-Lua/Lua粒子系统/">粒子系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#粒子系统</p>
<p>###1.Cocos2d-Lua中的粒子系统</p>
<p>#####1.1Cocos2d-Lua粒子系统的基础关系<br>粒子中的基础关系如图所示：<br><img src="http://7xqzxs.com1.z0.glb.clouddn.com/0824Coco2d-Lua%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F.png" alt=""><br>cc.ParticleSystem是粒子的基类，定义了粒子系统的各种基本属性。</p>
<p>#####1.2cc.ParticleSystemQuad<br>cc.ParticleSystemQuad除了具有cc.ParticleSystem的所有属性外还有以下特点：</p>
<ol>
<li>粒子的大小可以是任意的浮点数</li>
<li>系统可缩放</li>
<li>粒子可旋转</li>
<li>支持子区域</li>
<li>支持手批量渲染</li>
</ol>
<p>###2.料子系统批处理节点</p>
<p>###3.粒子属性</p>
<p>###4.粒子编辑器</p>
<p>###5.使用料子系统</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-Lua/Lua粒子系统/" data-id="cjov31rmk007388rid8495mtt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-Lua/">Cocos-Lua</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Cococs2d与OpenGL-ES/">Cococs2d与OpenGL ES</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos2d-Lua/">Cocos2d-Lua</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos2d与OpenGL-ES/">Cocos2d与OpenGL ES</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cococs2d与OpenGL-ES/">Cococs2d与OpenGL ES</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cocos-Lua/">Cocos-Lua</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lua/">Lua</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Cococs2d与OpenGL-ES/" style="font-size: 12.5px;">Cococs2d与OpenGL ES</a> <a href="/tags/Cocos-C/" style="font-size: 20px;">Cocos-C++</a> <a href="/tags/Cocos-Lua/" style="font-size: 17.5px;">Cocos-Lua</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Lua/" style="font-size: 15px;">Lua</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/3.2 精灵/">3.2 精灵</a>
          </li>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/3.1（2） 纹理压缩及应用/">3.1(2) 纹理压缩及应用</a>
          </li>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/3.1（1） 纹理/">3.1 纹理</a>
          </li>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/3 全新的绘制系统/">全新的绘制系统</a>
          </li>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/2.2 OpenGL ES 着色程序/">OpenGL ES着色程序</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Zenos<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>