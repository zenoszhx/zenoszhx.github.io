<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>ArrayStars</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="ArrayStars">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="ArrayStars">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ArrayStars">
  
    <link rel="alternate" href="/atom.xml" title="ArrayStars" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ArrayStars</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一些个人的总结，辩证来看，不保证完全正确。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Cocos-Lua/Cocos2d-Lua引擎架构与目录结构" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-Lua/Cocos2d-Lua引擎架构与目录结构/" class="article-date">
  <time datetime="2018-11-24T03:29:18.830Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-Lua/">Cocos2d-Lua</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-Lua/Cocos2d-Lua引擎架构与目录结构/">Cocos2d-Lua引擎架构与目录结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#Cocos2d-Lua引擎架构与目录结构</p>
<p>###1.引擎架构<br>Cocos2d-Lua是由Cocos2d-x衍生出来的，他们之间的关系如下图所示：<br><img src="http://7xqzxs.com1.z0.glb.clouddn.com/160808Cocos2d-Lua%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84.jpg" alt=""></p>
<ol>
<li>橙色区域的模块与具体平台相关，引擎渲染基于跨平台的OpenGL ES。</li>
<li>OpenGL ES之上是Cocos2d-x引擎架构，Cocos2d-x与ThirdPartLibrary对外暴露C++API</li>
<li>Lua Binding把C++ API映射为Lua API， 而Quick Framework基于Lua API二次封装并拓展了接口</li>
<li>游戏最上层，可以同时使用Lua API和Quick框架</li>
<li>Coco2d-x内部又可以细分为多个模块<br><img src="http://7xqzxs.com1.z0.glb.clouddn.com/160808Cocos2d-x%E6%A8%A1%E5%9D%97.jpg" alt=""></li>
</ol>
<p>###2.引擎文件结构</p>
<h5 id="2-1-引擎根目录"><a href="#2-1-引擎根目录" class="headerlink" title="2.1 引擎根目录"></a>2.1 引擎根目录</h5><p><img src="http://7xqzxs.com1.z0.glb.clouddn.com/0821Quick-Cocos2d-Lua%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt=""></p>
<ol>
<li>build：编译Cocos2d-x库的各平工具</li>
<li>cocos：Cocos2d-x引擎C++代码</li>
<li>docs：Cocos2d-Lua的文档</li>
<li>extension：GUI、物理引擎等扩展模块</li>
<li>external：第三方库</li>
<li>licenses：引擎以及第三方库的说明文件</li>
<li>quick：Quick框架代码</li>
<li>tools：项目生成工具</li>
<li>player3.bate：启动Cocos2d-Lua模拟器的工具</li>
<li>setup_mac.sh：Mac下设置Cocos2d-Lua环境变量的脚本文件</li>
<li>setup_win.bate：Win下设置Cocos2d-Lua环境变量的脚本文件</li>
<li>unins0000.dat、unins.exe：Windwos下引擎卸载程序</li>
</ol>
<h5 id="2-2-Quic框架"><a href="#2-2-Quic框架" class="headerlink" title="2.2 Quic框架"></a>2.2 Quic框架</h5><p><img src="http://7xqzxs.com1.z0.glb.clouddn.com/0821Quick%E6%A1%86%E6%9E%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt=""></p>
<ol>
<li>bin：Quick框架相关可执行脚本</li>
<li>cocos：Cocos2d-Lua binding接口</li>
<li>framework：Quick框架的Lua源码</li>
<li>lib：Quick框架的C++源码</li>
<li>player：模拟器的源码</li>
<li>samples：Quick框架测试案例</li>
<li>templetes：项目创建模板</li>
<li>welcome：项目启动欢迎模板</li>
</ol>
<h5 id="2-3-framework目录结构"><a href="#2-3-framework目录结构" class="headerlink" title="2.3 framework目录结构"></a>2.3 framework目录结构</h5><p><img src="http://7xqzxs.com1.z0.glb.clouddn.com/0821Quick-Framework%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt=""></p>
<ol>
<li>cc:扩展Cocos2d-x Lua API，提供Quick基本模块（符合脚本风格的事件模块、组件架构）</li>
<li>cocos：Quick对Cocos2d-Lua模块的加强</li>
<li>deprected：废弃的接口</li>
<li>plantform：Quick平台相关的接口</li>
<li>anysdkConst.Lua：AnySDK中常量的定义</li>
<li>audio.lua：音乐、音效管理</li>
<li>cocos2dx.lua：用来导入Cocos2d-x Lua API</li>
<li>crypto.lua：加解密、数据编码库</li>
<li>debug.lua：提供调试接口</li>
<li>device.lua：提供设备相关属性的查询以及设备功能的访问</li>
<li>display.lua：与显示图像、场景相关的功能</li>
<li>filter.lua：滤镜功能</li>
<li>function.lua：提供一组常用函数，以及对Lua标准库的拓展</li>
<li>init.lua：quick框架的初始化</li>
<li>json.lua：JSON的编码与解码</li>
<li>luaj.lua：Lua与Java之间的交互接口</li>
<li>luaoc.lua：Lua与Objective-C之间的交互接口</li>
<li>network.lua：网络接口封装。检查WIFI、3G网络接口情况等</li>
<li>schduler.lua：全局计时器、计划任务，该模块在框架初始化时不会自动载入</li>
<li>shortcode.lua：一些经常使用的短代码，比如设置旋转角度。</li>
<li>transition.lua：为动作和驱动对象添加效果。</li>
<li>ui.lua：创建和管理用户界面</li>
</ol>
<p>###3.项目文件结构<br><img src="http://7xqzxs.com1.z0.glb.clouddn.com/0821Cocos2d-Lua%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt=""></p>
<ol>
<li>frameworks：iOS、Android等平台的工程文件。</li>
<li>res：项目资源文件</li>
<li>src：项目源码存放文件夹</li>
<li>.project：Cocos Code IDE项目文件</li>
<li>config.json：项目信息配置文件</li>
<li>debug.log：最后一次log信息存档</li>
</ol>
<p><img src="http://7xqzxs.com1.z0.glb.clouddn.com/0821Cocos2d-Lua%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84-src.png" alt=""></p>
<ol>
<li>app：游戏界面及逻辑<ul>
<li>app/MyApp.lua：游戏实例</li>
<li>app/scenes：游戏场景文件夹</li>
<li>app/scenes/MainScene：游戏的第一个场景</li>
</ul>
</li>
<li>cocos：cocos2d-Lua/quick/cocos的复制，将随项目一起打包</li>
<li>config.lua：工程的配置文件，包括分辨率</li>
<li>main.lua：游戏入口</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-Lua/Cocos2d-Lua引擎架构与目录结构/" data-id="cjov31rlz006988rih91vqrg6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-Lua/">Cocos-Lua</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Cocos-Lua/序列帧动画" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Cocos-Lua/序列帧动画/" class="article-date">
  <time datetime="2018-11-24T03:29:18.828Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-Lua/">Cocos2d-Lua</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Cocos-Lua/序列帧动画/">Lua序列帧动画</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#Lua序列帧动画</p>
<p>Cocos2d序列帧动画只支持精灵表单(SpriteSheet)而不支持离散文件方式创建帧动画,使用起来很方便。</p>
<p>###1.精灵表单</p>
<p>#####1.1什么是精灵表单？</p>
<p>精灵表单由一张存储多个精灵纹理的大图和一个对应的描述文件组成，描述文件记录了每个精灵纹理在大图上的位置区域。</p>
<p>用一张大图来集合精灵的纹理有如下好处</p>
<ol>
<li><p>减少磁盘存储空间。一张大图可以减少图片压缩次数;大图上相邻精灵的纹理像素可以进一步压缩以减少文件体积。</p>
</li>
<li><p>减少内存占用空间。OpenGL ES在加载纹理的时候会对宽高不足2^n的图像进行填充，在一张大图上存储多个纹理将有效减少，内存的占用。</p>
</li>
<li><p>减少CPU开销。加载一个精灵表单能一次性加载多张纹理资源，之后对了纹理的访问都在，内存中进行，避免离散文件的多次加载。同时在图片解压的时候也只需要一次就能完成。在内存内部可以使用批处理指令交互。（批处理指令另外单独介绍）</p>
</li>
</ol>
<h5 id="1-2精灵表单的格式选择"><a href="#1-2精灵表单的格式选择" class="headerlink" title="1.2精灵表单的格式选择"></a>1.2精灵表单的格式选择</h5><p>将图片导入TexturePacker工具。</p>
<ol>
<li><p>选择Data Format，默认是cocos2d，即cocos2d系列所支持的格式。Cocos2d-Lua引擎，选用cocos2d格式。</p>
</li>
<li><p>选择Texture format格式，推荐使用zlib compr.PVR压缩方案。</p>
</li>
<li><p>选择Image format，默认为RGBA8888，最高图像质量，如果需要进一步</p>
</li>
</ol>
<p>###2.播放序列帧动画</p>
<p>#####2.1播放精灵表单序列帧动画的步骤</p>
<ol>
<li><p>将导出的pvr.ccz和stars.plist文件复制到项目的res文件下</p>
</li>
<li><p>从精灵表单批量导入精灵帧到引擎的缓存。Cocos2d-Lua中使用如下方法从指定的SpriteSheet导入精灵帧</p>
<p> display.addSpriteFrame(plistFilename， image, handler)</p>
</li>
<li><p>生成序列帧数组。精灵表单中的精灵帧可以用来做动画，也可以用来显示设置给某个静态精灵，我们需要挑选需要的帧并按照我们的期望播放顺序组成一个序列帧数组。Cocos2d-Lua中使用如下方法：（pattern：string类型，字符串匹配模板;isReversed：是否递增）</p>
<p> display.newFrames(pattern, begin, legth, isReversed)</p>
</li>
<li><p>生成Animation。Animation是一个描述动画的对象。使用如下方法创建：(frame:序列帧数组; time：相邻两帧之间的间隔)</p>
<p> display.newAnimaiton(frame, time)</p>
</li>
<li><p>播放精灵帧动画。Animation对象不能被节点的runAction播放，因为它不是一个Action对象，需要使用cc.Animate:create(animation)来创建一个Animate才可以播放。Animate提供很多灵活性，可以用在复合动作中。如果简单的让一个精灵播放动画，可使用如下方法：</p>
<p> Sprite:playAnimationOnce(animation, removeWhenFinshed, onComplete, delay)</p>
<p> Sprite:playAnimationForever(animation, delay)</p>
</li>
</ol>
<p>#####2.2示例</p>
<pre><code>display.addSpriteFrames(&quot;stars.plist&quot;, &quot;Star.pvr.ccz&quot;)
local frames = display.newFrames(&quot;star%02d.png&quot;, 1, 9)
local animation = display.newAnimation(frames, 0.2)
local animate = cc.Animate:create(animation)

local sprite = display.newSprite(&quot;#star01.png&quot;)
                      :center()
                      :addto(self.backgroundLayer)
                      :runAction(animate)
</code></pre><p>###3.动画缓存</p>
<p>#####3.1缓存动画</p>
<pre><code>display.setAnimationCache(name, animation)
</code></pre><p>#####3.2获取缓存动画</p>
<pre><code>animation = display.getAnimationCache(name)
</code></pre><p>#####3.3删除缓存的动画对象</p>
<pre><code>display.removeAnimationCache(name)
</code></pre><p>#####3.4示例</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Cocos-Lua/序列帧动画/" data-id="cjov31rmh006x88rif2cuv8xx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cocos-Lua/">Cocos-Lua</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Lua/1.7 样例" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Lua/1.7 样例/" class="article-date">
  <time datetime="2018-11-24T03:25:54.409Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Lua/1.7 样例/" data-id="cjov31rgw000488rin5kksuep" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Lua/1.6 Lua脚本引擎" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Lua/1.6 Lua脚本引擎/" class="article-date">
  <time datetime="2018-11-24T03:25:54.408Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-Lua/">Cocos2d-Lua</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Lua/1.6 Lua脚本引擎/">1.5 Lua脚本引擎</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在引擎中提供了两种脚本的支持Lua与JavaScript。</p>
<p>引擎中存在一个Lua脚本引擎，在Cocos2D-X\scripting\lua中，读者将会看到Lua解释器以及tolua++的源代码。在目录cocos2dx_support中源代码文件才是重点。</p>
<h3 id="1-LuaEngin"><a href="#1-LuaEngin" class="headerlink" title="1.LuaEngin"></a>1.LuaEngin</h3><p>此文件为类LuaEngine的实现源代码，就是在Cocos2D-X引擎中的脚本引擎，它也采用了外观模式与管理模式的结合，提供了一些统一函数接口，方便开发者执行Lua脚本。</p>
<pre><code>// 脚本引擎接口协议
class CC_DLL ScriptEngineProtocol
{
public:
    virtual ccScriptType getScriptType() { return kScriptTypeNone;};

    virtual void removeScriptObjectByObject(Ref* obj) = 0;

    virtual void removeScriptHandler (int handler) {};

    virtual int reallocateScriptHandler(int handler){return 0};

    virtual int excuteString(const char* codes) = 0;

    virtual int executeScpripFile(const char* fileName) = 0;

    virtual int executeGlobalFunction(const char* functionName) = 0;

    virtual int sendEvent(ScriptEvent *evt) = 0;

    virtual bool handleAssert(const char *msg) = 0;

    virtual void setCalledFormScript(bool callFormScript){CC_UNUSED_PARAM(callFormScript);};

    virtual void setCalledFormScript() {return false};

    enum class ConfigType
    {
        NONE,
        COCOSTUDIO
    };

    virtual bool parseConfig(ConfigType type, const std::string&amp; str) = 0;
}
</code></pre><h3 id="2-LuaCocos2d"><a href="#2-LuaCocos2d" class="headerlink" title="2.LuaCocos2d"></a>2.LuaCocos2d</h3><p>这是脚本引擎的具体实现代码。在此文件中，几乎所有Cocos2D-X引擎的类都可以找到。由此可见，这个文件的容量也相当庞大，有近4万行的代码。下面展示部分代码：</p>
<p>此文件代码的作用就是建立Cocos2D-X引擎与脚本之间的联系，将引擎中的类、函数、数据类型压入栈，只有这样Lua才能使用引擎各个功能。</p>
<p>示例1：</p>
<pre><code>// 类Speed的函数setSpeed实现
#ifndef TOLUA_DISABLE_tolua_Cocos2d_Speed_setSpeed00

static int tolua_Cocos2d_setSpeed00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE

tolua_Error tolua_err;
if(
    !tolua_isusertype(tolua_S, 1, &quot;Speed&quot;, 0, &amp;tolua_err) ||
    !tolua_isnumber(tolua_S, 2, 0, &amp;tolua_err)||
    !tolua_isnoobj(tolua_S, 3, &amp;tolua_err)
)
goto tolua_lerror;
else
#endif
{
    // 创建引擎中Speed类对象
    Speed* self = (Speed*) tolua_tousertype(tolua_S, 1, 0);
    // 从栈中获取参数值
    float fSpeed = ((float) tolua_tonumber(tolua_S, 2, 0));
#ifndef TOLUA_RELEASE

    if (!self) tolua_error(tolua_S, &quot;invalid &apos;self&apos; in function &apos;setSpeed&apos;&quot;, NULL);

#endif
    {
        // 调用引擎中setSpeed函数，并非传递参数
        self-&gt;setSpeed(fSpeed);
    }
}

return 0;

#ifnef TOLUA_RELEASE

    tolua_lerror;
    tolua_error(tolua_S, &quot;#ferror in function &apos;setSpeed&apos;.&quot;, &amp;tolua_err)
    return 0

#endif

}

#endif
</code></pre><p>示例2：</p>
<pre><code>// 引擎中类及函数声明

tolua_class(tolua_S, &quot;Speed &quot;, &quot;Action &quot;, NULL);
tolua_beginmodule(tolua_S, &quot;Speed&quot;);
tolua_function(tolua_S, &quot;getSpeed&quot;, tolua_Cocos2d_Speed _getSpeed00);
tolua_function(tolua_S, &quot;setSpeed&quot;, tolua_Cocos2d_Speed _setSpeed00);
tolua_function(tolua_S, &quot;reverse&quot;, tolua_Cocos2d_Speed _setSpeed00);
tolua_function(tolua_S, &quot;create&quot;, tolua_Cocos2d_Speed _create00);
tolua_endmodule(rolua_S);

// 数据类型声明
static int tolua_collect_Size (lua_State* rolua_S)
{
    Size* self = (Size *) tolua_tousertype(tolua_S, 1, 0);
    Mtolua_delete(self);
    return 0;
}

// 类的注册
tolua_usertype(tolua_S, &quot;Action&quot;);
tolua_usettype(tolua_S, &quot;Speed&quot;);
tolua_usertype(tolua_S, &quot;TextFieldTTF&quot;);
tolua_usertype(tolua_S, &quot;GridBase&quot;);
</code></pre><h3 id="3-初始化脚本引擎"><a href="#3-初始化脚本引擎" class="headerlink" title="3.初始化脚本引擎"></a>3.初始化脚本引擎</h3><pre><code>bool AppDelegate::applicationDidFinishLaunching()
{
    // 初始化显示设备
    auto director = Director::getInstance();
    auto glView = director-&gt;getOpenGLView();
    if (!glView)
    {
        glview = GLViewImpl::create(&quot;Cp Empty Test&quot;);
        director-&gt;setOpenGLView(glview);
    }

    director-&gt;setOpenGLView(glview);
    //使用高清模式
    director-&gt;enableRetainDisplay(true);

    director-&gt;setDisplayFPS(true);
    director-&gt;setAnimationInterval(1.0/60);

    // 通过LuaEngin的静态函数获取一个Lua脚本引擎实例对象指针
    ScriptEnginProtocol *pEngine = LuaEngine::getInstance();

    // ScripEnginManager的静态函数getInstanceaq获取单例脚本引擎管理器的实例对象
    // 然后将Lua脚本引擎实例对象指针设为脚本引擎管理器当前进行管理的脚本引擎
    ScripEngineManager::getInstance()-&gt;setScriptEngine(pEngine);

#if (CC_TARGET_PLANTFORM == CC_PLANTFORM_ANDROID)

    // 在android平台下，会通过文件处理API类FileUtils中的getFileData取得hello.lua文件并读取到char数组中
    unsigned long size;
    char *pFileContent = (char*)FileUtils::getFileData(&quot;hello.lua&quot;, &quot;r&quot;, &amp;size);

    if (pFileContent)
    {
        // 将char数组数据放入一个新的以&apos;\0&apos;结尾的char数组中形成一个Lua脚本字符串
        char *pCodes = new char[size + 1];
        pCodes[size] = &apos;\0&apos;;
        memcpy(pCodes, pFileContent, size);
        delete[] pFileContent;
        // 让脚本引擎执行这个LUA脚本字符串
        pEngine-&gt;executeString(pCodes);
        // 释放动态申请的char数组的内存
        delete []pCode;
    }

#endif

#if (CC_TARGET_PLANTFORM == CC_PLANTFORM_WIN32) || (CC_TARGET_PLANTFORM == CC_PLANTFORM_IOS) || (CC_TARGET_PLANTFORM == CC_PLANTFORM_MARWALADE)

    // 如果是Win32, iOS, MARMALADE平台，通过文件处理API类FileUtils中的fullPathFromRelativeFile函数产生一个hello.lua在当前程序在目录下的路径
    string path = FileUtils::fullPathFromRelativeFile(&quot;hello.lua&quot;);
    // 将这个路径的目录放入到脚本引擎的搜索目录
    // path.substr会将路径中的目录取出来
    pEngine-&gt;addSearchPath(path.substr(0, path.find_last_of(&quot;/&quot;)).c_str());
    // 执行这个脚本所指向的LUA文件
    pEngine-&gt;executeScriptFile(path.c_str());

#endif
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Lua/1.6 Lua脚本引擎/" data-id="cjov31rif001g88rikhm5f8ub" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/">Lua</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Lua/1.5 Lua bindings" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Lua/1.5 Lua bindings/" class="article-date">
  <time datetime="2018-11-24T03:25:54.406Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-Lua/">Cocos2d-Lua</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Lua/1.5 Lua bindings/">1.5 Lua bindings</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Cocos2d3.0之前的版本中，使用tolua直接生成供Lua调用的代码，开发者需要对想要生成绑定代码的每个头文件编写一个PKG文件，还要移除那些在头文件中的实现，有此定义还需要针对tolua作一些特殊处理，这样导致代码的维护成本特别的高。</p>
<p>从Coco2d-x 3.0开始，Cocos2d-x使用一个名为binding-generator的工具来自动生成绑定代码。bindging-generator是基于tolua++来实现的，它使开发者只需要配置一份类的声明，bindings-generator即会对这些类的所有公共方法生成绑定代码。这样，开发者修改了类的结构后，只需要执行命重新生成绑定代码即可。</p>
<h3 id="1-生成绑定代码"><a href="#1-生成绑定代码" class="headerlink" title="1 生成绑定代码"></a>1 生成绑定代码</h3><p>使用binding-generator生成绑定代码关键是要提供一个INI配置文件，INI文件中定义了许多配置项：</p>
<ul>
<li>prefix：指示生成lua_CFunction的方法名称的前缀，通常与文件名相同。</li>
<li>target_namespace：给库指定独立的名命空间，以防止类型与其他库冲突。</li>
<li>headers：指定后面将要生成的绑定代码的类型将从哪些头文件中找。</li>
<li>class：定义那些类型需要生成绑定文件</li>
<li>skip: 用来独力忽略某些方法</li>
</ul>
<p>配置完INI文件之后，还需要向genbinding.py文件的cmd_args参数中加入下面配置：</p>
<pre><code>&apos;geniuxs.ini&apos; : (&apos;geniusx&apos;, &apos;lua_geniusx_auto&apos;), \
</code></pre><p>之后需要在cocos2d/tools/bidings-generator/targets/lua目录下的conversions.ymal文件中的ns_map节点中添加以下一行。</p>
<pre><code>&quot;GX::&quot;:&quot;gx.&quot;
</code></pre><p>当所有这些配置完毕后，执行tolua目录下的genbingings.py脚本就可以生成绑定代码。</p>
<h3 id="2-使用绑定代码"><a href="#2-使用绑定代码" class="headerlink" title="2 使用绑定代码"></a>2 使用绑定代码</h3><p>当绑定代码生成后，我们需要将它们手动添加至cocos2d_lua_binding工程下面的aoto文件夹下，然后向cocosd_lua_binding项目添加搜索路径。</p>
<p>最后需要向LuaEngine注册这些新生成的绑定代码。然后就可以使用了：</p>
<pre><code>auto engine = LuaEngine::getInstance();
ScriptEngineManager::getInstance()-&gt;setScriptEngine(engine);

auto state = engine-&gt;getLuaStack()-&gt;getLuaState();
lua_getglobal(state, &quot;_G&quot;);
register_all_geniusx(state);
lua_pop(state, 1);
</code></pre><h3 id="3-自定义绑定"><a href="#3-自定义绑定" class="headerlink" title="3 自定义绑定"></a>3 自定义绑定</h3><p>bindings-generate虽然简化了生成代码的工作，但是它也裁剪了tolua的一些功能，binding-generate只能用来生成方法的绑定代码。如果需要高级的一些绑定代码，如常量、枚举、模块、全局方法等，仍然可以使用原生的tolua来生成绑定代码。</p>
<p>对于不是由binding-generator生成的绑定代码，通常可以放在manual目录下。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Lua/1.5 Lua bindings/" data-id="cjov31rib001a88ritekfxez9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/">Lua</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Lua/1.4 面向对象脚本语言" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Lua/1.4 面向对象脚本语言/" class="article-date">
  <time datetime="2018-11-24T03:25:54.403Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-Lua/">Cocos2d-Lua</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Lua/1.4 面向对象脚本语言/">1.4 面向对象脚本语言</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>有此脚本用来扩展原生对象的行为，这可能需要脚本对面向对象有一定的支持，有些脚本如Python等本身就是面向对象的，但是通过metatable的机制，Lua可以实现对面向对象的支持，这很大地提升了脚本的处理能力。</p>
<p>一个类实例可以通过metatable来扩展其操作能力，使其可以处理其类型的实例方法，那么在Lua中对继承的对象使用同样的方式也能够实现继承的能力。在Cocos2d-x中可以extern模块提供的全局方法class来简化对继承的实现。</p>
<pre><code>function class(classname, super)

    local superType = type(super)
    local cls

    if superType ~= “function” and superType ~= &quot;table&quot; then
        superType = nil
        super = nil
    end

    if superType == &quot;function&quot; or (super and super.__ctype == 1) then

        cls = {}

        if superType == &quot;table&quot; then
            for k, v in pairs(super) do cls[k] == v end
            cls.__create = super.__create
            cls.super = super
        else
            cls.__create = super
        end

        cls.ctor = function() end
        cls.__cname = classname
        cls.__ctype = 1

        function cls.new(...)
            local instance = cls.__create(...)
            for k, v in pairs(cls) do instance[k] = v end
            instance.class = cls
            instance.ctor(....)
            return instance
        end

    else

        if super then
            cls = clone(super)
            cls.super(super)
        else
            cls = {ctor = function() end}
        end

        cls._cname = classname
        cls._ctype = 2
        cls._index = cls

        function cls.new(...)
            local instance = setmetatable({}, cls)
            instance.calss = cls
            instance:ctor(...)
            return instance
        end

    end

    return cls

end        
</code></pre><p>class方法接受一个类型的名称以及一个基类的定义，来构建一个新的类型。类型名称用来在以后的使用中区分对象的类型，可以使用_cname来查询其类型，因为在Lua中继承是依赖复制元方法来实现的，对象本身没有“类”类型。对于基类的理解如下：</p>
<p>（1）基类的参数可以是一个function，或者一个table，前者用来创建一个继承自原生对象类型的类型，而后者可以用来创建一个继承自Lua table的类型。</p>
<p>（2）基类被用来构造新类型的new方法，一个function基类，新类型new方法的返回值就是该function  ，并复制function返回对象的所有属性和方法，使其拥有父类的行为；而一个table基类，该基类的实例则会直接作为子类的实例。</p>
<p>class用于创建一个新类型，例如Genius-x中的Component类型ChapterCom</p>
<pre><code>ChapterCom = class (&quot;sg.Com&quot;
    function()
        return sg.Com.create(&quot;ChapterCom&quot;)
end)
</code></pre><p>当类型ChapterCo被创建之后，可以通过其new方法来创建一个类型ChapterCom的实例，示例如下：</p>
<pre><code>local chapter = ChapterCom.new()
</code></pre><p>class方法简化了Lua脚本中对继承的使用，使得应用程序可以轻松地对原生类型或者Lua类型作出扩展。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Lua/1.4 面向对象脚本语言/" data-id="cjov31rih001l88rilgi7k2x9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/">Lua</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Lua/1.3 Lua脚本中的事件" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Lua/1.3 Lua脚本中的事件/" class="article-date">
  <time datetime="2018-11-24T03:25:54.402Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-Lua/">Cocos2d-Lua</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Lua/1.3 Lua脚本中的事件/">1. Lua脚本中的事件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-接受及处理事件"><a href="#1-接受及处理事件" class="headerlink" title="1 接受及处理事件"></a>1 接受及处理事件</h3><p>tolua解决了C/C++方法到Lua的绑定，使得Lua可以访问原生语言中定义的方法。然而在实际开发中，除了调用原生语言中定义的方法，脚本还需要响应原生语言中的事件，这通常表现为原生语言向脚本语言发起一个方法调用。</p>
<p>这种事件响应的能力及机制对脚本来说更加重要，例如游戏设计师可以在脚本中对各种事件作出定制，深入控制游戏逻辑，对于那些完全由脚本构成的游戏，其脚本中的游戏循环则是需要引擎来驱动的。</p>
<h5 id="1-1-通信机制"><a href="#1-1-通信机制" class="headerlink" title="1.1 通信机制"></a>1.1 通信机制</h5><p>Lua的C函数接口在宿主程序和Lua之间建立了双向通信的机制，使得Lua脚本可以访问原生语言的方法，原生语言也可以调用Lua中的函数。但是在Lua之上，我们需要建立自己的架构来让他们之间真正的通信。</p>
<p>如同之间所讲过的，Lua访问原生语言的游戏对象方法的情境中，其操作步骤可以分为以下两步：</p>
<ol>
<li>宿主程序向Lua注册lua_CFunction的地址</li>
<li>在Lua中调用lua_CFunction函数，从而调用C/C++中定义的方法。</li>
</ol>
<p>类似地，在原生语言中调用Lua的函数，也需要经历两步：</p>
<ol>
<li>Lua向原生语言注册Lua函数的地址。</li>
<li>原生语言通过Lua的C函数接口调用Lua函数。</li>
</ol>
<p>在具体应用中，前者通常可以以类对象来包装文类所有方法，使用比较一致的方式进行处理，tolua就是用来帮助简化这件事情。</p>
<p>对于Lua向原生语言注册函数地址则不容易使用一致的方法来完成。这是因为除了注册和调用还需要解决另外一个问题：在什么地方需要调用一个Lua函数？这可以是在类方法、实例方法或者全局方法中。这种不同的调用Lua函数的时机各地方可能导致不同的脚本架构，，但是2他们实现通信的机制却是相同的。</p>
<h5 id="1-2-向宿主程序注册一个Lua函数地址"><a href="#1-2-向宿主程序注册一个Lua函数地址" class="headerlink" title="1.2 向宿主程序注册一个Lua函数地址"></a>1.2 向宿主程序注册一个Lua函数地址</h5><p>要向宿主程序注册一个Lua函数，首先应该由脚本程序调用原生语言方法，并将一个Lua函数地址作为一个参数传入lua_CFunction中。</p>
<p>例如在Geniux-x中，System对象需要调用脚本提供的update等方法来对游戏对象进行状态更新，那么System首先向Lua提供了一个注册方法。</p>
<pre><code>class System:public cocos2d:Ref
{
public:
# if CC_ENABLE_SCRIPT_BINDING
    void registerScriptHandler(int handler);
    void unregisterScriptHandler(void);
    int getScriptHandler(void) {return _scriptHandler};
# endif
}
</code></pre><p>在原生语言的System类定义中，registerScriptHandler和其他普通方法一样，只是这里参数handler表示的是一个Lua函数的地址，System实例会将它保存起来，以便当事件发生时，调用该地址指向的Lua函数。</p>
<pre><code>void System:registerScriptHandler(int handler)
{
    unregisterScriptHandler();
    _scriptHandler = handler;
}
</code></pre><p>当在脚本中创建一个System的实例时，调用registerScriptHandler来注册一个Lua函数，并传入一个Lua函数的地址作为参数，示例如下：</p>
<pre><code>ChapterSystem = class(&quot;gx.System&quot;,
    function ()
        local sys = sg.System:create(&quot;ChapterSystem&quot;, &quot;ChapterCom&quot;, 0)

        local function comfunc(eventName, pSender)
            if eventName == &quot;init&quot; then
            if eventName == &quot;clone&quot; then
            if eventName == &quot;attached&quot; then
            if eventName == &quot;deattached&quot; then
            if eventName == &quot;update&quot; then
            if eventName == &quot;changed&quot; then
            end
        end
    end

    sys:registerScriptHandler(comfunc);
    return sys
end)
</code></pre><p>在上述的脚本中，我们构造了一个gx.System的实例，并向其注册了一个Lua函数地址confunc。comfunc用来处理原生语言向该对象发起的各种事件调用，例如attached、update等事件，这样使得脚本对象能够执行真正的逻辑更新操作。</p>
<p>需要注意的是在C/C++中并没有对应的类型，所以tolua并不能处理registerScripterHander方法的绑定，这一部分需要我们手动维护。在cocos2d_lua_bindings项目中有两个文件夹。分别是auto和manual，其中auto文件夹里存放的是tolua生成的绑定文件，而manual文件夹则用来存储我们自己维护的绑定方法。例如namual目录下的lua_geniusx_manual中就包含了上述System类的registerScriptHandler方法的绑定。</p>
<pre><code>static void extendSystem(lua_State* L)
{
    lua_pushstring(L, &quot;gx.System&quot;);
    lua_rawget(L, LUA_REGISTRYINDEX);
    if (lua_istable(L, -1))
    {
        tolua_function(L, &quot;registerScriptHandler&quot;, tolua_geniusx_System_registerScriptHandler);
        tolua_function(L, &quot;unregisterScriptHandler&quot;, tolua_geniusx_System_unregisterScriptHandler);
    }
    lua_pop(L, 1);
}
</code></pre><p>同样，我们需要在应用程序启动的时候向LuaEngine来注册这些方法绑定，以使其生效。</p>
<h5 id="1-3-在宿主程序中调用Lua函数"><a href="#1-3-在宿主程序中调用Lua函数" class="headerlink" title="1.3 在宿主程序中调用Lua函数"></a>1.3 在宿主程序中调用Lua函数</h5><p>当某个事件发生的时候我们需要调用的是绑定的Lua函数而不是C/C++中自身的方法。下面以System的updata()方法进行分析。</p>
<pre><code>void System::update(float dt)
{
#if CC_ENABLE_SCRIPT_BINDING
    if (_scriptType == kScriptTypeLua)
    {
        SystemScriptData* custom = new SystemScriptData(dt);
        CommonScriptData data(_scriptHandler, &quot;updata&quot;, custom);
        ScriptEvent event(kCommonEvent, (void*)&amp;data);
        ScriptEngineManager::getInstance()-&gt;getScriptEngine-()-&gt;sendEvent(&amp;event);
        custom-&gt;release();
    }
#endif
}
</code></pre><p>当ECSManager调用System实例的update方法时，如果该实例包含一个Lua函数的地址，它将直接调用Lua函数进行操作。</p>
<p>其中LuaEngine实现了sendEvent方法，它将负责调用指定地址的Lua函数，这里我们还可以传入一个CommScriptData，它可以用来传入一个继承自Ref的对象作为Lua函数的参数。在sendEvent的方法链中，最终使用Lua的C函数接口lua_pcall来发起对Lua函数的调用。</p>
<p>如果一个事件处理需要返回值，由于sendEvent并没有处理返回值的机制，所以可以使用CommonScriptData中传递的Ref参数来作为数据传递的对象。由于该参数是一个指针，并且在原生语言中构造，在Lua中是一个userData对象，可以通过前面讲述的方式对其绑定一些set方法来存储返回值，然后在事件Lua函数调用完毕之后使用对应的get方法来获取返回值。最后，需要注意的是，这里需要手动释放自己构造的custom对象。否则将导致其内存不被释放。</p>
<p>通过变两个过程，我们可以处理任何类型的事件，可以在原生语言的任何地方发起Lua函数调用。</p>
<h5 id="1-4-更好地组建脚本架构"><a href="#1-4-更好地组建脚本架构" class="headerlink" title="1.4 更好地组建脚本架构"></a>1.4 更好地组建脚本架构</h5><p>在前面的讲述的方法中，处理原生语言对一个Lua函数的调用其实非常不灵活，可以总结如下：</p>
<p>（1）首先原生对象需要对每一个事件写一个注册函数。<br>（2）然后需要手动建立并初始化注册方法的绑定。<br>（3）接下来在Lua中需要调用注册方法向原生语言注册Lua函数。<br>（4）最后在事件发生的时候调用lua_pcall来调用Lua函数。</p>
<p>上面繁琐的过程这几乎成了使用Lua开发Cocos2d-x游戏比较头疼的事情，然而针对组件模型，每个组件脚本就是固定地处理组件的几个事件，这可能大大简化这个过程。</p>
<p>在Lua中，每个chunk代码段都是一个对象，所以可以使用数据驱动的方式把一个Lua脚本文件配置到Component，然后System就可以直接使用它来执行一些事件调用，这几乎省去了上述所有开发者手动处理Lua和原生语言通信相关的工作。</p>
<p>当然，这需要System对其他做特定的支持。但是将一个脚本文件看作一个脚本对象，然后直接对其执行这种方式，比起需要通过注册的方式来获取脚本对象能够很大提升使用上的体验。</p>
<h3 id="2-发送事件"><a href="#2-发送事件" class="headerlink" title="2 发送事件"></a>2 发送事件</h3><p>在脚本中产生的事件能够被其他脚本处理或者被原始语言处理，这种能力对脚本架构来说非常重要。这可能需要建立一些公共的数据结构用来处理方法、函数指针的注册。但是在Cocos2d-x中提供了一个事件分发器，只需要将事件分发器本身支持被LUa函数调用，则Lua函数就可以通过其来注册和响应事件。</p>
<p>在脚本中向EventDisPatcher注册一个事件订阅者。</p>
<pre><code>local function onLevelSelected(event)
end

local dispatcher = self:getEventDispatcher()
listenter = cc.EventListenerCustom:create(&quot;LevelSelected&quot;, onLevelSelected)
dispatcher:addEventListenerWithSceneGraphPriority(selectedListener, self)
</code></pre><p>也可以在脚本中发起一个事件：</p>
<pre><code>local event = cc.EventCustom:new(&quot;LevelSelected&quot;)
event.status = 2
event.chapterId = self.chapterData.chapterId
event.levelId = second.index
self:getEventDispatcher():dispatchEvent(event)
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Lua/1.3 Lua脚本中的事件/" data-id="cjov31ri7001388riloqi7a8m" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/">Lua</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Lua/1.2 Lua和Cocos" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Lua/1.2 Lua和Cocos/" class="article-date">
  <time datetime="2018-11-24T03:25:54.400Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-Lua/">Cocos2d-Lua</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Lua/1.2 Lua和Cocos/">1.2 Lua和Cocos</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上两篇解释了什么是脚本，及常见的脚本架构思想，以及Lua脚本和C++的交互。在不同的脚本架构中，脚本语言与游戏引擎的关系都是相似的：游戏引擎必须能够执行脚本代码，脚本也要能够发起引擎中的操作。接下来将详细整理Lua在Cocos引擎中的工作机制。</p>
<h3 id="1-对原生编程语言的接口"><a href="#1-对原生编程语言的接口" class="headerlink" title="1 对原生编程语言的接口"></a>1 对原生编程语言的接口</h3><p>通常，运行时脚本语言都提供一个虚拟机，以及原生语言与虚拟机交互的接口。虚拟机被嵌入到游戏引擎中，由游戏引擎启动虚拟机。虚拟机使得原生语言可以执行脚本代码，同时也可以向虚拟机注册一个C函数，供脚本调用。虚拟机执行脚本的单位根据具体语言和游戏实现有所不同，通常有同种执行单位。</p>
<p>（1）在函数式脚本语言中，函数通常是脚本执行的主要单位。调用一个脚本函数，需要按函数名称找到对应的字节码，然后生成一个或者命令一个现存的虚拟机去执行。</p>
<p>（2）在面向对象脚本语言中，类通常是脚本执行的主要单位。这种系统通常可以创建和销毁对象，以及对个别实例调用其方法。</p>
<p>下面以Lua脚本语言举例原生语言各脚本语言之间的通信。</p>
<h5 id="1-1-Lua的C函数语言接口"><a href="#1-1-Lua的C函数语言接口" class="headerlink" title="1.1 Lua的C函数语言接口"></a>1.1 Lua的C函数语言接口</h5><p>Lua提供了一组宿主程序与Lua通信的C函数（参考上节），Lua使用一个虚拟栈来和C传递值。</p>
<p>Lua如果要调用C函数，首先宿主程序向Lua注册一个C函数的地址，当C函数被调用的时候该函数会得到一个新的栈，这个栈独立于C函数本身，也独立于其函数调用的栈（Lua为每一次C函数调用分配一个独立的栈），它里面包含了所有Lua传递给C函数的参数，而C函数则要将返回的结果也放入堆栈以返还给调用者。</p>
<p>如果要调用一个Lua函数，首先将要被调用的函数压入栈，接着把需要传递给这个函数的参数按正序压入栈，最调用lua_call()方法，并指明参数个数，当函数调用完毕之后，所有参数及函数本身都会出栈，而函数的返回值则被压入栈。由于Lua有多个返回值，Lua会保证所有返回值都放入栈中，并按正序压栈。</p>
<p>Lua语言就是通过变个一组C函数接口，以及一个传递函数地址及参数的堆栈来使宿主程序和Lua函数进行通信的，这建立起了脚本被用在宿主程序的基础设施。在这之上可以使用前面讲述的不同脚本架构风格，灵活地将Lua作用在任何游戏的引擎之上。</p>
<h3 id="2-游戏对象句柄"><a href="#2-游戏对象句柄" class="headerlink" title="2 游戏对象句柄"></a>2 游戏对象句柄</h3><p>脚本函数需要与游戏对象互动，而游戏对象本身可能是部分或者全部由游戏引擎原生语言实现的。脚本语言可以用方法取得游戏对象句柄。如通过引擎传递过来，当一个C函数调用lua_call()并以一个对象作为参数；也可以通过查询所得，例如在Cocos2d-x中查询某个Node元素的子元素，或者是以特定的对象名字查找游戏对象句柄。</p>
<p>不同的脚本语言有不同表示游戏对象句柄的方式，例如有些脚本语言使用不透明的数值型句柄来引用游戏对象；例如在《顽皮狗》的脚本语言使用对象的名字，即以字符串来表示游戏对象句柄，这非常的易读而且直觉地使用，并保留名字”self”来代表执行中脚本现实绑定至的游戏对象。</p>
<p>而通过C/C++分配的内存在Lua中表现为一个userdata类型，userdate类型和tabel在很多方面都类似的，例如都拥有自己的metatable。但是userdata不能在Lua中被创建出来，也不能在Lua中被修改。这样的操作只能通过C函数接口来实现，这保证了宿主程序完全掌握其中的数据。此外，userdata也不受Lua垃圾回收机制的管理。</p>
<p>因此，引擎传递过来的游戏对象也是一个userdata，userdata即代表一个游戏对象的句柄。下面将讲述引擎向Lua传递游戏对象，以及Lua怎样通过游戏对象调用C/C++实现的方法。</p>
<h5 id="2-1-Lua函数调用与定义"><a href="#2-1-Lua函数调用与定义" class="headerlink" title="2.1 Lua函数调用与定义"></a>2.1 Lua函数调用与定义</h5><p>脚本函数拿到游戏对象之后最重要的是要调用其中的方法。</p>
<p>（1）在Lua中函数的调用方法如下：</p>
<pre><code>functioncall ::= prefixexp args
</code></pre><p>函数调用时，首先prefixexp被求值，如果prefixexp值的类型为function，那么这个函数就被给出的参数调用；否则prefixexp的元方法“call”被调用第个参数就是prefixexp的值，接下来依次是原来的参数args。</p>
<p>Lua支持的一种语法糖，可以通过下面形式来调用“方法”：</p>
<pre><code>function ::= prefixexp&apos;:&apos;Name args
</code></pre><p>像v:name(args)会被解释为v.name(v, args)，其中v只会被求值一次，这有点像调用对象v的实例方法name.</p>
<p>（2）Lua中函数定义如下：</p>
<pre><code>functiondef ::= function funcbody
funcbody ::= &apos;(&apos;[parlist]&apos;)&apos; block end
</code></pre><p>另外定义的一些语法糖简化了函数定义的写法。</p>
<pre><code>stat ::= function funcname funcbody
stat ::= local function Name funcbody
funcname :: Name {&apos;.&apos; Name} [&apos;:&apos; Name]
</code></pre><p>例如如下定义：</p>
<pre><code>function f () body end
</code></pre><p>被转换为：</p>
<pre><code>f = function () body end
</code></pre><p>函数定义:</p>
<pre><code>local function f () body end
</code></pre><p>被转换成：</p>
<pre><code>local f; f = function () body end
</code></pre><p>而不是：</p>
<pre><code>local f = function () body end
</code></pre><p>一个函数的定义是一个可执行的表达式，执行结果是一个类型为function的值。当一个Lua预编译一个chunk的时候，chunk被作为一个函数，整个函数体也就被预编译了，无论何时Lua执行了函数定义，这个函数本身本身就被实例化了（或者说是关闭了）。这个函数的实例，或者说闭包（Closur），就是表达式的最终值。相同函数的不同实例有可能引用不同的外部局部变量，也可能拥有不同的环境表。</p>
<p>冒号语法可以用来定义方法，也就是说函数可以有一个隐式的形参self，示例如下：</p>
<pre><code>function t.a.b.c:f (params) body end
</code></pre><p>是下面这种写法的语法糖：</p>
<pre><code>t.a.b.c.f = function (self, params) body end
</code></pre><h5 id="2-2-类对象及注册表"><a href="#2-2-类对象及注册表" class="headerlink" title="2.2 类对象及注册表"></a>2.2 类对象及注册表</h5><p>通过Lua函数的调用及定义不难发现，只要能够在Lua脚本中获取到一个表示原生语言类的对象，就可以在Lua中调用其方法。</p>
<p>例如，原生语言定义的类型ClassA:</p>
<pre><code>class ClassA
{
public:
    static ClassA* create();
    string getName();
}
</code></pre><p>如果在Lua中有一个全局对象ClassA表示原生语言定义的ClassA类型，那么就可以通过“Class.create()”来调用原生语言类型静态方法，而一个Class的实例a可以通过“a:getName()”来调用原生语言类型ClassA的实例方法，这等效于“ClassA.getName(self)”。</p>
<p>所以，Lua类对象最重要的事情就是怎样向Lua注册一个类对象，用来供Lua调用原生语言定义的方法。</p>
<p>Lua提供了一张注册表，这是一张预定义表，可以用来存储任意C代码想要保存的Lua值，这张表使用伪索引LUA_REGISTERYINDEX来定位，任何C库都可以在这张表里保存数据。为了防止冲突，需要特别小心地选择键名。一般的做法是使用库的名字或者userdata的地址来作为键。</p>
<p>有了注册表，那么我们怎么根据每个类的定义来构造一个表示类型的对象呢？这就要用到tolua。</p>
<h5 id="2-3-tolua构造对象"><a href="#2-3-tolua构造对象" class="headerlink" title="2.3 tolua构造对象"></a>2.3 tolua构造对象</h5><p>tolua是一个用来简化C/C++与Lua之间进行集成的工具，基于一个不包含实现的头文件。tolua可以帮助生成从Lua中访问C/C++功能的绑定代码，通过这些绑定代码，tolua将C/C++的常量、变量、函数、类及方法映射到Lua中去。我们通常使用的是tolua++，它是tolua的扩展，支持模板方法、string基本类型。</p>
<p>由于宿主程序可以通过向Lua注册表中添加Lua对象来存储C/C++数据，那么tolua的主要功能就是构造各种对象，并将其存储在注册表中，例如常量及函数将存储在全局表中，而每个类及实例方法则定义为一个类对象。</p>
<p>对于一个类对象进行绑定的代码大体结构如下：</p>
<pre><code>int lua_register_geniusx_Entity(lua_State* tolua_S)
{
    tolua_usertype(tolua_S, &quot;gx.Entity&quot;);
    tolua_classs(tolua_S, &quot;Entity&quot;, &quot;gx.Entity&quot;, &quot;cc.Ref&quot;, nullptr);

    tolua_beginmodule(tolua_S, &quot;Entity&quot;);

    tolua_function(tolua_S, &quot;setBucket&quot;, lua_geniusx_Entiy_setBucket);
    tolua_function(tolua_S, &quot;getComByTpe&quot;, lua_geniusx_Entiy_getComByTpe);
    tolua_function(tolua_S, &quot;getParent&quot;, lua_geniusx_Entiy_getParent);
    tolua_function(tolua_S, &quot;removeAllComs&quot;, lua_geniusx_Entiy_removeAllComs);
    tolua_function(tolua_S, &quot;getId&quot;, lua_geniusx_Entiy_getId);
    tolua_function(tolua_S, &quot;removeCom&quot;, lua_geniusx_Entiy_removeCom);
    tolua_function(tolua_S, &quot;getNode&quot;, lua_geniusx_Entiy_getNode);

    tolua_endmodule(tolua_S);
    std::string typeName = typeid(GX:Entity).name()
    g_luaType[typeName] = &quot;gx.Entity&quot;;
    g_typeCase[&quot;Entity&quot;] = &quot;gx.Entity&quot;;

    return 1;
}

上述示例会创建一个名为gx.Entity的全局对象，该对象包含每个C++中定义的方法的指针，这实际上被转换为一个lua_CFunction类型。这个对象被注册到Lua的注册表，前功并以类型的名称作为键，所以在Lua中使用gx.Entity就可以获取到Entity类对象。而对于类Entity的实例entity管理，可以通过下面的方法来查询ID。

 local id = gx.Entity.getId(entity);
</code></pre><p>那么什么时候调用绑定代码向Lua虚拟机注册这些类对象？当然是启动引擎的时候。可以直接使用当前的Lua栈作为参数来调用上述方法进行初始化。在Cocos2d-x中，Lua虚拟机由LuaEngin管理，可以通过下面的方式来注册类对象。</p>
<pre><code>auto engine = LuaEngine::getInstance();
ScriptEngineManager::getInstance-&gt;setScriptEngine(engine);

auto state = engine-&gt;getLuaStack()-&gt;getLuaState();
lua_getglobal(state, &quot;_G&quot;);
lua_register_geniux_Entity(state);
lua_pop(State, 1);
</code></pre><p>当程序启动的时候，LuaEngine就会调用lua_register_geniusx_Entiy方法，将Entity类对象注册到Lua虚拟机中，这样在Lua中就能调用Entity类对象中的方法。</p>
<h5 id="2-4-调用游戏对象方法"><a href="#2-4-调用游戏对象方法" class="headerlink" title="2.4 调用游戏对象方法"></a>2.4 调用游戏对象方法</h5><p>类对象和游戏对象是有区别的，游戏对象是一个C/C++分配的内存，所以它是一个userdata类型的对象。而类对象并不是C/C++中的一段内存，也不是一个普通的table，而是一个metatable。</p>
<pre><code>TULUA_API void tolua_usertype(lua_State* L, const char* type)
{
    char ctype[128] = &quot;const&quot;;
    strncat(ctype, type, 120);

    if (tolua_newmetatable(L, ctype) &amp;&amp; tolua_newmetatable(L, type))
        mapsuper(L, type, ctype);
}
</code></pre><p>Lua中每一个值都可以拥有一个metatable，这个metatable就是一个原始的Lua table，它用来定义原始值在特定操作下的行为。可以通过在metatable中的特定域设一些值来改变拥有这个metatable的值的指定操作行为。例如，当一个非数字的值做加法操作的时候，Lua会检查它的metatable的”_add”域中是否有一个函数，如果有这么一个函数，Lua会调用这个函数来执行一次加法。我们称metatable中的键名为事件（Event），把其中的值叫作元方法。在上面的例子中，事件是add，而元方法是执行那个加法操作的函数。</p>
<p>在Lua中，每个table和userdata拥有独立的matatable，多个table和userdata可以共享五个相同的表作为它们的matatable；而其类型的值，每种类型分别共享唯一一个matatable。因此所有的数字共享一个matatable，所有的字符串也一起共享一个metatable。</p>
<p>通过以类型名称如gx.Entity注册了全局变量之后，该matatable包含了Entity定义的所有方法。每个实例共享方类所对应的matatable，与每个数字共享一个matatable是一样的。在C/C++中创建一个对象的时候，tulua会找到该实例的类型对应的matatable，然后将其作为该实例对象的matatable。</p>
<p>这个过程量怎么实现的呢？可以看Cocos2d中的Node类的create方法。</p>
<pre><code>lua lua_cocos2dx_node_create(lua_State* tolua_S)
{
    int argc = 0;
    bool ok = true;

    argc = lua_gettop(tolus_S) - 1;
    if (argc == 0)
    {
        if(ok)
            return 0;
        Node* ret = Node::create();
        object_to_luaval&lt;Node&gt;(tulus_S, &quot;cc.Node&quot;, (Node*)rec);
        return 1
    }
    return 0;
}
</code></pre><p>这是一个lua_CFunction，在Lua中调用cc.Node.creat的时候将会执行此方法。该方法首先调用原生的Node:create()方法创建一个Node对象，然后使用刚刚创建的实例ret及一个类型参数cc.Node调用了一个object_toluaval()方法，该方法调用的最终结果是调用了toluafix_pushusertype_ccobject()方法。</p>
<pre><code>TOLUA_API int toluafix_pushusertype_ccobject(lua_State* L, int refid, int* p_refid, void* ptr, const char* type)
{
    if (ptr == NULL || p_refid == NULL)
    {
        lua_pushnil(L);
        return -1;
    }

    Ref* vptr = static_cast&lt;Ref*&gt;(ptr);
    const char* vType = getLuaTypeName(vPtr, type);

    if(*p_retid == 0)
    {
        *p_refid = refid;

        lua_pushstring(L, TOLUA_ETFID_PTR_MAPPING);
        lua_rewget(L, LUA_REGISTRYINDEX);
        lua_pushinteger(L, refid);
        lua_pushlightuserdata(L, vPtr);

        lua_rawset(L, -3);
        lua_pop(L, 1);

        lua_pushstring(L, TOLUA_REFID_TYPE_MAPPING);
        lua_rewget(L, LUA_REGISTRYINDEX);
        lua_pushinteger(L, refid);
        lua_pushstring(L, vType);
        lua_rawset(L, -3);
        lua_pop(L, 1);
    }
    tolua_pushusertype_and_addtoroot(L, vPtr, bType);
    return 0;
}
</code></pre><p>该方法使用ptr为ref实例构建了一个userdata对象来在Lua中引用其内存地址，并从注册表中查找该类型的matatabel，让该对象拥有其表示类型的matatable。这样，通过类实例对象就可以该类的所有方法了。</p>
<p>例如，在Lua中有类型Node的实例node变量，则可以通过node:setName(“Hero”)这等效于：</p>
<pre><code>node.setName(node, &quot;Hexo&quot;);
</code></pre><p>或者：</p>
<pre><code>cc.Node.setName(node, &quot;Hexo&quot;);
</code></pre><p>因为最终它们都会从类型cc.Node对应的metatable中查找setName操作。</p>
<p>在Cocos2D-X引擎中嵌入了C语言版本解释器，保证了性能。</p>
<p>作为</p>
<p>###1.Lua和C++交互</p>
<p>Lua在各Ｃ++交与时，Lua运行环境维护着一份堆栈。这不是传统意义上的堆栈，而是Lua模拟出来的。Lua与C/C++数据传递、函数调用都通过这份堆栈来完成。</p>
<p>这份堆栈代表的就是lua_State*所指的结构数据。所有Lua语言中的类型在C和C++中都存在一种应对方式。开发者通过lua_push系列函数向堆栈中压入值，通过luaL_check系列从堆栈中获取值。</p>
<p>具体过程如图12-4所示的方式。</p>
<p>###2.tolua++</p>
<p>tolua++是第三方的开源库，它可以为Lua提供面向对象的特性，这样开发者就可以通过Lua来编写使用C++语言库的脚本文件。</p>
<p>tolua++使用的方法为编写一个.pkg，然后生成对应的.c或.cpp文件，然后把这个和对应的C\C++文件一起编译生成可执行程序，这样就可以对对应的lua文件进行读取操作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Lua/1.2 Lua和Cocos/" data-id="cjov31ria001788rifppanccb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/">Lua</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Lua/1.1 Lua和C++" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Lua/1.1 Lua和C++/" class="article-date">
  <time datetime="2018-11-24T03:25:54.397Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-Lua/">Cocos2d-Lua</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Lua/1.1 Lua和C++/">1.1 Lua和C++</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="1-1-Lua和C"><a href="#1-1-Lua和C" class="headerlink" title="1.1 Lua和C++"></a>1.1 Lua和C++</h1><p>Lua提供了一组宿主程序与Lua通信的C函数，Lua使用一个虚拟栈来和C传递值，栈上的第一个元素过都是一个Lua值，例如nil、数字、字符串等，栈的特点是先进后出。</p>
<h3 id="1-Lua堆栈"><a href="#1-Lua堆栈" class="headerlink" title="1 Lua堆栈"></a>1 Lua堆栈</h3><p>Lua栈是在创建lua_State的时候创建的，lua的栈类似于以下定义：</p>
<pre><code>TValue stack[max_stack_len]    // 欲知内情可查lstate.c的stack_init函数
</code></pre><p>图Lua栈是一个栈的例子：</p>
<p><img src="http://7xqzxs.com1.z0.glb.clouddn.com/170708Lua%E6%A0%88.jpg" alt=""></p>
<p>栈的索引可以是正数也可以是负数。区别是正数索引1永远表示栈底，负数索引-1永远表示栈顶。</p>
<p>执行下面代码就可以让你的Lua栈上呈现图中的情况：</p>
<pre><code>lua_pushcclosure(L, func, 0)   // 创建并压入一个闭包
lua_createtable(L, 0, 0)       // 创建并压入一个表
lua_pushnumber(L, 343)         // 压入一个数字
lua_pushstring(L, &quot;mystr&quot;)     // 压入一个字符串
</code></pre><p>这里要说明的是，你压入的类型有数值、字符串、表和闭包[在C中看来是不同类型的值，但是最后都统一用TValue这种数据结构来保存的，上图Lua栈元素说明了这种结构。</p>
<p>（1）TValue</p>
<p>TValue结构对应于lua中所有数据类型，是一个{值， 类型}的结构，它把值和类型绑在一起，用tt记录value的类型。</p>
<p>（2）valua</p>
<p>valua是一个联合结构，由Value定义，它有4个域：</p>
<ul>
<li>gc，需要内存垃圾回收的值都存这里。gc是一个指针，它可以指向的类型由联合体GCObject定义，图中可以看出有string、userdata、closure、table、proto、upvalue、thread。</li>
<li>p，可以存一个指针，实际是lua中的light userdata结构。</li>
<li>n，所有的数值存这里，不管是int还是float</li>
<li>b，Boolean值存在这里，注意lua_pushinteger不是存在这是，而是存在n中，b只存布尔</li>
</ul>
<p>Lua Value和C Value的对应关系：</p>
<p><img src="http://7xqzxs.com1.z0.glb.clouddn.com/170709C%E5%92%8CLuaValue%E5%AF%B9%E6%AF%94.jpg" alt=""></p>
<p>Lua中的一些类型和C中是对应的，也提供一些C中没有的类型。做如下说明：</p>
<ul>
<li>nil，C中没有可以通过lua_pushnil向lua中压入一个nil值。</li>
<li>lua_push所有函数都有“创建一个类型值并压入”的语义，因为Lua中所有的变量都是Lua中创建并保存的。</li>
</ul>
<p>通过以上，可以得出如下结论：</p>
<p>（1）lua中，number、boolean、nil、light四种类型的值是直接存在栈上元素里，和垃圾回收无关。</p>
<p>（2）lua中，string、table、closure、userdata、thread存在栈元素里的只有指针，它们都会丰生命周期结束后被垃圾回收。</p>
<h3 id="2-Lua堆栈的操作"><a href="#2-Lua堆栈的操作" class="headerlink" title="2 Lua堆栈的操作"></a>2 Lua堆栈的操作</h3><p>Lua与C++是通过栈来通信，Lua提供了C API对栈进行操作，如下：</p>
<pre><code>int  lua_gettop(lua_State *L);                    // 返回栈顶索引（即栈长度）
void lua_settop(lua_State *L, int idx);           // 将栈顶设置为一个指定的位置，底用nil补，高则舍去
void lua_pushvalue(lua_State *L, int idx);        // 将idx索引上的值压入栈顶
void lua_remove(lua_State *L, int idx);           // 移除idx索引上的值
void lua_insert(lua_State *L, int idx);           // 弹出栈顶元素，并插入索引idx位置
void_replace(lua_State *L, int idx);              // 弹出栈顶元素，并替换索引idx位置的值
</code></pre><p>C中加载Lua时的一些函数：</p>
<pre><code>Lua_State* luaL_newstate();                       // 申请一个虚拟机，返回指针类型，此后所有Lua Api调用都需要指定此指针为第一参数，用来指定虚拟机
lua_getgobal(lua_State *L, const char *name);     // 操作两步：1.将name放入酷栈中。2.由Lua去寻找变量var的值，并返回栈顶。作用就是把全局的name的值压到栈顶
lua_getfild(lua_State *L, int idx, const char *k);// 读取table 中字段的值,将字段的值读取到栈中; 
lua_is***(lua_State *L, int idx);                 // 检查索引为index的变量是某个类型
lua_to***(lua_State *L, int idx);                 // 获取栈中的变量，转为某个指定的类型
lua_close();                                      // 销毁所在Lua State上的所有对象
</code></pre><p><strong>注：Lua堆栈操作是基于栈顶的，就是它只会去操作栈顶的值。</strong></p>
<p>示例：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string.h&gt;
using namespace std;

extern &quot;C&quot;
{
    #include &quot;lua.h&quot;
    #include &quot;luaxlib.h&quot;
    #include &quot;lualib.h&quot;
}

void main()
{
    // 1.创建一个state
    // 可以简单理解为luaL_newState返回一个指向堆栈的指针
    lua_State *L = luaL_newstate();

    // 2.入栈操作
    lua_pushstring(L, &quot;I am so cool~&quot;);
    lua_pushnumber(L, 20);

    // 3.取值操作
    if(lua_isstring(L, 1))                 // 判断是否可转为string
    {
        cout&lt;&lt;lua_tostring(L, 1)&lt;&lt;endl;    // 转为string并返回
    }

    if(lua_isnumber(L, 1))
    {
        cout&lt;&lt;lua_tonumber(L, 2)&lt;&lt;endl;
    }

    // 关闭state
    lua_close(L);
    return;
}
</code></pre><h3 id="3-C-调用Lua"><a href="#3-C-调用Lua" class="headerlink" title="3 C++调用Lua"></a>3 C++调用Lua</h3><p>我们经常使用Lua文件来作配置文件。类似ini、xml等文件配置信息。我们使用C++来读取Lua文件中的变量，table，函数。</p>
<p>Lua和C++的通信规则为：</p>
<p>（1）所有Lua中的值由lua来管理，Lua负责这些变量的生命周期和垃圾回收，C++中产生的值lua不知道。</p>
<p>（2）C++想要什么值，只需要告诉Lua，由Lua产生放到栈上。C++只能通过API来操作这个值。</p>
<p>用C++来读取Lua示例：</p>
<pre><code>//helo.lua文件
str = &quot;I am so cool&quot;
tbl = {name = &quot;zhang&quot;, id = 20170708};
function add(a, b)
    return a + b;
end
</code></pre><p>使用下面C++程序来读取它：</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string.h&gt;
using namespace std;

extern &quot;C&quot;
{
    #include &quot;lua.h&quot;
    #include &quot;luaxlib.h&quot;
    #include &quot;lualib.h&quot;
}

void main()
{
    // 1.创建Lua状态
    lua_State *L = luaL_newstate();
    if (L == NULL)
    {
        return;
    }

    // 2. 加载Lua文件
    int bRet = luaL_loadfile(L, &quot;hello.lua&quot;);
    if (bRet)
    {
        cout&lt;&lt;&quot;load file error&quot;&lt;&lt;endl;
        return;
    }

    // 3.运行Lua文件
    bRet = lua_pcall(L, 0, 0, 0);
    if(bRet)
    {
        cout&lt;&lt;&quot;pcall ettor&quot;&lt;&lt;endl;
        return;
    }

    // 4.读取变量
    lua_getglobal(L, &quot;str&quot;);
    string str = lua_tostring(L, -1);
    cout&lt;&lt;&quot;str = &quot;&lt;&lt;str.c_str()&lt;&lt;endl;        // str = I am so cool~

    // 5.读取table
    lua_getglobal(L, &quot;tbl&quot;);
    lua_getfield(L, -1, &quot;name&quot;);
    str = lua_tostring(L, -1);
    cout&lt;&lt;&quot;tbl:name=&quot;&lt;&lt;str.c_str()&lt;&lt;endl;    // tbl:name = shun

    // 6.读取函数
    lua_getglobal(L, &quot;add&quot;);                 // 获取函数压入栈中
    lua_pushnumber(L, 10);                   // 压入第一个参数
    lua_pushnumber(L, 20);                   // 压入第二个参数
    int iRet = lua_pcall(L, 2, 1, 0);        // 调用函数，调用完以后，会将返回值压入栈中，2表示参数个数，1表示返回结果数
    if (iRect)                               // 调用出错
    {
        const char *pErrorMsg = lua_tostring(L, -1);
        cout &lt;&lt; pErrorMsg &lt;&lt; endl;
        lua_close(L);
        return;
    }
    if (lua_isnumber(L, -1))                 // 取值输出
    {
        double fValue = lua_tonumber(L, -1);
        cout &lt;&lt; &quot;Result is&quot; &lt;&lt; fValue &lt;&lt; endl;
    }

    // 至此，栈中的情况是：
    // =========================栈顶==========================
    // 索引    类型      值
    // 4       int:      30
    // 3       string:   zhang
    // 2       table:    tbl
    // 1       string:   I am so cool~

    // 7.关闭state
    lua_close(L);
    return;
}
</code></pre><p>读取后，通过以下方法修改table的值：</p>
<pre><code>lua_pushstring(L, &quot;我是一个大帅锅~&quot;);        // 将需要设置的值设置到栈中
lua_setfield(L, 2, &quot;name&quot;);                  // 将这个值设置到table中（此时tbl在栈的位置为2）
</code></pre><p>或者新建一个table</p>
<pre><code>lua_newtable(L);                             // 创建一个新的table，并压入栈
lua_pushstring(L, &quot;Give me a gril friend!&quot;); // 将值压入栈
lua_setfield(L, -2, &quot;str&quot;);                  // 将值设置到table中，并将“Give me...出栈”
</code></pre><p>值的传递：</p>
<p>对于那些和C中有对应关系的lua类型，lua会通过api传来的附加参数，创建出对应类型的Lua变量放在栈顶;对于和C中没有对应关系的lua类型，lua直接创建出对应类型的lua变量放在栈顶。例如：</p>
<pre><code>lua_pushstring(L, &quot;string&quot;);   // Lua会根据func创建一个TString obj，绑定到新分配的元素上
lua_pushnumber(L,5);           // Lua会直接修改新分配的栈顶元素，将5赋值到对应的域
</code></pre><p>总之：</p>
<p>C Value -&gt; Lua Value的流向，一个c value入栈就是进入了lua的世界, lua会生成一个对应的结构并管理起来, 从此就不再依赖这个c value。不管是想把一个简单的5放Lua的世界，还是创建一个table都会导致：</p>
<ol>
<li>栈顶分配新元素</li>
<li>绑定或赋值</li>
</ol>
<p>Lua Value -&gt; C Value时，是通过lua_to族api实现，取出对应C中的域的值就行了。只能转换那些有对应值的lua Value，比如table就不能to c value。</p>
<h3 id="4-Lua调用C"><a href="#4-Lua调用C" class="headerlink" title="4 Lua调用C++"></a>4 Lua调用C++</h3><p>Lua调用C++通常有以下三种方法：</p>
<h5 id="4-1-直接将模块写入Lua源码中"><a href="#4-1-直接将模块写入Lua源码中" class="headerlink" title="4.1 直接将模块写入Lua源码中"></a>4.1 直接将模块写入Lua源码中</h5><p>在Lua中调用C++,我们可以将函数写入lua.c中，然后重新编译Lua文件。</p>
<p>在Lua.c中加入函数，必须要遵循如下规范：</p>
<pre><code>typedef int (*lua_CFunction) (lua_State *L);
// 所有的函数必须接受一个lua_State作为参数，同时返回一个整数值。
// 使用Lua栈作为参数可以从栈里读取任意数量和任意类型的参数，而返回值表示有多少个函数值被压入Lua栈。
</code></pre><p>在lua.c加入如下函数：</p>
<pre><code>static int getTwoVar(lua_State *L)
{
    // 向函数栈中压入2个值
    lua_pushnumber(L, 10);
    lua_pushunumber(L, &quot;hello&quot;);
    return 2;
}

// 在pmain函数中，在luaL_openlibs函数后加入以下代码：
// 注册函数
lua_pushcfunction(L, getTwoVar);              // 将函数放入栈中
lua_setglobal(L, &quot;getTwoVar&quot;);                // 设置lua全局变量getTwoVar
</code></pre><p>通过查找lua.h，之前的注册函数还有如下写法：</p>
<pre><code>// 注册函数的宏定义
#defin lua_register(L, n, f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)));

// 注册函数
lua_register(L, &quot;getTwoVar&quot;, getTwoVar);
</code></pre><p>调用及运行结果如下：</p>
<pre><code>&gt; a, b = getTwoVar()
&gt; print(a, b)
10          hello
&gt;
</code></pre><p>我们一般不去修改别人的源码，更倾向于编写独立的C/C++模块，供Lua调用。</p>
<h5 id="4-2-使用静态依赖库的方式"><a href="#4-2-使用静态依赖库的方式" class="headerlink" title="4.2 使用静态依赖库的方式"></a>4.2 使用静态依赖库的方式</h5><p>使用静态依赖库的方式大概顺序就是：我们在C++中写一个模块函数，将函数注册到Lua解释器中，然后由C++去执行我们的Lua文件，在Lua文件中去调用刚刚注册的函数。具体步骤如下：</p>
<p>（1）新建一个win32控制台工程，记得在VC++目录中，把lua中的头文件和lib文件的目录包含进来。然后链接器-&gt;附加依赖项-&gt;将lualib也包含进来。</p>
<p>（2）在目录下新建一个avg.lua如下：</p>
<pre><code>avg, sum = average(10, 20, 30, 40, 50);
print(&quot;The average is&quot;, avg);
print(&quot;The sum is&quot;, sum)
</code></pre><p>（3）新建test.cpp如下</p>
<pre><code>#include &lt;stdio.h&gt;  
extern &quot;C&quot; {  
#include &quot;lua.h&quot;  
#include &quot;lualib.h&quot;  
#include &quot;lauxlib.h&quot;  
}  

lua_State* L;                               // 指向Lua解释器的指针
static int average(lua_State *L)  
{  
    int n = lua_gettop(L);                  // 得到参数个数
    double sum = 0;  
    int i;  

    for (i = 1; i &lt;= n; i++)                // 循环求参数之和
    {  
        sum += lua_tonumber(L, i);  
    }  
    lua_pushnumber(L, sum / n);             // 压入平均值
    lua_pushnumber(L, sum);                 // 压入和
    return 2;                               // 返回返回值的个数
}  

int main ( int argc, char *argv[] )  
{  
    L = lua_open();                         // 初始化Lua

    luaL_openlibs(L);                       // 载入Lua基本库
    lua_register(L, &quot;average&quot;, average);    // 注册函数
    luaL_dofile(L, &quot;avg.lua&quot;);              // 运行脚本
    lua_close(L);                           // 清除Lua

    printf( &quot;Press enter to exit…&quot; );       // 暂停
    getchar();  
    return 0;  
}
</code></pre><p>执行可以得到如下结果：</p>
<pre><code>The average is 30
The sum is     150
Press enter to exit ...
</code></pre><h5 id="4-3-使用dll动态链接的方式"><a href="#4-3-使用dll动态链接的方式" class="headerlink" title="4.3 使用dll动态链接的方式"></a>4.3 使用dll动态链接的方式</h5><p>具体步骤如下：</p>
<p>（1）新建dll工程，工程名为mLualib（最后导出为myLualib.dll），然后编写我们C++模块，创建一个.h和.m文件。</p>
<p>（2）.h和定义如下：</p>
<pre><code>extern &quot;C&quot; {  
#include &quot;lua.h&quot;  
#include &quot;lualib.h&quot;  
#include &quot;lauxlib.h&quot;  
}  

#ifdef LUA_EXPORTS  
#define LUA_API __declspec(dllexport)  
#else  
#define LUA_API __declspec(dllimport)  
#endif  

extern &quot;C&quot; LUA_API int luaopen_mLualib(lua_State *L);     //定义导出函数
</code></pre><p>（3）.m定义如下：</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &quot;mLualib.h&quot;  
static int averageFunc(lua_State *L)  
{  
    int n = lua_gettop(L);  
    double sum = 0;  
    int i;  

    for (i = 1; i &lt;= n; i++)          // 循环求和
        sum += lua_tonumber(L, i);  

    lua_pushnumber(L, sum / n);       // 压入平均值  
    lua_pushnumber(L, sum);           // 压入和  

    return 2;                         // 返回两个结果  
}  

static int sayHelloFunc(lua_State* L)  
{  
    printf(&quot;hello world!&quot;);  
    return 0;  
}  

static const struct luaL_Reg myLib[] =   
{  
    {&quot;average&quot;, averageFunc},  
    {&quot;sayHello&quot;, sayHelloFunc},  
    {NULL, NULL}                      // 数组中最后一对必须是{NULL, NULL}，用来表示结束      
};  

int luaopen_mLualib(lua_State *L)  
{  
    luaL_register(L, &quot;ss&quot;, myLib);  
    return 1;                         // 把myLib表压入了栈中，所以就需要返回1  
}
</code></pre><p>（4）新建Lua文件如下：</p>
<pre><code>require &quot;mLualib&quot;  
local ave,sum = ss.average(1,2,3,4,5) //参数对应堆栈中的数据  
print(ave,sum)  -- 3 15  
ss.sayHello()   -- hello world!
</code></pre><p>以上代码的执行过程如下：</p>
<ol>
<li>我们编写了averageFunc求平均值和sayHelloFunc函数。</li>
<li>然后把函数封装myLib数组里面，类型必须是luaL_Reg。</li>
<li>由luaopen_mLualib函数导出并在lua中注册这两个函数。</li>
</ol>
<p>当我们在Lua中:</p>
<pre><code>require &quot;mLualib&quot;
</code></pre><p>Lua会进行如下操作：</p>
<pre><code>local path = &quot;mLualib.dll&quot;
local f = package.loadlib(path, &quot;luaopen_mLualib&quot;)   -- 返回luaopen_mLualib函数
f()                                                  -- 执行
</code></pre><p>所以当我们编写这样的一个模块的时候，编写luaopen_xxx导出函数的时候，xxx最好是和项目名一样（因为项目名和dll一样）。</p>
<p>需要注意的是：函数参数里的lua_State是私有的，每一个函数都有自己的栈。当一个C/C++函数把返回值压入Lua栈以后，该栈会自动被清空。</p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h3><ul>
<li>Lua和C++是通过一个虚拟栈来交互的。</li>
<li>C++调用Lua实际上是：由C++先把数据放入栈中，由Lua去栈中取数据，然后返回数据对应的值到栈顶，再由栈顶返回C++。</li>
<li>Lua调C++也一样：先编写自己的C模块，然后注册函数到Lua解释器中，然后由Lua去调用这个模块的函数。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Lua/1.1 Lua和C++/" data-id="cjov31ri6001188ritm42t47d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/">Lua</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Lua/1 脚本" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/24/Lua/1 脚本/" class="article-date">
  <time datetime="2018-11-24T03:25:54.396Z" itemprop="datePublished">2018-11-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Cocos2d-Lua/">Cocos2d-Lua</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/24/Lua/1 脚本/">1. 脚本</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-脚本概念"><a href="#1-脚本概念" class="headerlink" title="1 脚本概念"></a>1 脚本概念</h3><p>脚本语言是相对于静态编译型语言而言的，它通常在应用程序运行期间通过虚拟机解释执行。因此脚本代码是与平台无关的，引擎可以把代码当作数据处理，在运行期间动态载入内存执行。</p>
<p>Cocos2d-x支持Lua和JavaScript两种脚本语言，同时还提供绑定的机制，让开发者自定义的C++对象可以被脚本访问。</p>
<h5 id="1-1-脚本的分类"><a href="#1-1-脚本的分类" class="headerlink" title="1.1 脚本的分类"></a>1.1 脚本的分类</h5><p>广义的脚本实际上可以分为两种：</p>
<ul>
<li><p>数据定义语言：主要功能在于让用户创建及填充数据结构，这些数据供引擎读取。这些语言通常是声明式的，如HTML、XML、JSON。</p>
</li>
<li><p>运行时脚本语言：包含的是引擎可执行代码，在运行时的引擎上下文中执行。这些语言通常用于扩展或定制游戏对象模型/或其他引擎系统的硬编码（是指被编译器翻译成机器码，这些机器码在CPU上执行而不能被运行时修改）。</p>
</li>
</ul>
<p>运行时脚本语言本质上是属于数据定制脚本语言，但是通过结合以属性为中心的对象模型，它也能够实现一些对游戏对象行为的修改。所以他们直接的区别在于游戏引擎是需要解析脚本还是执行脚本。Lua在Cocos2d中属于后者。</p>
<h5 id="1-2-脚本的特征"><a href="#1-2-脚本的特征" class="headerlink" title="1.2 脚本的特征"></a>1.2 脚本的特征</h5><p>脚本的特征是解析。大多数脚本语言是直译式的，也称之为动态解释型，动态解释型是相对于静态的编译式语言而言。</p>
<p>（1）执行速度</p>
<p>编译时语言的源码由编译器翻译成机器码，然后机器码直接在cpu上运行，编译器可以可以针对平台进行优化，因而它的执行速度比较快。</p>
<p>直译式的源码可以在运行时直接解析，或是先编译为与平台无关的的字节码，然后这些字节码在在虚拟机中直接执行。直译式语言通常需要一个宿主程序来执行虚拟机，因此它几乎可以移植到任何平台。但是虚拟机执行字节码和速度比原生CPU执行机器码和速度要慢得多。</p>
<p>（2）轻量级</p>
<p>脚本语言相对于原生语言要轻量的多，并且它们的虚拟机比较简单，消耗的内存比较少。例如在Lua中，它以代码段（Chunk）为单位，虚拟机在执行的时候使用一个很小的栈来保存方法、地址及参数，然后将执行结果保存在栈中供原生语言来获取，在执行完一个方法即清空栈。这使得Lua执行速度很快且非常轻量级。</p>
<p>（3）适用场景</p>
<p>由于脚本的解析特征，以及以代码段为单位，因而它特别适合用来对程序的某些方面提供一些定制功能。例如用来发送处理一些事件，实现有限状态机，以及一些对系统的控制。</p>
<p>此外，一些脚本语言是函数式的，其目的是完全避免使用状态。在函数式语言中，程序由一组函数定义，每个函数都不对系统其他数据构成影响。程序的构建方法是由一个函数传送输入参数至另外一个函数，直到取得所需结果。这些语言适合实现一些数据处理管道。</p>
<h5 id="1-3-脚本的架构"><a href="#1-3-脚本的架构" class="headerlink" title="1.3 脚本的架构"></a>1.3 脚本的架构</h5><p>脚本在游戏引擎中可以扮演不同的角色，有许多架构可以参考，从简单的脚本代码片段去代表一个游戏对象或引擎系统执行一个简单的功能，到高层的脚本去管理游戏的操作。下面讨论一些可能的脚本：</p>
<p>（1）回调脚本：</p>
<p>在这种架构中，引擎的大部分功能主要是原生语言硬编码的，只有某些关键的小功能设计成可定制的。这些部分通常实现为回调函数。让用户提供一个函数供引擎调用，以实现一些定制。回调函数可以使用脚本编写。例如在游戏循环中更新游戏对象时，引擎可提供一个回调函数，让用户有机会对游戏对象更新方式作一些定制。</p>
<p>（2）事件处理脚本</p>
<p>事件处理器是一种特殊的回调函数，其作用是令游戏对象回应游戏世界发生的事件，例如对爆炸作出反应，或是回应游戏引擎本身的事件，如内存不足。事件处理脚本较回调脚本在实现上更为灵活，例如事件处理脚本可以向一个专门的事件处理器注册事件处理函数，但是回调脚本则可能需要向引擎不同部分注册回调函数。</p>
<p>（3）以脚本扩展游戏对象类型或定义新类型</p>
<p>有些脚本语言可以用脚本扩展原来由原生语言实现的游戏对象模型。例如，在Cocos2d中可以使用Lua派生自Node类来实现一个新的类型。</p>
<p>（4）组件属性脚本</p>
<p>在基于组件或基于属性的游戏对象模型中，只允许使用脚本或部分脚本创建新组件或属性对象，而不能扩展原生的游戏对象模型。例如在《末日危城》中，允许用C++或者Skrit编写属性对象，在项目结束时约有148个脚本属性和21个C++原生对象属性。</p>
<p>（5）脚本驱动的引擎系统</p>
<p>脚本也可以驱动整个引擎系统，例如可以将游戏对象模型完全用脚本编写，仅当需要一些底层引擎组件时才需要调用原生引擎代码。可以想像使用脚本来实现属性模型架构，仅当需要实现渲染、动画、物理等部分的组件时才需要和引擎系统交互。</p>
<p>（6）脚本驱动的游戏</p>
<p>有些语言则完全颠倒原生语言各脚本语言的关系，在这些引擎中，脚本代码是游戏运行的主体，原生引擎代码仅作为程序库。例如在Cocos2d-x中，可以完全使用Lua来编写游戏，而C++的Cocos2d-x引擎作为一个引擎库使用。</p>
<h5 id="1-4-Lua脚本"><a href="#1-4-Lua脚本" class="headerlink" title="1.4 Lua脚本"></a>1.4 Lua脚本</h5><p>Lua是一门轻量级、强大、高效的嵌入式脚本语言。据说嵌入式即意味着它需要嵌入到一个宿主程序中执行。宿主程序可以通过调用函数执行一小段Lua代码，以及读写Lua变量，还可以注入C函数让Lua代码调用。Lua提供了一些C函数接口，宿主程序可以通过这些C函数与Lua代码进行交互，这使得Lua可以应用于各种宿主环境，包括游戏引擎，用来扩展宿主程序定制能力。Lua的特性主要有以下：</p>
<ul>
<li>健壮：已经被应用在一些工业程序中、嵌入式系统中。Lua有很好的接口文档。</li>
<li>高效：Lua以快而著称，在直译的脚本语言中它几乎是最快的。</li>
<li>可移植：Lua可以运行在所有拥有标准C编译器的平台上，包括所有分支的UNIX和Windows平台上，以及移动平台上。</li>
<li>可嵌入：Lua是一个嵌入式语言，可以将Lua轻松的嵌入到宿主程序中。</li>
<li>轻量：简单而强大解析器和Lua库占用空间小。</li>
<li>免费：Lua是开源的。</li>
</ul>
<h3 id="2-Lua脚本语言的功能"><a href="#2-Lua脚本语言的功能" class="headerlink" title="2 Lua脚本语言的功能"></a>2 Lua脚本语言的功能</h3><p>不管选何种架构风格，脚本语言在运行时需要具备的功能是一致的。以Lua为例，运行时脚本语言的功能如下：</p>
<ul>
<li>对原生编程语言的接口</li>
<li>游戏对象句柄</li>
<li>在脚本中接受及处理事件</li>
<li>发送事件</li>
<li>面向对象脚本语言</li>
</ul>
<p>在后面章节中将具体介绍Lua和C++的交互以及在游戏引擎中的工作机制。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/24/Lua/1 脚本/" data-id="cjov31rid001e88riw9g0l4dq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/">Lua</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/8/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Cococs2d与OpenGL-ES/">Cococs2d与OpenGL ES</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos2d-C/">Cocos2d-C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos2d-Lua/">Cocos2d-Lua</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Cocos2d与OpenGL-ES/">Cocos2d与OpenGL ES</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cococs2d与OpenGL-ES/">Cococs2d与OpenGL ES</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cocos-C/">Cocos-C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cocos-Lua/">Cocos-Lua</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lua/">Lua</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Cococs2d与OpenGL-ES/" style="font-size: 12.5px;">Cococs2d与OpenGL ES</a> <a href="/tags/Cocos-C/" style="font-size: 20px;">Cocos-C++</a> <a href="/tags/Cocos-Lua/" style="font-size: 17.5px;">Cocos-Lua</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Lua/" style="font-size: 15px;">Lua</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/3.2 精灵/">3.2 精灵</a>
          </li>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/3.1（2） 纹理压缩及应用/">3.1(2) 纹理压缩及应用</a>
          </li>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/3.1（1） 纹理/">3.1 纹理</a>
          </li>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/3 全新的绘制系统/">全新的绘制系统</a>
          </li>
        
          <li>
            <a href="/2018/11/24/Cocos-C++-P/2.2 OpenGL ES 着色程序/">OpenGL ES着色程序</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Zenos<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>